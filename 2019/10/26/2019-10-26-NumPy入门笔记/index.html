

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Yuchen">
  <meta name="keywords" content="">
  <title>NumPy入门笔记 - Yuchen&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night-eighties.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Yuchen's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/main4.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-10-26 00:00" pubdate>
        2019年10月26日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      145
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">NumPy入门笔记</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="numpy学习笔记">Numpy学习笔记</h1>
<p>序：真的是想到哪里学到哪里，学东西不要管那么多，就当是“量子波动”学习知识，总有一天会成体系。</p>
<p>2019年10月25日 至 2019年10月28日</p>
<p># define " <strong>import numpy as np</strong> "</p>
<hr />
<h2 id="简介">简介</h2>
<p>​ NumPy是Python语言的一个扩充程序库。支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。Numpy内部解除了Python的PIL(全局解释器锁),运算效率极好,是大量机器学习框架的基础库!</p>
<p>​ NumPy 的前身 Numeric 最早是由 Jim Hugunin 与其它协作者共同开发，2005 年，Travis Oliphant 在 Numeric 中结合了另一个同性质的程序库 Numarray 的特色，并加入了其它扩展而开发了 NumPy。NumPy 为开放源代码并且由许多协作者共同维护开发。</p>
<hr />
<hr />
<h2 id="numpy-ndarray对象及常用操作">NumPy Ndarray对象及常用操作</h2>
<h3 id="基本属性">基本属性</h3>
<p>​ 这是一个N维数组对象，下标从0开始，且所有元素同类型、同内存大小，主要包含如下属性：</p>
<ul>
<li><p>ndarray.ndim</p>
<p>表示axes(axis复数)/dimensions 描述维度数字</p></li>
<li><p>ndarray.shape</p>
<p>返回元组，输出各个维度的大小</p>
<p>可以使用<code>reshape</code>函数来调整数组的形状</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])
b = a.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)
<span class="hljs-keyword">print</span> (b)</code></pre></div></li>
<li><p>ndarray.size</p>
<p>返回所有元素的个数（各个维度大小的乘积）</p></li>
<li><p>ndarray.dtype</p>
<p>返回数据的类型</p>
<p>​ "&gt;" 若首先取高字节的数据存放在低地址，则是大端法；</p>
<p>​ "&lt;" 若首先取低字节的数据存放在低地址，则是小端法；</p>
<ul>
<li><strong>自定义数据类型</strong></li>
</ul>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
student = np.dtype([(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;S20&#x27;</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;i1&#x27;</span>), (<span class="hljs-string">&#x27;marks&#x27;</span>, <span class="hljs-string">&#x27;f4&#x27;</span>)]) 
a = np.array([(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">50</span>),(<span class="hljs-string">&#x27;xyz&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">75</span>)], dtype = student) 
print(a)</code></pre></div></li>
<li><p>ndarray.itemsize</p>
<p>返回单个元素的大小（单位字节），等价于ndarray.dtype.itemsize</p></li>
<li><p>ndarray.data</p>
<p>一般不使用，这是存放数据的区域</p></li>
<li><p>其他参见numpy-ref文档</p>
<p>NumPy数组的维数称为<strong>秩（rank）</strong>，一维数组的秩为 1，二维数组的秩为2，以此类推。</p></li>
</ul>
<p>​ 在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量(秩)，就是数组的维数。W</p>
<p>​ <strong>很多时候可以声明 axis，axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。</strong></p>
<hr />
<h3 id="创建数组">创建数组</h3>
<ol type="1">
<li>使用函数创建新数组</li>
</ol>
<p><code>np.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p>
<p>对应参数解释：<code>object</code>数组或者嵌套数列；<code>dtype</code>元素类型可选；<code>copy</code>对象是否复制可选；<code>order</code>创建数组的样式（C行方向、F列方向、默认A任意方向）；<code>subok</code>默认返回一个与基类同类型的数组；<code>ndim</code>指定生成数组的最小维度。</p>
<p>还可以使用其他函数：</p>
<p><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.array.html#numpy.array"><code>array</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.zeros.html#numpy.zeros"><code>zeros</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.zeros_like.html#numpy.zeros_like"><code>zeros_like</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.ones.html#numpy.ones"><code>ones</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.ones_like.html#numpy.ones_like"><code>ones_like</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.empty.html#numpy.empty"><code>empty</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.empty_like.html#numpy.empty_like"><code>empty_like</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.arange.html#numpy.arange"><code>arange</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.linspace.html#numpy.linspace"><code>linspace</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/random/generated/numpy.random.RandomState.rand.html#numpy.random.RandomState.rand"><code>numpy.random.RandomState.rand</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/random/generated/numpy.random.RandomState.randn.html#numpy.random.RandomState.randn"><code>numpy.random.RandomState.randn</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.fromfunction.html#numpy.fromfunction"><code>fromfunction</code></a>, <a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.fromfile.html#numpy.fromfile"><code>fromfile</code></a></p>
<ol start="2" type="1">
<li>从已有对象创建新数组</li>
</ol>
<p><code>numpy.asarray(a, dtype = None, order = None)</code></p>
<p>a可以接受的参数为列表、列表的元组、元组、元组的元组、元组的列表、多为数组；数据类型可选；存放方式C/F。</p>
<p><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></p>
<p>numpy.frombuffer 用于实现动态数组。numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p>
<p><code>buffer</code>可以是任意对象，会以流的形式读入；<code>dtype</code>返回数组的数据类型可选；<code>count</code>读取的数据数量，默认为-1，读取所有数据；<code>offset</code>读取的起始位置，默认为0。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
s =  <span class="hljs-string">&#x27;Hello World&#x27;</span>
a = np.frombuffer(s, dtype =  <span class="hljs-string">&#x27;S1&#x27;</span>)
<span class="hljs-keyword">print</span> (a)
<span class="hljs-comment"># 输出</span>
<span class="hljs-comment"># [&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27; &#x27; &#x27;W&#x27; &#x27;o&#x27; &#x27;r&#x27; &#x27;l&#x27; &#x27;d&#x27;]</span></code></pre></div>
<p><code>numpy.fromiter(iterable, dtype, count=-1)</code></p>
<p>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</p>
<p><code>iterable</code>可迭代对象；<code>dtype</code>返回数组的数据类型；<code>count</code>读取的数据数量，默认为-1，读取所有数据。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 
<span class="hljs-comment"># 使用 range 函数创建列表对象  </span>
list=range(<span class="hljs-number">5</span>)
it=iter(list)
<span class="hljs-comment"># 使用迭代器创建 ndarray </span>
x=np.fromiter(it, dtype=float)
print(x)
<span class="hljs-comment">#输出</span>
<span class="hljs-comment"># [0. 1. 2. 3. 4.]</span></code></pre></div>
<ol start="3" type="1">
<li>使用数值范围创建数组</li>
</ol>
<p><code>numpy.arange(start, stop, step, dtype)</code></p>
<p>numpy.arange 根据 [start,stop)指定的范围，以及 step 设定的步长，生成一个 ndarray对象。</p>
<p><code>start</code>起始值，默认为0；<code>stop</code>终止值（不包含）；<code>step</code>步长，默认为1；<code>dtype</code>返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</p>
<p><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p>
<p>numpy.linspace 函数用于创建一个一维数组，该数组是一个<strong>等差数列</strong>构成的。</p>
<p><code>start</code>序列的起始值；<code>stop</code>序列的终止值，如果<code>endpoint</code>为true，该值包含于数列中；<code>num</code>要生成的等步长的样本数量，默认为50；<code>endpoint</code>该值为 ture 时，数列中中包含stop值，反之不包含，默认是True；<code>retstep</code>如果为 True 时，生成的数组中会显示间距，反之不显示；<code>dtype</code>ndarray 的数据类型。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
a =np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,retstep=<span class="hljs-literal">True</span>)
print(a)
<span class="hljs-comment"># 拓展例子</span>
b =np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>).reshape([<span class="hljs-number">10</span>,<span class="hljs-number">1</span>])
print(b)
<span class="hljs-comment">#输出</span>
<span class="hljs-comment"># (array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.]), 1.0)</span></code></pre></div>
<p><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p>
<p>numpy.logspace 函数用于创建一个于等比数列，值得注意的是：start和stop是数列的<strong>下标值</strong>，他们的底数是base。</p>
<p><code>start</code>序列的起始值为：base ** start；<code>stop</code>序列的终止值为：base ** stop，如果endpoint为true，该值包含于数列中；<code>num</code> 要生成的等步长的样本数量，默认为50；<code>endpoint</code>该值为 ture 时，数列中包含stop值，反之不包含，默认是True；<code>base</code>对数 log 的底数；<code>dtype</code>ndarray 的数据类型。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
a = np.logspace(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,base=<span class="hljs-number">2</span>)
<span class="hljs-keyword">print</span> (a)
<span class="hljs-comment"># [  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]</span></code></pre></div>
<hr />
<h3 id="数据类型">数据类型</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">名称</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bool_</td>
<td style="text-align: center;">布尔型数据类型（True 或者 False）</td>
</tr>
<tr class="even">
<td style="text-align: left;">int_</td>
<td style="text-align: center;">默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">intc</td>
<td style="text-align: center;">与 C 的 int 类型一样，一般是 int32 或 int 64</td>
</tr>
<tr class="even">
<td style="text-align: left;">intp</td>
<td style="text-align: center;">用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int8</td>
<td style="text-align: center;">字节（-128 to 127）</td>
</tr>
<tr class="even">
<td style="text-align: left;">int16</td>
<td style="text-align: center;">整数（-32768 to 32767）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int32</td>
<td style="text-align: center;">整数（-2147483648 to 2147483647）</td>
</tr>
<tr class="even">
<td style="text-align: left;">int64</td>
<td style="text-align: center;">整数（-9223372036854775808 to 9223372036854775807）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint8</td>
<td style="text-align: center;">无符号整数（0 to 255）</td>
</tr>
<tr class="even">
<td style="text-align: left;">uint16</td>
<td style="text-align: center;">无符号整数（0 to 65535）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint32</td>
<td style="text-align: center;">无符号整数（0 to 4294967295）</td>
</tr>
<tr class="even">
<td style="text-align: left;">uint64</td>
<td style="text-align: center;">无符号整数（0 to 18446744073709551615）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float_</td>
<td style="text-align: center;">float64 类型的简写</td>
</tr>
<tr class="even">
<td style="text-align: left;">float16</td>
<td style="text-align: center;">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float32</td>
<td style="text-align: center;">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td>
</tr>
<tr class="even">
<td style="text-align: left;">float64</td>
<td style="text-align: center;">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td>
</tr>
<tr class="odd">
<td style="text-align: left;">complex_</td>
<td style="text-align: center;">complex128 类型的简写，即 128 位复数</td>
</tr>
<tr class="even">
<td style="text-align: left;">complex64</td>
<td style="text-align: center;">复数，表示双 32 位浮点数（实数部分和虚数部分）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">complex128</td>
<td style="text-align: center;">复数，表示双 64 位浮点数（实数部分和虚数部分）</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="类型转换">类型转换</h3>
<ul>
<li><p>浮点数据转换</p>
<p>float64(默认)的数组转化为float32和float16的数组时，数组的长度会发生变化，分别变为原来的两倍和四倍。</p></li>
<li><p>整型数据转换</p>
<p>同上</p></li>
<li><p>浮点数转整数</p>
<p><code>numpy</code>中的数据类型转换，不能直接改原数据的dtype，只能用函数<code>astype()</code></p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
b=np.array([<span class="hljs-number">1.</span>,<span class="hljs-number">2.</span>,<span class="hljs-number">3.</span>,<span class="hljs-number">4.</span>]) <span class="hljs-comment"># 默认为float64,直接改变则数组长度会变化</span>
c=b.astype(int)
print(c)
print(c.shape)
print(c.dtype)</code></pre></div></li>
</ul>
<hr />
<h3 id="数组切片和索引">数组切片和索引</h3>
<p><strong>NumPy切片和普通索引</strong>，ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。ndarray 数组可以基于 0 – n 的下标进行索引，切片对象可以通过内置的 <code>slice()</code> 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。</p>
<div class="hljs"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">10</span>) <span class="hljs-comment"># [0 1 2 3 4 5 6 7 8 9]</span>
s = slice(<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>)   <span class="hljs-comment"># 从索引 2 开始到索引 7 停止，间隔为2</span>
<span class="hljs-keyword">print</span> (a[s])
<span class="hljs-comment"># 或者</span>
a = np.arange(<span class="hljs-number">10</span>)
b = a[<span class="hljs-number">2</span>:<span class="hljs-number">7</span>:<span class="hljs-number">2</span>]   <span class="hljs-comment"># 从索引 2 开始到索引 7 停止（不包括7），间隔为 2</span>
print(b)
<span class="hljs-comment"># 输出 [2  4  6]</span></code></pre></div>
<p><strong>冒号 " : "的解释：</strong>如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引<strong>(不包括停止索引)</strong>之间的项，list[start​ : end: ​step]start:起始位置、end:结束位置、step:步长，list[::-1]用于reverse。</p>
<p><strong>list[-1:]和list[:-1]的区别和联系：</strong> 这里面list[-1]是最后一个元素，所以等价于 <code>list[len-1:len]</code> 和 <code>list[0:len-1]</code> <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40576010/article/details/88426129">参考链接</a></p>
<p>切片还可以包括省略号 " … "，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p>
<div class="hljs"><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])  
<span class="hljs-keyword">print</span> (a[...,<span class="hljs-number">1</span>])   <span class="hljs-comment"># 第2列元素</span>
<span class="hljs-keyword">print</span> (a[<span class="hljs-number">1</span>,...])   <span class="hljs-comment"># 第2行元素</span>
<span class="hljs-keyword">print</span> (a[...,<span class="hljs-number">1</span>:])  <span class="hljs-comment"># 第2列及剩下的所有元素</span>
<span class="hljs-comment"># 输出</span>
<span class="hljs-comment"># [2 4 5]</span>
<span class="hljs-comment"># [3 4 5]</span>
<span class="hljs-comment"># [[2 3]</span>
<span class="hljs-comment">#  [4 5]</span>
<span class="hljs-comment">#  [5 6]]</span>
<span class="hljs-comment"># reversed a</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>print(a[ : :<span class="hljs-number">-1</span>])     
array([[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], 
       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], 
       [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])  
<span class="hljs-meta">&gt;&gt;&gt; </span>print(a[...,::<span class="hljs-number">-1</span>])
[[<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>]
 [<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>]
 [<span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>]]
<span class="hljs-meta">&gt;&gt;&gt; </span>print(a[::<span class="hljs-number">-1</span>,::<span class="hljs-number">-1</span>])
[[<span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>]
 [<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>]
 [<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>]]</code></pre></div>
<p><strong>NumPy 高级索引</strong>，NumPy 比一般的 Python 序列提供更多的索引方式。除了之前看到的用整数和切片的索引外，数组可以由<strong>整数数组索引（花式索引）、布尔索引</strong>（对应下面三段代码）。（花式索引？）</p>
<p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],  [<span class="hljs-number">5</span>,  <span class="hljs-number">6</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>x[x&gt;<span class="hljs-number">3</span>]
array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])
<span class="hljs-comment"># 以下实例使用了 ~（取补运算符）来过滤 NaN</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([np.nan, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, np.nan, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (a[~np.isnan(a)])
[<span class="hljs-number">1.</span> <span class="hljs-number">2.</span> <span class="hljs-number">3.</span> <span class="hljs-number">4.</span> <span class="hljs-number">5.</span>]
<span class="hljs-comment"># 还有a[np.iscomplex(a)]等</span></code></pre></div>
<p>花式索引指的是<strong>利用整数数组进行索引</strong>。花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。<strong>花式索引跟切片不一样，它总是将数据复制到新数组中。</strong></p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># 获取数组中(0,0)，(1,1)和(2,0)位置处的元素</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],  [<span class="hljs-number">5</span>,  <span class="hljs-number">6</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>y = x[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]] <span class="hljs-comment"># 二维数组的索引</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>y
array([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])
<span class="hljs-comment">#</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x=np.arange(<span class="hljs-number">32</span>).reshape((<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>x
array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],
       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],
       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],
       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],
       [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],
       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>],
       [<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>],
       [<span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>x[[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>]]
array([[<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],
       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],
       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],
       [<span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>]])
<span class="hljs-comment"># 传入多个索引数组（要使用np.ix_）</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x[np.ix_([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])]
array([[ <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],
       [<span class="hljs-number">20</span>, <span class="hljs-number">23</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>],
       [<span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>],
       [ <span class="hljs-number">8</span>, <span class="hljs-number">11</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]])</code></pre></div>
<p>寻找数组中的最大值和最小值索引可使用np.argmax(arr.axis = 0/1) , np.argmin(arr, axis = 0/1)不写axis则返回整个数组的最大值的索引（1个），0轴为列方向，1轴为行方向。</p>
<ul>
<li>生成随机数（ <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016097466">链接</a> ）</li>
</ul>
<hr />
<h3 id="数组广播">数组广播</h3>
<p>NumPy广播(Broadcast)，广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p>
<ul>
<li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在shape前面加 1 补齐维度。（3,4）+（3,）补齐（1,3）</li>
<li>输出数组的形状是输入数组形状的各个维度上的最大值。</li>
<li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。（x*y，y的维度与x中的子维度相同则可以运算）</li>
</ul>
<hr />
<h3 id="迭代数组">迭代数组</h3>
<p>参考链接：<a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.nditer.html?highlight=nditer#numpy.nditer" class="uri">https://numpy.org/devdocs/reference/generated/numpy.nditer.html?highlight=nditer#numpy.nditer</a></p>
<p>NumPy 迭代数组，NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式，迭代器最基本的任务的可以完成对数组元素的访问。</p>
<p><code>np.nditer(op, flags=['multi_index'], op_flags=['readwrite'])</code></p>
<p><code>op</code> ndarray 或者是序列；<code>flags</code> 可选项，字符串序列,用于控制迭代器行为；<code>op_flags</code> 可选项，字符串列表,可选值有 <strong>readonly, readwrite, or writeonly</strong>。</p>
<ul>
<li>数组x和x.T的存储方式是一样的，使用迭代当时输出也是一样的。</li>
<li>使用C（按照行输出）和F（按照列输出）迭代显式出的结果不一致。</li>
</ul>
<div class="hljs"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.nditer(x):
<span class="hljs-meta">... </span>    print(i,end = <span class="hljs-string">&quot; &quot;</span>)
...
<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span></code></pre></div>
<p>nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。</p>
<div class="hljs"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">60</span>,<span class="hljs-number">5</span>) 
a = a.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)  
<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;原始数组是：&#x27;</span>)
<span class="hljs-keyword">print</span> (a)
<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;\n&#x27;</span>)
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> np.nditer(a, op_flags=[<span class="hljs-string">&#x27;readwrite&#x27;</span>]): 
    x[...]=<span class="hljs-number">2</span>*x 
<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;修改后的数组是：&#x27;</span>)
<span class="hljs-keyword">print</span> (a)</code></pre></div>
<p>nditer类的构造器拥有flags参数，它可以接受下列值：<code>c_index</code> 跟踪C顺序索引；<code>f_index</code> 跟踪Fortran顺序索引；<code>external_loop</code>输出值时具有多个值的一维数组。</p>
<p>如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 （3，4），数组 b 的维度为 （4，） ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">60</span>,<span class="hljs-number">5</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>b = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>a
array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>],
       [<span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>],
       [<span class="hljs-number">40</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">55</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>b
array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> np.nditer([a,b]):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;%d:%d&quot;</span>  %  (x,y), end=<span class="hljs-string">&quot;, &quot;</span> )
...
<span class="hljs-number">0</span>:<span class="hljs-number">1</span>, <span class="hljs-number">5</span>:<span class="hljs-number">2</span>, <span class="hljs-number">10</span>:<span class="hljs-number">3</span>, <span class="hljs-number">15</span>:<span class="hljs-number">4</span>, <span class="hljs-number">20</span>:<span class="hljs-number">1</span>, <span class="hljs-number">25</span>:<span class="hljs-number">2</span>, <span class="hljs-number">30</span>:<span class="hljs-number">3</span>, <span class="hljs-number">35</span>:<span class="hljs-number">4</span>, <span class="hljs-number">40</span>:<span class="hljs-number">1</span>, <span class="hljs-number">45</span>:<span class="hljs-number">2</span>, <span class="hljs-number">50</span>:<span class="hljs-number">3</span>, <span class="hljs-number">55</span>:<span class="hljs-number">4</span>,</code></pre></div>
<hr />
<h3 id="数组相关操作">数组相关操作</h3>
<ul>
<li><p>修改数组形状 <code>numpy.reshape</code> <code>numpy.ndarray.flat</code></p>
<p>函数返回一个数组元素迭代器</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>x
array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],
       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],
       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>x.flat
&lt;numpy.flatiter object at <span class="hljs-number">0x000001E7D0570910</span>&gt;</code></pre></div>
<p><code>numpy.ndarray.flatten</code></p>
<p>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.flatten()
array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])</code></pre></div>
<p><code>numpy.ravel</code></p>
<p>返回一个连续的被展开的数组。等同于x.reshape(-1, order=order)，修改会引起原来数组的变化。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = np.ravel(x,order= <span class="hljs-string">&quot;A&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>y
array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>y[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>y
array([<span class="hljs-number">100</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">4</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">6</span>,   <span class="hljs-number">7</span>,   <span class="hljs-number">8</span>,   <span class="hljs-number">9</span>,  <span class="hljs-number">10</span>,  <span class="hljs-number">11</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>x
array([[<span class="hljs-number">100</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">3</span>],
       [  <span class="hljs-number">4</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">6</span>,   <span class="hljs-number">7</span>],
       [  <span class="hljs-number">8</span>,   <span class="hljs-number">9</span>,  <span class="hljs-number">10</span>,  <span class="hljs-number">11</span>]])</code></pre></div></li>
<li><p>翻转数组 <code>numpy.transpose</code></p>
<p>用于对换数组的维度，<code>numpy.transpose(arr, axes)</code>，<code>arr</code>：要操作的数组；<code>axes</code>：整数列表，对应维度，通常所有维度都会对换。功能同arr.T，转置。</p>
<p><code>numpy.rollaxis</code></p>
<p>函数向后滚动特定的轴到一个特定位置，<code>numpy.rollaxis(arr, axis, start)</code>，<code>arr</code>：数组；<code>axis</code>：要向后滚动的轴，其它轴的相对位置不会改变；<code>start</code>：<strong>默认为零，表示完整的滚动</strong>。会滚动到特定位置。</p>
<p><code>numpy.swapaxes</code></p>
<p><code>numpy.swapaxes(arr, axis1, axis2)</code>， 函数用于交换数组的两个轴 axis1和axis2。</p></li>
<li><p>修改数组维度 <code>numpy.broadcast</code></p>
<p>用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。该函数使用两个数组作为输入参数 。</p></li>
</ul>
<p><code>numpy.broadcast_to</code></p>
<p>函数<code>numpy.broadcast_to(array, shape, subok)</code> 将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError 。</p>
<p><code>numpy.expand_dims</code></p>
<p>函数通过在指定位置插入新的轴来扩展数组形状 <code>numpy.expand_dims(arr, axis)</code> 。</p>
<p><code>numpy.squeeze</code></p>
<p>函数<code>numpy.squeeze(arr, axis)</code> 从给定数组的形状中删除一维（该维度数值必须为1）的条目 。</p>
<ul>
<li><p>连接数组 <code>numpy.concatenate</code></p>
<p>函数 <code>numpy.concatenate((a1, a2, ...), axis)</code> 用于沿指定轴连接相同形状的两个或多个数组。</p></li>
</ul>
<div class="hljs"><pre><code class="hljs shell">第一个数组：
[[1 2]
 [3 4]]
  
第二个数组：
  [[5 6]
   [7 8]]
  
沿轴 0 连接两个数组：
  [[1 2]
   [3 4]
   [5 6]
   [7 8]]
  
沿轴 1 连接两个数组：
  [[1 2 5 6]
   [3 4 7 8]]</code></pre></div>
<p><code>numpy.stack</code></p>
<p>函数<code>numpy.stack((a1,a2,...), axis)</code> 用于沿新轴连接数组序列 。（维度会加1）</p>
<p><div class="hljs"><pre><code class="hljs shell">第一个数组：
[[1 2]
  [3 4]]
  
第二个数组：
[[5 6]
 [7 8]]
  
沿轴 0 堆叠两个数组：
  [[[1 2]
    [3 4]]
  
   [[5 6]
    [7 8]]]
  
  沿轴 1 堆叠两个数组：
  [[[1 2]
    [5 6]]
  
   [[3 4]
    [7 8]]]</code></pre></div></p>
<p><code>numpy.hstack</code></p>
<p>numpy.stack 函数的变体，它通过水平堆叠来生成数组 <code>np.hstack((a,b))</code> 。</p>
<p><div class="hljs"><pre><code class="hljs shell">第一个数组：
[[1 2]
 [3 4]]  
第二个数组：
[[5 6]
 [7 8]]  
水平堆叠：
[[1 2 5 6]
 [3 4 7 8]]</code></pre></div></p>
<p><code>numpy.vstack</code></p>
<p><div class="hljs"><pre><code class="hljs shell">第一个数组：
  [[1 2]
   [3 4]] 
第二个数组：
  [[5 6]
   [7 8]]
竖直堆叠：
  [[1 2]
   [3 4]
   [5 6]
   [7 8]]</code></pre></div></p>
<ul>
<li><p>分割数组 <code>numpy.split</code></p>
<p>函数<code>numpy.split(ary, indices_or_sections, axis)</code> 沿特定的轴将数组分割为子数组 。<code>ary</code>：被分割的数组<code>indices_or_sections</code>：如果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）<code>axis</code>：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分。</p>
<p>For example, <code>[2, 3]</code> would, for <code>axis=0</code>, result in ary[:2]、ary[2:3]、ary[3:]。</p>
<p><code>numpy.hsplit</code></p>
<div class="hljs"><pre><code class="hljs shell">原array：
[[4. 7. 6. 3. 2. 6.]
 [6. 3. 6. 7. 9. 7.]]
np.hsplit(harr, 3)拆分后：
[array([[4., 7.],
       [6., 3.]]), array([[6., 3.],
       [6., 7.]]), array([[2., 6.],
       [9., 7.]])]</code></pre></div>
<p><code>numpy.vsplit</code></p>
<div class="hljs"><pre><code class="hljs shell">第一个数组：
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
np.vsplit(a,2)竖直分割：
[array([[0, 1, 2, 3],
       [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],
       [12, 13, 14, 15]])]</code></pre></div></li>
<li><p>数组元素的添加与删除 <code>numpy.resize</code></p>
<p>函数 <code>numpy.resize(arr, shape)</code> 返回指定大小的新数组。<strong>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</strong></p>
<p><code>numpy.append</code></p>
<p>函数<code>numpy.append(arr, values, axis=None)</code> 在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 输入数组的维度必须匹配否则将生成ValueError。</p>
<p><code>arr</code>：输入数组；<code>values</code>：要向<code>arr</code>添加的值，需要和<code>arr</code>形状相同（除了要添加的轴）；<code>axis</code>：默认为 None。<strong>当axis无定义时，是横向加成，返回总是为一维数组！</strong>当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</p>
<p><strong>append 函数返回的始终是一个一维数组。</strong></p>
<div class="hljs"><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])
<span class="hljs-keyword">print</span> (np.append(a, [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]))
<span class="hljs-keyword">print</span> (np.append(a, [[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]],axis = <span class="hljs-number">0</span>))
<span class="hljs-keyword">print</span> (np.append(a, [[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]],axis = <span class="hljs-number">1</span>))
第一个数组：
[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
 [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]]
向数组添加元素：
[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]
沿轴 <span class="hljs-number">0</span> 添加元素：
[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
 [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]
 [<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]]
沿轴 <span class="hljs-number">1</span> 添加元素：
[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span>]
 [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]]</code></pre></div>
<p><code>numpy.insert</code></p>
<p>函数<code>numpy.insert(arr, obj, values, axis)</code> 在给定索引之前，沿给定轴在输入数组中插入值。 如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p>
<p><code>arr</code>：输入数组；<code>obj</code>：在其之前插入值的索引；<code>values</code>：要插入的值；<code>axis</code>：沿着它插入的轴，如果未提供，则输入数组会被展开。该操作会广播值数组来配输入数组。</p>
<div class="hljs"><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])
<span class="hljs-keyword">print</span> (a)
<span class="hljs-keyword">print</span> (np.insert(a,<span class="hljs-number">3</span>,[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]))
<span class="hljs-keyword">print</span> (np.insert(a,<span class="hljs-number">1</span>,[<span class="hljs-number">11</span>],axis = <span class="hljs-number">0</span>))
<span class="hljs-keyword">print</span> (np.insert(a,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,axis = <span class="hljs-number">1</span>))
第一个数组：
[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]
 [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]
 [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]]
未传递 Axis 参数。 在插入之前输入数组会被展开。
[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>]
传递了 Axis 参数。 会广播值数组来配输入数组。
沿轴 <span class="hljs-number">0</span> 广播：
[[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>]
 [<span class="hljs-number">11</span> <span class="hljs-number">11</span>]
 [ <span class="hljs-number">3</span>  <span class="hljs-number">4</span>]
 [ <span class="hljs-number">5</span>  <span class="hljs-number">6</span>]]
沿轴 <span class="hljs-number">1</span> 广播：
[[ <span class="hljs-number">1</span> <span class="hljs-number">11</span>  <span class="hljs-number">2</span>]
 [ <span class="hljs-number">3</span> <span class="hljs-number">11</span>  <span class="hljs-number">4</span>]
 [ <span class="hljs-number">5</span> <span class="hljs-number">11</span>  <span class="hljs-number">6</span>]]</code></pre></div>
<p><code>numpy.delete</code></p>
<p>函数<code>Numpy.delete(arr, obj, axis)</code> 返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p>
<p><code>arr</code>：输入数组；<code>obj</code>：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组；<code>axis</code>：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开。</p>
<div class="hljs"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
<span class="hljs-keyword">print</span> (a)
<span class="hljs-keyword">print</span> (np.delete(a,<span class="hljs-number">5</span>))
<span class="hljs-keyword">print</span> (np.delete(a,<span class="hljs-number">1</span>,axis = <span class="hljs-number">0</span>))
<span class="hljs-keyword">print</span> (np.delete(a,<span class="hljs-number">1</span>,axis = <span class="hljs-number">1</span>))
a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>])
<span class="hljs-keyword">print</span> (np.delete(a, np.s_[::<span class="hljs-number">2</span>])) <span class="hljs-comment"># np.s_[::2] = slice(none,none,2)</span>
第一个数组：
[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]  <span class="hljs-comment"># 第一行</span>
 [ <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]  <span class="hljs-comment"># 第二行</span>
 [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]
未传递 Axis 参数。 在删除之前输入数组会被展开。
[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]
删除第二行：
[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],
 [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]]
删除第二列：
[[ <span class="hljs-number">0</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]
 [ <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]
 [ <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]
包含从数组中删除的替代值的切片：
[ <span class="hljs-number">2</span>  <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">8</span> <span class="hljs-number">10</span>]</code></pre></div>
<p><code>numpy.unique</code></p>
<p>函数<code>numpy.unique(arr, return_index, return_inverse, return_counts)</code> 用于去除数组中的重复元素。</p>
<p><code>arr</code>：输入数组，如果不是一维数组则会展开；<code>return_index</code>：如果为<code>true</code>，返回新列表元素在旧列表中的位置（下标），并以列表形式存储；<code>return_inverse</code>：如果为<code>true</code>，返回旧列表元素在新列表中的位置（下标），并以列表形式存储；<code>return_counts</code>：如果为<code>true</code>，返回去重数组中的元素在原数组中的出现次数。</p>
<div class="hljs"><pre><code class="hljs python">a = np.array([<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>])
<span class="hljs-keyword">print</span> (a)
第一个数组：
[<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span>]

u,indices = np.unique(a, return_index = <span class="hljs-literal">True</span>)
print(u)
<span class="hljs-keyword">print</span> (indices)
第一个数组的去重值：
[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]
去重数组的索引数组：
[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]

u,indices = np.unique(a,return_inverse = <span class="hljs-literal">True</span>)
<span class="hljs-keyword">print</span> (u)
<span class="hljs-keyword">print</span> (indices)
<span class="hljs-keyword">print</span> (u[indices])
去重数组的下标：
[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]
下标为：
[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span>]
使用下标重构原数组：
[<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span>]

u,indices = np.unique(a,return_counts = <span class="hljs-literal">True</span>)
<span class="hljs-keyword">print</span> (u)
<span class="hljs-keyword">print</span> (indices)
返回去重元素的重复数量：
[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]
[<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]</code></pre></div></li>
</ul>
<hr />
<h3 id="位运算">位运算</h3>
<p><code>bitwise_and</code> 对数组元素执行位与操作 <code>bitwise_or</code> 对数组元素执行位或操作 <code>invert</code> 按位取反 <code>left_shift</code> 向左移动二进制表示的位 <code>right_shift</code> 向右移动二进制表示的位</p>
<p><strong>注：也可以使用 “&amp;”、 “~”、 “|” 和 “^” 等操作符进行计算。</strong></p>
<hr />
<h3 id="字符串数组">字符串数组</h3>
<p>NumPy 字符串函数，字符数组类（numpy.char）中定义了一些函数，这些函数用于对 dtype 为 numpy.string_ 或 numpy.unicode_ 的数组执行向量化字符串操作，它们基于 Python 内置库中的标准字符串函数。</p>
<p><code>numpy.char.add()</code> 依次对两个数组的元素进行字符串连接 。</p>
<p><code>numpy.char.multiply()</code> 对字符串执行多重连接。</p>
<div class="hljs"><pre><code class="hljs python">np.char.multiply(<span class="hljs-string">&#x27;geek-docs &#x27;</span>,<span class="hljs-number">3</span>) <span class="hljs-comment"># geek-docs geek-docs geek-docs</span></code></pre></div>
<p><code>numpy.char.center()</code> 用于将字符串居中，并使用指定字符在左侧和右侧进行填充。</p>
<p><code>numpy.char.capitalize()</code> 将字符串的第一个字母转换为大写 。</p>
<p><code>numpy.char.title()</code> 将字符串的每个单词的第一个字母转换为大写 。</p>
<p><code>numpy.char.lower()</code> 对数组的每个元素转换为小写。它对每个元素调用 str.lower 。</p>
<p><code>numpy.char.upper()</code> 对数组的每个元素转换为大写。它对每个元素调用 str.upper 。</p>
<p><code>numpy.char.split()</code> 指定分隔符对字符串进行分割，并返回数组。默认情况下，分隔符为空格。</p>
<p><code>numpy.char.splitlines()</code> 以换行符作为分隔符来分割字符串，并返回数组。</p>
<p><code>numpy.char.strip()</code> 用于移除开头或结尾处的特定字符。</p>
<p><code>numpy.char.join()</code> 通过指定分隔符来连接数组中的元素或字符串 。</p>
<p><code>numpy.char.replace()</code> 函数使用新字符串替换字符串中的所有子字符串。</p>
<p><code>numpy.char.encode()</code> 对数组中的每个元素调用 str.encode 函数。 默认编码是'utf-8'，可以使用标准 Python 库中的编解码器。</p>
<p><code>numpy.char.decode()</code> 函数对编码的元素进行 str.decode() 解码。</p>
<div class="hljs"><pre><code class="hljs python">a = np.char.encode(<span class="hljs-string">&#x27;geek-docs&#x27;</span>, <span class="hljs-string">&#x27;cp500&#x27;</span>)
print(a)  <span class="hljs-comment"># b&#x27;\x87\x85\x85\x92`\x84\x96\x83\xa2&#x27;</span>
print(np.char.decode(a, <span class="hljs-string">&#x27;cp500&#x27;</span>)) <span class="hljs-comment"># geek-docs</span></code></pre></div>
<hr />
<h3 id="数学函数与计算">数学函数与计算</h3>
<ul>
<li><p><strong>三角函数</strong></p>
<p><code>cos</code> <code>cosh</code> <code>sin</code> <code>sinh</code> <code>tan</code> <code>tanh</code> （ 一般三角函数和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0/8704306?fr=aladdin">双曲函数</a> ）</p>
<p><code>arccos</code> <code>arccosh</code> <code>arcsin</code> <code>arcsinh</code> <code>arctan</code> <code>arctanh</code> （反三角函数）</p></li>
</ul>
<div class="hljs"><pre><code class="hljs python">cos = np.cos(a*np.pi/<span class="hljs-number">180</span>)
inv = np.arccos(cos)
np.degrees(inv)(弧度转化为度数)</code></pre></div>
<ul>
<li><p><strong>四舍五入函数</strong></p>
<p><code>numpy.around(array,decimals)</code></p>
<p>decimals默认为0，n表示保留到小数点后n位，-n表示保留到小数点前n位置。</p></li>
<li><p><strong>向上、下取整</strong></p>
<p><code>numpy.ceil()</code> <code>numpy.floor()</code></p></li>
<li><p><strong>算数函数</strong></p>
<p><code>add()</code> <code>subtract()</code> <code>multiply()</code> <code>divide()</code> 加减乘除</p>
<p><code>numpy.reciprocal()</code> 函数返回参数逐元素的倒数</p>
<p><code>numpy.power()</code> 第一个输入数组中的元素作为底数，第二个输入为幂</p>
<p><code>numpy.mod()</code> 求余，函数 <code>numpy.remainder()</code> 也产生相同的结果。</p></li>
<li><p><strong>统计函数</strong></p>
<p><strong>(不使用axis参数则返回所有元素的最大、最小值)</strong></p>
<p><code>numpy.amin(arr, axis)</code> 用于计算数组中的元素沿指定轴的最小值。</p>
<p><code>numpy.amax(arr, axis)</code> 用于计算数组中的元素沿指定轴的最大值。</p>
<p><code>numpy.ptp(arr, axis)</code> 计算数组中元素最大值与最小值的差（最大值 – 最小值）</p>
<p><code>numpy.percentile(a, q, axis,keepdims=false)</code></p>
<p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。</p>
<p>a是输入数组，q是计算的百分位数，axis为轴向，keepdims为true保持原形状。</p>
<p><code>numpy.median()</code> 函数用于计算数组 a 中元素的中位数（中值）</p>
<p><code>numpy.mean()</code></p>
<p>函数返回数组中元素的算术平均值。</p>
<p>如果提供了轴，则沿其计算。算术平均值是沿轴的元素的总和除以元素的数量。</p>
<p><code>numpy.average(arr, axis, weights, returned)</code></p>
<p>函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。 该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。 如果 <code>returned</code> 参数设为 true，则返回 (average, sum_of_weights) 。</p>
<p><code>numpy.std(a, axis=None, dtype=None)</code></p>
<p>标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。</p>
<p>标准差的计算等同于 <code>std = sqrt(mean(abs(x - x.mean())**2))</code></p></li>
<li><p><strong>排序函数</strong></p>
<p><code>numpy.sort(a, axis, kind, order)</code></p>
<p>返回待排序数组的有序副本。<code>kind</code> 可以选择排序方法，默认quicksort，如果数组包含字段，则设置order根据字段排序。默认为升序排序降序排列（ np.sort(arr)[::-1]）。</p>
<div class="hljs"><pre><code class="hljs python">dt = np.dtype([(<span class="hljs-string">&#x27;name&#x27;</span>,  <span class="hljs-string">&#x27;S10&#x27;</span>),(<span class="hljs-string">&#x27;age&#x27;</span>,  int)]) 
a = np.array([(<span class="hljs-string">&quot;raju&quot;</span>,<span class="hljs-number">21</span>),(<span class="hljs-string">&quot;anil&quot;</span>,<span class="hljs-number">25</span>),(<span class="hljs-string">&quot;ravi&quot;</span>,  <span class="hljs-number">17</span>),  (<span class="hljs-string">&quot;amar&quot;</span>,<span class="hljs-number">27</span>)], dtype = dt)  
<span class="hljs-keyword">print</span> (np.sort(a, order =  <span class="hljs-string">&#x27;name&#x27;</span>))
<span class="hljs-comment"># 结果</span>
我们的数组是：
[(<span class="hljs-string">b&#x27;raju&#x27;</span>, <span class="hljs-number">21</span>) (<span class="hljs-string">b&#x27;anil&#x27;</span>, <span class="hljs-number">25</span>) (<span class="hljs-string">b&#x27;ravi&#x27;</span>, <span class="hljs-number">17</span>) (<span class="hljs-string">b&#x27;amar&#x27;</span>, <span class="hljs-number">27</span>)]
按 name 排序：
[(<span class="hljs-string">b&#x27;amar&#x27;</span>, <span class="hljs-number">27</span>) (<span class="hljs-string">b&#x27;anil&#x27;</span>, <span class="hljs-number">25</span>) (<span class="hljs-string">b&#x27;raju&#x27;</span>, <span class="hljs-number">21</span>) (<span class="hljs-string">b&#x27;ravi&#x27;</span>, <span class="hljs-number">17</span>)]</code></pre></div>
<p><code>numpy.argsort()</code> 函数返回的是数组值从小到大的索引值。</p>
<div class="hljs"><pre><code class="hljs python">x = np.array([<span class="hljs-number">3</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>])
y = np.argsort(x)
x[y]
我们的数组是：
[<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>]
对 x 调用 argsort() 函数，返回所以：
[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>]
以排序后的索引，顺序重构原数组：
[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]</code></pre></div>
<p><code>numpy.lexsort()</code> 用于对多个序列进行排序，返回其索引。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p>
<p>小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p>
<div class="hljs"><pre><code class="hljs python">nm =  (<span class="hljs-string">&#x27;raju&#x27;</span>,<span class="hljs-string">&#x27;anil&#x27;</span>,<span class="hljs-string">&#x27;ravi&#x27;</span>,<span class="hljs-string">&#x27;amar&#x27;</span>) 
dv =  (<span class="hljs-string">&#x27;f.y.&#x27;</span>,  <span class="hljs-string">&#x27;s.y.&#x27;</span>,  <span class="hljs-string">&#x27;s.y.&#x27;</span>,  <span class="hljs-string">&#x27;f.y.&#x27;</span>) 
ind = np.lexsort((dv,nm))  
<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;调用 lexsort() 函数：&#x27;</span>) 
<span class="hljs-keyword">print</span> (ind) 
<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;使用这个索引来获取排序后的数据：&#x27;</span>) 
<span class="hljs-keyword">print</span> ([nm[i]  +  <span class="hljs-string">&quot;, &quot;</span>  + dv[i]  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ind])

调用 lexsort() 函数：
[<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span>]
使用这个索引来获取排序后的数据：
[<span class="hljs-string">&#x27;amar, f.y.&#x27;</span>, <span class="hljs-string">&#x27;anil, s.y.&#x27;</span>, <span class="hljs-string">&#x27;raju, f.y.&#x27;</span>, <span class="hljs-string">&#x27;ravi, s.y.&#x27;</span>]</code></pre></div>
<p><code>msort(a)</code></p>
<p>数组按第一个轴排序，返回排序后的数组副本，相等于 np.sort(a, axis=0)。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>np.msort(result)
array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],
       [ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>],
       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],
       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],
       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],
       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>result
array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],
       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>],
       [ <span class="hljs-number">4</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],
       [ <span class="hljs-number">1</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">12</span>],
       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">4</span>],
       [ <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">5</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>np.sort(result,axis = <span class="hljs-number">0</span>)
array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],
       [ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>],
       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],
       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],
       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],
       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]])</code></pre></div>
<p><code>sort_complex(a)</code> 对复数按照先实部后虚部的顺序进行排序。</p>
<p><code>partition(a, kth[, axis, kind, order])</code></p>
<p>指定一个数，对数组进行分区。</p>
<p><code>np.partition</code> 的工作流程可以看做是先对数组排序（升序），然后以索引是kth的元素为基准，将元素分成两部分，即大于该元素的放在其后面，小于该元素的放在其前面，这里有点类似于快排。常用于求一个数组的前k（k = kth+1求最小，k = kth求最大）个最值元素，时间复杂度很低 O(n) 。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42001089/article/details/89204112">参考链接</a></p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>result = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>,(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>result
array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],
       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>],
       [ <span class="hljs-number">4</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],
       [ <span class="hljs-number">1</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">12</span>],
       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">4</span>],
       [ <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">5</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>result1 = np.sort(result,axis=<span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>result1
array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],
       [ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>],
       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],
       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],
       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],
       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>result2 = np.partition(result, kth=<span class="hljs-number">1</span>, axis=<span class="hljs-number">0</span>)[:<span class="hljs-number">2</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>result2  <span class="hljs-comment"># 求每一列前k = 2小,所以参数kth = 1</span>
array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
       [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>result3 = np.partition(result, kth=<span class="hljs-number">-2</span>, axis=<span class="hljs-number">1</span>)[::,<span class="hljs-number">-2</span>:]
<span class="hljs-meta">&gt;&gt;&gt; </span>result3  <span class="hljs-comment"># 求每一行最大k = 2个元素，</span>
array([[ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],
       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],
       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],
       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],
       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>],
       [ <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>]])</code></pre></div>
<p><code>argpartition(a, kth[, axis, kind, order])</code></p>
<p>类似上面的函数，常用于求一个数组的前k个最值元素的索引，可以通过关键字 kind 指定算法（默认"introselect"），沿着指定轴axis对数组进行分区。(introselect参考快排过程)</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
a = np.array([<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>])
print(np.argpartition(a, <span class="hljs-number">4</span>)) <span class="hljs-comment">#将数组a中所有元素（包括重复元素）从小到大排列，比索引为第5的元素小的放在前面，大的放在后面（除了第五个元素，其余元素可能都是乱序的），输出新数组索引。</span>
&gt;&gt; [<span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">0</span>]
a[np.argpartition(a, <span class="hljs-number">4</span>)]     <span class="hljs-comment">#输出新数组索引对应的数组</span>
&gt;&gt; array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])
a[np.argpartition(a, <span class="hljs-number">-5</span>)[<span class="hljs-number">-5</span>:]] <span class="hljs-comment"># 输出top5</span>
&gt;&gt; array([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>result3 = result[np.c_[np.arange(result.shape[<span class="hljs-number">0</span>]),np.arange(result.shape[<span class="hljs-number">0</span>])],np.argpartition(result, kth=<span class="hljs-number">-2</span>, axis=<span class="hljs-number">1</span>)[:,<span class="hljs-number">-2</span>:]]
<span class="hljs-meta">&gt;&gt;&gt; </span>result3 <span class="hljs-comment"># 操作略复杂，直接partition可以得到一样的效果，两者相同</span>
array([[ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],
       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],
       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],
       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],
       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>],
       [ <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>]])条件筛选函数</code></pre></div></li>
<li><p>条件筛选函数</p>
<p><code>numpy.argmax()</code> 和 <code>numpy.argmin()</code> 返回最大值和最小值索引</p>
<p><code>numpy.nonzero()</code> 返回非0值索引</p>
<div class="hljs"><pre><code class="hljs python"> <span class="hljs-comment"># 对应两个两个维度的坐标我们的数组是：</span>
[[<span class="hljs-number">30</span> <span class="hljs-number">40</span>  <span class="hljs-number">0</span>]
 [ <span class="hljs-number">0</span> <span class="hljs-number">20</span> <span class="hljs-number">10</span>]
 [<span class="hljs-number">50</span>  <span class="hljs-number">0</span> <span class="hljs-number">60</span>]]
调用 nonzero() 函数：
(array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], dtype=int64), array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>], dtype=int64)) <span class="hljs-comment"># 对应两个两个维度的坐标</span></code></pre></div>
<p><code>numpy.where()</code> 根据条件返回符合的元素的索引</p>
<div class="hljs"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">9.</span>).reshape(<span class="hljs-number">3</span>,  <span class="hljs-number">3</span>)  
y = np.where(x &gt;  <span class="hljs-number">3</span>)  
x[y] <span class="hljs-comment"># 根据索引求原来的元素</span>
我们的数组是：
[[<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">2.</span>]
 [<span class="hljs-number">3.</span> <span class="hljs-number">4.</span> <span class="hljs-number">5.</span>]
 [<span class="hljs-number">6.</span> <span class="hljs-number">7.</span> <span class="hljs-number">8.</span>]]
大于 <span class="hljs-number">3</span> 的元素的索引：
(array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]), array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])) <span class="hljs-comment"># y是元组</span>
使用这些索引来获取满足条件的元素：
[<span class="hljs-number">4.</span> <span class="hljs-number">5.</span> <span class="hljs-number">6.</span> <span class="hljs-number">7.</span> <span class="hljs-number">8.</span>]</code></pre></div>
<p><code>numpy.extract()</code> 也是返回一定满足一定条件的元素。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>arr
array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],
       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],
       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>condition = np.mod(arr, <span class="hljs-number">3</span>)==<span class="hljs-number">0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>condition
array([[ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>],
       [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>],
       [<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>]])
<span class="hljs-meta">&gt;&gt;&gt; </span>np.extract(condition, arr)
array([<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])
<span class="hljs-comment"># condition是布尔型的，等价于array[condition]</span></code></pre></div></li>
<li><p><strong>字节交换</strong></p>
<p><code>numpy.ndarray.byteswap()</code> 大小端的转化，参数为True</p></li>
<li><p><strong>NumPy 副本和视图</strong></p>
<p><code>np.ndarray.view()</code> 创建一个新的数组对象，该方法创建的新数组的维数改变不会更改原始数据的维数。修改元素会改变原始值。</p>
<p>但是， 使用切片创建视图修改数据<strong>会影响到</strong>原始数组 。</p>
<div class="hljs"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">12</span>)
arr
a=arr[<span class="hljs-number">3</span>:]
b=arr[<span class="hljs-number">3</span>:]
a[<span class="hljs-number">1</span>]=<span class="hljs-number">123</span>
b[<span class="hljs-number">2</span>]=<span class="hljs-number">234</span>
arr
id(a),id(b),id(arr[<span class="hljs-number">3</span>:])
我们的数组：
[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]
创建切片：
[  <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span> <span class="hljs-number">123</span> <span class="hljs-number">234</span>   <span class="hljs-number">6</span>   <span class="hljs-number">7</span>   <span class="hljs-number">8</span>   <span class="hljs-number">9</span>  <span class="hljs-number">10</span>  <span class="hljs-number">11</span>]
<span class="hljs-number">2142679040208</span> <span class="hljs-number">2142679040288</span> <span class="hljs-number">2142816278048</span>
<span class="hljs-comment"># 变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。</span></code></pre></div>
<p><code>np.ndarray.copy()</code> 创建一个副本，对副本数据进行修改，不会影响原始数据，物理内存不在一个位置。</p>
<p><strong>无复制： </strong> <strong>简单的赋值</strong> 不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p></li>
</ul>
<hr />
<h2 id="矩阵">矩阵</h2>
<h3 id="简介-1">简介</h3>
<p>NumPy 矩阵库(Matrix)，NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。一个 m x n 的矩阵是一个由m行(row)n列（column）元素排列成的矩形阵列。</p>
<h3 id="相关函数">相关函数</h3>
<ul>
<li><p>创建矩阵</p>
<p><code>numpy.matlib.empty(shape, dtype, order)</code> 创建矩阵，填充伪随机数（通常非常小）。</p>
<p><code>numpy.matlib.zeros()</code></p>
<p><code>numpy.matlib.ones()</code></p>
<p><code>numpy.matlib.eye(n, M,k, dtype)</code> 函数返回一个矩阵，对角线元素为 1，其他位置为零。创建一个n*M的矩阵，为对角线索引。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy.matlib
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (np.matlib.eye(n =  <span class="hljs-number">3</span>, M =  <span class="hljs-number">4</span>, k =  <span class="hljs-number">0</span>, dtype =  float))
[[<span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>]
 [<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>]
 [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span>]]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (np.matlib.eye(n =  <span class="hljs-number">3</span>, M =  <span class="hljs-number">4</span>, k =  <span class="hljs-number">1</span>, dtype =  float))
[[<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>]
 [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span>]
 [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span>]]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (np.matlib.eye(n =  <span class="hljs-number">3</span>, M =  <span class="hljs-number">4</span>, k =  <span class="hljs-number">-1</span>, dtype =  float))
[[<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>]
 [<span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>]
 [<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>]]</code></pre></div>
<p><code>numpy.matlib.identity()</code> 创建单位矩阵</p>
<p><code>numpy.matlib.rand()</code> 创建一个矩阵，用[0,1)之间伪随机数填充。</p>
<p>可以使用 <code>np.asmatrix()</code> 和 <code>np.asarray()</code> 互相转化。</p></li>
<li><p>矩阵运算</p>
<p><code>numpy.dot()</code> 两个数组的点积，即元素对应相乘。</p>
<p>对于两个一维数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和。</p>
<div class="hljs"><pre><code class="hljs python">dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。
numpy.dot(a, b, out=<span class="hljs-literal">None</span>)</code></pre></div>
<p><code>numpy.vdot()</code> 两个向量的点积。</p>
<p>函数是两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开，计算之后得到的是一个标量值。、</p>
<div class="hljs"><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])
b = np.array([[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">14</span>]])
<span class="hljs-comment"># vdot 将数组展开计算内积</span>
<span class="hljs-keyword">print</span> (np.vdot(a,b)) <span class="hljs-comment"># 130</span></code></pre></div>
<p><code>numpy.inner()</code> 两个数组的内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>np.inner(np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]),np.array([<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]))
<span class="hljs-number">17</span>  <span class="hljs-comment"># 一维数组</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>np.inner(np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]),np.array([[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]))
array([[<span class="hljs-number">17</span>, <span class="hljs-number">23</span>],
       [<span class="hljs-number">39</span>, <span class="hljs-number">53</span>]]) <span class="hljs-comment"># 多维数组</span></code></pre></div>
<p><code>numpy.matmul()</code> 两个数组的矩阵积。</p>
<p>虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。对于二维数组，它就是矩阵乘法：</p>
<div class="hljs"><pre><code class="hljs python">a = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]] 
b = [[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]] 
<span class="hljs-keyword">print</span> (np.matmul(a,b))
[[<span class="hljs-number">4</span>  <span class="hljs-number">1</span>]
 [<span class="hljs-number">2</span>  <span class="hljs-number">2</span>]]
<span class="hljs-comment"># 二维</span>
a = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]] 
b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 
<span class="hljs-keyword">print</span> (np.matmul(a,b))
<span class="hljs-keyword">print</span> (np.matmul(b,a))
[<span class="hljs-number">7</span>  <span class="hljs-number">10</span>] 
[<span class="hljs-number">5</span>  <span class="hljs-number">11</span>]
<span class="hljs-comment"># 三维</span>
a = np.arange(<span class="hljs-number">8</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) 
b = np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) 
<span class="hljs-keyword">print</span> (np.matmul(a,b))
[[[ <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]
  [ <span class="hljs-number">6</span> <span class="hljs-number">11</span>]]
 [[<span class="hljs-number">10</span> <span class="hljs-number">19</span>]
  [<span class="hljs-number">14</span> <span class="hljs-number">27</span>]]]</code></pre></div>
<p><code>numpy.linalg.det()</code> 数组的行列式。</p>
<p><code>numpy.linalg.solve()</code> 求解线性矩阵方程。AX = B或者X = A^(-1)B</p>
<p><code>numpy.linalg.inv()</code> 计算矩阵的乘法逆矩阵。</p></li>
</ul>
<hr />
<h2 id="其他">其他</h2>
<h3 id="io及磁盘存储">IO及磁盘存储</h3>
<p>​ Numpy可以读写磁盘上的文本数据或二进制数据，NumPy 为 ndarray 对象引入了一个简单的文件格式(.npy)。npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p>
<p><code>numpy.save() 和 numpy.load()</code></p>
<p>函数 <code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code> 可以存储数组为".npy"格式。</p>
<p><code>numpy.savez(file, *args, **kwds)</code></p>
<div class="hljs"><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])
b = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.1</span>)
c = np.sin(b)
<span class="hljs-comment"># c 使用了关键字参数 sin_array</span>
np.savez(<span class="hljs-string">&quot;geek-docs.npz&quot;</span>, a, b, sin_array = c)
r = np.load(<span class="hljs-string">&quot;geek-docs.npz&quot;</span>)
print(r.files) <span class="hljs-comment"># 查看各个数组名称</span>
print(r[<span class="hljs-string">&quot;arr_0&quot;</span>]) <span class="hljs-comment"># 数组 a</span>
print(r[<span class="hljs-string">&quot;arr_1&quot;</span>]) <span class="hljs-comment"># 数组 b</span>
print(r[<span class="hljs-string">&quot;sin_array&quot;</span>]) <span class="hljs-comment"># 数组 c</span>
<span class="hljs-comment"># 输出</span>
[<span class="hljs-string">&#x27;sin_array&#x27;</span>, <span class="hljs-string">&#x27;arr_0&#x27;</span>, <span class="hljs-string">&#x27;arr_1&#x27;</span>]
[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
 [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]]
[<span class="hljs-number">0.</span>  <span class="hljs-number">0.1</span> <span class="hljs-number">0.2</span> <span class="hljs-number">0.3</span> <span class="hljs-number">0.4</span> <span class="hljs-number">0.5</span> <span class="hljs-number">0.6</span> <span class="hljs-number">0.7</span> <span class="hljs-number">0.8</span> <span class="hljs-number">0.9</span>]
[<span class="hljs-number">0.</span>         <span class="hljs-number">0.09983342</span> <span class="hljs-number">0.19866933</span> <span class="hljs-number">0.29552021</span> <span class="hljs-number">0.38941834</span> <span class="hljs-number">0.47942554</span>
 <span class="hljs-number">0.56464247</span> <span class="hljs-number">0.64421769</span> <span class="hljs-number">0.71735609</span> <span class="hljs-number">0.78332691</span>]</code></pre></div>
<p><code>numpy.savetxt(FILENAME, a, fmt="%d", delimiter=",")</code></p>
<p><code>numpy.loadtxt(FILENAME, dtype=int, delimiter=' ')</code></p>
<p>以简单的文本文件格式(.txt)存储数据， 参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</p>
<div class="hljs"><pre><code class="hljs python">a=np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0.5</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>)
np.savetxt(<span class="hljs-string">&quot;out.txt&quot;</span>,a,fmt=<span class="hljs-string">&quot;%d&quot;</span>,delimiter=<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment"># 改为保存为整数，以逗号分隔</span>
b = np.loadtxt(<span class="hljs-string">&quot;out.txt&quot;</span>,delimiter=<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment"># load 时也要指定为逗号分隔</span>
print(b)
<span class="hljs-comment"># 输出</span>
[[<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">1.</span> <span class="hljs-number">2.</span>]
 [<span class="hljs-number">2.</span> <span class="hljs-number">3.</span> <span class="hljs-number">3.</span> <span class="hljs-number">4.</span> <span class="hljs-number">4.</span>]
 [<span class="hljs-number">5.</span> <span class="hljs-number">5.</span> <span class="hljs-number">6.</span> <span class="hljs-number">6.</span> <span class="hljs-number">7.</span>]
 [<span class="hljs-number">7.</span> <span class="hljs-number">8.</span> <span class="hljs-number">8.</span> <span class="hljs-number">9.</span> <span class="hljs-number">9.</span>]]</code></pre></div>
<hr />
<h3 id="matplotlib">Matplotlib</h3>
<p><a target="_blank" rel="noopener" href="https://liam.page/2014/09/11/matplotlib-tutorial-zh-cn/">学习链接1</a></p>
<ul>
<li><p>中文显示 <a target="_blank" rel="noopener" href="https://blog.csdn.net/skyli114/article/details/77508247">参考链接</a></p>
<p>Matplotlib 默认情况不支持中文，我们可以使用以下简单的方法来解决 ：</p>
<div class="hljs"><pre><code class="hljs awk">zhfont = matplotlib.font_manager.FontProperties(fname=<span class="hljs-string">r&quot;c:\windows\fonts\simsun.ttc&quot;</span>)</code></pre></div>
<p>然后可以设置参数： fontproperties=zhfont`</p>
<p>或者修改全局字体： <code>plt.rcParams['font.family']=['FontName']</code></p></li>
<li><p>线形 <a target="_blank" rel="noopener" href="https://github.com/rougier/matplotlib-tutorial#quick-references">链接</a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字符</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>'-'</code></td>
<td style="text-align: center;">实线样式</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'--'</code></td>
<td style="text-align: center;">短横线样式</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'-.'</code></td>
<td style="text-align: center;">点划线样式</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>':'</code></td>
<td style="text-align: center;">虚线样式</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'.'</code></td>
<td style="text-align: center;">点标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>','</code></td>
<td style="text-align: center;">像素标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'o'</code></td>
<td style="text-align: center;">圆标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'v'</code></td>
<td style="text-align: center;">倒三角标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'^'</code></td>
<td style="text-align: center;">正三角标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'&lt;'</code></td>
<td style="text-align: center;">左三角标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'&gt;'</code></td>
<td style="text-align: center;">右三角标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'1'</code></td>
<td style="text-align: center;">下箭头标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'2'</code></td>
<td style="text-align: center;">上箭头标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'3'</code></td>
<td style="text-align: center;">左箭头标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'4'</code></td>
<td style="text-align: center;">右箭头标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'s'</code></td>
<td style="text-align: center;">正方形标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'p'</code></td>
<td style="text-align: center;">五边形标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'*'</code></td>
<td style="text-align: center;">星形标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'h'</code></td>
<td style="text-align: center;">六边形标记 1</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'H'</code></td>
<td style="text-align: center;">六边形标记 2</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'+'</code></td>
<td style="text-align: center;">加号标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'x'</code></td>
<td style="text-align: center;">X 标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'D'</code></td>
<td style="text-align: center;">菱形标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'d'</code></td>
<td style="text-align: center;">窄菱形标记</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'|'</code></td>
<td style="text-align: center;">竖直线标记</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'_'</code></td>
<td style="text-align: center;">水平线标记</td>
</tr>
</tbody>
</table></li>
<li><p>颜色</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字符</th>
<th style="text-align: center;">颜色</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>'b'</code></td>
<td style="text-align: center;">蓝色</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'g'</code></td>
<td style="text-align: center;">绿色</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'r'</code></td>
<td style="text-align: center;">红色</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'c'</code></td>
<td style="text-align: center;">青色</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'m'</code></td>
<td style="text-align: center;">品红色</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'y'</code></td>
<td style="text-align: center;">黄色</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'k'</code></td>
<td style="text-align: center;">黑色</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'w'</code></td>
<td style="text-align: center;">白色</td>
</tr>
</tbody>
</table></li>
<li><p>绘制子图</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt 
<span class="hljs-comment"># 计算正弦和余弦曲线上的点的 x 和 y 坐标 </span>
x = np.arange(<span class="hljs-number">0</span>,  <span class="hljs-number">3</span>  * np.pi,  <span class="hljs-number">0.1</span>) 
y_sin = np.sin(x) 
y_cos = np.cos(x)  
<span class="hljs-comment"># 建立 subplot 网格，高为 2，宽为 1  </span>
<span class="hljs-comment"># 激活第一个 subplot</span>
plt.subplot(<span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>)  
<span class="hljs-comment"># 绘制第一个图像 </span>
plt.plot(x, y_sin) 
plt.title(<span class="hljs-string">&#x27;Sine&#x27;</span>)  
<span class="hljs-comment"># 将第二个 subplot 激活，并绘制第二个图像</span>
plt.subplot(<span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>) 
plt.plot(x, y_cos) 
plt.title(<span class="hljs-string">&#x27;Cosine&#x27;</span>)  
<span class="hljs-comment"># 展示图像</span>
plt.show()</code></pre></div></li>
</ul>
<hr />
<h3 id="结构化数组">结构化数组</h3>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># numpy基本类型</span>
bytes                 b1
int                   i1,i2,i4,i8
unsigned ints         u1,u2,u4,u8
floats                f2,f4,f8
complex               c8,c16
fixed length strings a&lt;n&gt;</code></pre></div>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

structured = np.array([(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>+<span class="hljs-number">2j</span>), 
                       (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Second&#x27;</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">2</span><span class="hljs-number">-2j</span>),
                       (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Third&#x27;</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>+<span class="hljs-number">3j</span>)],
                      dtype=[(<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;i2&#x27;</span>), (<span class="hljs-string">&#x27;position&#x27;</span>,<span class="hljs-string">&#x27;a6&#x27;</span>), 
                             (<span class="hljs-string">&#x27;value&#x27;</span>,<span class="hljs-string">&#x27;f4&#x27;</span>), (<span class="hljs-string">&#x27;complex&#x27;</span>, <span class="hljs-string">&#x27;c8&#x27;</span>)])
<span class="hljs-comment"># 或者</span>
structured = np.array([(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>+<span class="hljs-number">2j</span>), 
                       (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Second&#x27;</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">2</span><span class="hljs-number">-2j</span>),
                       (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Third&#x27;</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>+<span class="hljs-number">3j</span>)], 
                      dtype=(<span class="hljs-string">&#x27;i2, a6, f4, c8&#x27;</span>))
<span class="hljs-comment">#这里再单独指定字段名称</span>
structured.dtype.names = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;order&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;complex&#x27;</span>)

print(structured[<span class="hljs-string">&#x27;position&#x27;</span>])<span class="hljs-comment"># 指定字段名，否则自动分配f0,f1,f2</span></code></pre></div>
<hr />
<ol type="1">
<li><p>单元素元组表示（num,）括号内应当加上逗号，否则按照数值处理</p></li>
<li><p><code>*args, **kwargs</code> 这两个是python中的可变参数。<code>*args</code>表示任何多个无名参数，它是一个tuple；<code>**kwargs</code> 表示关键字参数，它是一个dict。并且同时使用<code>*args</code>和<code>**kwargs</code> 时，必须<code>*args</code>参数列要在<code>**kwargs</code>前。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yjk13703623757/article/details/76521420">参考链接</a></p></li>
<li><p>参考资料：<a target="_blank" rel="noopener" href="https://numpy.org/devdocs/user/quickstart.html#" class="uri">https://numpy.org/devdocs/user/quickstart.html#</a></p></li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/15/2020-08-01-%E5%8A%9B%E6%89%A3-%E6%A0%91/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode专题 树</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/10/16/2019-10-16-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/">
                        <span class="hidden-mobile">深度学习入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="" target="_blank" rel="nofollow noopener"><span>_____</span></a>
      <i class="iconfont icon-love"></i>
      <a href="" target="_blank" rel="nofollow noopener">
        <span>digua</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "NumPy入门笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  
















</body>
</html>
