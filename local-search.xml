<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cpp知识点小结-第二部分</title>
    <link href="/2022/08/09/2022-07-30-cpp%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"/>
    <url>/2022/08/09/2022-07-30-cpp%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<hr /><h1 id="c基础篇">C++基础篇</h1><hr /><h2 id="c基础">C++基础</h2><h3 id="简述智能指针">简述智能指针</h3><p>智能指针其作用是管理一个指针，避免申请的空间在函数或对象生命周期结束时忘记释放，造成内存泄漏。智能指针即是C++ RAII的一种应用，可用于动态资源管理，资源即对象的管理策略。使用智能指针可以很大程度上的内存泄漏的问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。在C++11开始，提供了unique_ptr，shared_ptr，weak_ptr。在此之前，C++98中的auto_ptr在C++11中已废弃。</p><ul><li><p><strong>unqiue_ptr：</strong>某个时刻只能有一个unique_ptr指向其管理的动态内存上的对象（独占式），所以不提供copy操作，只能在不同unique_ptr对象间move。当这个unique_ptr销毁时，它所指向的对象也会被销毁。（性能和普通指针相当，且重载了对数组对象的支持，但是C++11中未实现make_unique方法，make_unique在C++14中已加入）</p></li><li><p><strong>shared_ptr：</strong>多个shared_ptr智能指针可以共同使用同一块堆内存（共享式）。并且，由于该类型智能指针在实现上采用的是引用计数机制（通过use_count()查看），即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），只有引用计数为 0 时，堆内存才会被自动释放。</p><ul><li><p>拓展：引用计数增加是否线程安全</p><p>[ <a href="https://www.cnblogs.com/gqtcgq/p/7492772.html">shared_ptr的线程安全性</a>、<a href="https://cloud.tencent.com/developer/article/1654442">shared_ptr是线程安全的吗</a> ]</p><p>是的，shared_ptr有两个数据成员，对内存对象的读写不能原子化。shared_ptr的引用计数本身是安全且无锁的，计数器的实现应当是原子的，C++11中提供了atomic类。多个线程同时读同一个shared_ptr对象是线程安全的，但是如果是多个线程对同一g个shared_ptr对象进行读和写，则需要加锁。</p></li></ul></li><li><p><strong>weak_ptr：</strong>为了配合shared_ptr而引入的weak_ptr智能指针，它指向一个由shared_ptr管理的对象，但是不控制所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。它只可以从一个shared_ptr或另一个weak_ptr对象构造。因此，可被用来解决循环引用的问题。</p><ul><li><p>拓展：weak_ptr注意点</p><p>weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过weak_ptr::lock()方法提升为shared_ptr强智能指针（loick方法返回一个shared_ptr），才能访问资源。可以用weak_ptr::expired()检测其指向的内存对象是否已经失效，若失效则weak_ptr::lock()返回的是一个空的shared_ptr对象。</p></li><li><p>拓展：weak_ptr的其它使用场景</p><p>[ <a href="https://blog.csdn.net/qq_53111905/article/details/122240842">weak_ptr 的几个应用场景 —— 观察者、解决循环引用、弱回调</a> ]</p><p>观察者模式：若某个对象只关心内存资源的状态、引用计数等，那么应当使用弱引用来“观察”内存资源。</p><p>弱回调：如果对象还活着，就调用它的成员函数，否则忽略之。例如，多线程访问共享对象的线程安全问题：线程A和线程B访问一个共享的对象，如果线程A正在析构这个对象的时候，线程B又要调用该共享对象的成员方法，此时可能线程A已经把对象析构完了，线程B再去访问该对象，就会发生不可预期的错误。因此，使用weak_ptr可以判断共享对象是否仍然有效，避免无效调用。</p><p>循环引用场景：两个对象互相使用一个shared_ptr成员变量指向对方的会造成循环引用，导致引用计数失效。（其他方法：手动释放）</p></li></ul></li><li><p>为什么unique_ptr的Deleter是模板类型参数，而shared_ptr的Deleter不是</p><p>[ <a href="(https://fuzhe1989.github.io/2017/05/19/cpp-different-role-of-deleter-in-unique-ptr-and-shared-ptr/)">unique_ptr和shared_ptr的deleter使用区别</a> ]</p><p>答案是效率。unique_ptr的设计目标之一是尽可能的高效，如果用户不指定Deleter，就要像原生指针一样高效。</p></li></ul><hr /><h3 id="c-中内存分配情况">C++ 中内存分配情况</h3><p>[ <a href="https://www.cnblogs.com/Braveliu/p/15127735.html">C++内存分区</a> ]</p><p><em>C++内存分区模型：两部分（代码区、数据区）、三部分（程序存储区、静态存储区、动态存储区）、四部分（代码区、全局区、栈区、堆区）、五部分（程序代码区、全局/静态区、文字常量区、栈区、堆区）</em></p><ul><li><p><strong>栈：</strong>由编译器管理分配和回收，存放局部变量和函数参数。</p></li><li><p><strong>堆：</strong>由程序员管理，需要手动malloc/free进行分配和回收，空间较大，但可能会出现内存泄漏和空闲碎片的情况。(拓展：自由存储区的概念)</p></li><li><p><strong>全局/静态存储区：</strong>分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。</p></li><li><p><strong>常量存储区：</strong>存储常量，一般不允许修改。</p></li><li><p><strong>代码区：</strong>存放程序的二进制代码。</p></li><li><p><strong>自由存储区与堆有什么区别？</strong></p><p>[ <a href="https://www.cnblogs.com/QG-whz/p/5060894.html">C++ 自由存储区是否等价于堆</a> ]</p><p>malloc在堆（heap）上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区（free store）上，使用delete来释放。虽然编译器通常基于malloc/free实现new/delete，但是<em>堆与自由存储区并不等价</em>。从概念上来讲堆是操作系统维护的一块内存，而自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念。所以，通过重载new/delete可以将其它部分的内存作为自由存储区。</p></li></ul><hr /><h3 id="堆和栈的区别">堆和栈的区别</h3><ul><li><strong>栈：</strong>是一段连续的内存空间，由编译器进⾏管理分配和回收，⼀般保存的是局部变和函数参数。比如函数调用的时候会用到栈，⾸先⼊栈的主函数的下⼀条可执⾏指令的地址，然后是函数的各个参数，参数入栈顺序一般是自右向左。栈是<em>⾼地址向低地址</em>扩展，栈底为⾼地址，空间较⼩。</li><li><strong>堆：</strong>不连续的空间，需要手动申请和释放。系统中有⼀个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请⼤⼩的空间分配给程序。堆是<em>低地址向⾼地址</em>扩展，空间较大，较为灵活。</li></ul><p>（栈的最大容量是系统预先规定好的，在Window下，栈的大小是2MB，Linux下，默认栈空间大小为8MB，可通过ulimit -s来设置。堆的大小和虚拟内存）</p><hr /><h3 id="函数参数传递">函数参数传递</h3><ul><li><p><strong>按值传递：</strong>被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本。</p></li><li><p><strong>地址传递：</strong>指针传递参数本质上是值传递的方式，它所传递的是一个地址值。被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本。</p></li><li><p><strong>引用传递：</strong>形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</p></li><li><p>从编译的角度看，在生成符号表的时候，引用变量的地址值是引用对象的实际地址，而指针变量的地址值是该指针变量自身的地址，随意可以改变指针的内容，即指向的值。</p></li></ul><hr /><h3 id="const作用">const作用</h3><ul><li><p>const 修饰基本类型数据类型、修饰指针（常量指针和指针常量）和引用、函数返回值，实现常量化。</p></li><li><p>类成员函数中，可以函数定义末尾添加const，该函数不允许修改类的数据成员。</p><ul><li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</li><li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li><li>良好的编程风格：在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为const 成员函数。</li></ul></li><li><p><strong>const 修饰指针如何区分?</strong></p><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * p1; <span class="hljs-comment">//指向整形常量的指针，它指向的值不能修改，但可以指向其它整型常量</span><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p2; <span class="hljs-comment">//指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p3; <span class="hljs-comment">//指整形常量的常量指针 。它既不能再指向别的常量，指向的值也不能修改。</span></code></pre></li></ul><hr /><h3 id="static作用">static作用</h3><ul><li><strong>修饰局部变量：</strong>局部变量通常存放在栈区，其所处的局部语句结束时生命周期结束，若使用static修饰，变量便会存放在静态数据区，生命周期和整个程序一致。（不改变作用域）</li><li><strong>修饰全局变量：</strong>普通全局变量对其它文件时可见的，可以通过extern关键词声明，若用static修饰，则其作用域仅限本文件。</li><li><strong>修饰函数：</strong>同全局变量，改变函数的作用域。</li><li><strong>修饰类：</strong>修饰成员变量/函数则表示成员变量/函数属于一个类而不是属于此类的任何特定对象。静态成员变量在存储空间中只存在一个副本，可以通过类和对象去调用。静态非常量数据成员，其只能在类外定义和初始化，在类内仅是声明而已。 静态成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的静态成员变量。</li></ul><hr /><h3 id="volatile和extern作用">volatile和extern作用</h3><ul><li><p><strong>volatile：</strong>三个特性是易变性（从内存重读）、不可优化性、顺序性。</p></li><li><p><strong>extern：</strong>修饰在变量或者函数的声明前，用来说明 “此变量/函数是在别处定义的，要在此处引用”。（<em>extern声明的位置对其作用域也有关系。extern会加速程序的编译过程。</em>）</p><p>extern还可用于指示C或者C++函数的调用规范，告诉链接器使用C函数规范来链接（）。</p></li></ul><hr /><h3 id="define-和-const-区别">define 和 const 区别</h3><ul><li><p><strong>define：</strong>宏定义实际上是在预编译阶段进行处理，仅执行字符串展开，没有类型，也没有类型检查，占用代码段，因此运行时系统并不为宏定义分配内存（汇编立即数），定义后在之后的程序中可用。其他功能包括<em>定义常量、变量、条件编译</em>。</p></li><li><p><strong>const：</strong>在编译期间进行处理，const有类型，也有类型检查，占用数据段空间，程序运行时系统会为const常量分配内存。（汇编内存地址）</p><p>（*编译器可能不分配内存而将常量添加到符号表）</p></li></ul><hr /><h3 id="c和c区别">C和C++区别</h3><ul><li><p>C++兼容C，但是C++在语法、关键词、重载、面向对象、泛型编程上有更多特性。</p></li><li><p><strong>拓展：C++面向对象的三大特征</strong></p><ul><li>封装：把客观事物封装成抽象的类，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。类中可实现接口、信息隐藏和不同级别的保护。</li><li>继承：让某个类型的对象获得另一个类型的对象的属性的方法，同时派生类可以继续添加新的属性和方法。其中，<em>实现继承</em>是指直接使用基类的属性和方法而无需额外编码的能力；<em>接口继承</em>是指仅使用属性和方法的名称、但是子类必需提供实现的能力。</li><li>多态：一个接口，可以实现多种方法。具体表现为函数地址是静态绑定还是动态绑定的。（虚函数）</li></ul></li><li><p><strong>拓展：类与类之间的关系</strong></p><ul><li><p>has-A：包含关系，用以描述一个类由多个部件类构成，实现 has-A 关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；</p></li><li><p>use-A：一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；</p></li><li><p>is-A：继承关系，关系具有传递性；</p></li></ul></li><li><p><strong>拓展：面向对象设计的五大原则</strong></p><p>[ <a href="https://huangwang.github.io/2019/06/16/面向对象设计的五大原则SOLID/">面向对象设计的五大原则SOLID | Jack Huang's Blog</a> ]</p><p>SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）</p><table><thead><tr class="header"><th style="text-align: left;">首字母</th><th style="text-align: left;">指代</th><th style="text-align: left;">概念</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">S</td><td style="text-align: left;">单一功能原则</td><td style="text-align: left;">对象应该仅具有一种单一功能</td></tr><tr class="even"><td style="text-align: left;">O</td><td style="text-align: left;">开闭原则</td><td style="text-align: left;">软件体应该是对于扩展开放的，但是对于修改封闭的</td></tr><tr class="odd"><td style="text-align: left;">L</td><td style="text-align: left;">里氏替换原则</td><td style="text-align: left;">程序中对象在不改变程序正确性的前提下被它的子类所替换</td></tr><tr class="even"><td style="text-align: left;">I</td><td style="text-align: left;">接口隔离原则</td><td style="text-align: left;">多个特定客户端接口要好于一个宽泛用途的接口</td></tr><tr class="odd"><td style="text-align: left;">D</td><td style="text-align: left;">依赖反转原则</td><td style="text-align: left;">依赖于抽象而不是一个实例</td></tr></tbody></table></li></ul><hr /><h3 id="c编译过程">C++编译过程</h3><ul><li><p><strong>预编译（.i），编译(.s)，汇编(.o)，链接(可执行文件)</strong></p><p>对应这4个过程中gcc driver分别使用cpp，cc1，as，ld来完成。[ <a href="http://fallincode.com/blog/2013/09/symbol_tables_resulution/">符号、符号表和符号解析</a> ]</p></li><li><p><strong>预处理，编译，汇编，链接程序的区别</strong></p><ul><li>预处理：(gcc - E)读取c源程序，对其中的<em>伪指令</em>（以# 开头的指令，例如宏定义、条件编译、头文件等）和<em>特殊符号</em>进行处理。</li><li>编译：(gcc -S)通过<em>词法分析和语法分析</em>，在确认所有的指令都符合语法规则之后，将其翻译成等价的<em>中间代码表示或汇编代码</em>。</li><li>汇编：(gcc -c)把汇编语言代码翻译成<em>目标机器指令</em>的过程。</li><li>链接：(gcc -o)吧有关的目标文件彼此相连接，得到的是可执行目标文件。可分为<em>静态链接和动态链接</em>。</li></ul></li><li><p><strong>静态链接与动态链接</strong></p><ul><li>静态链接：函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中，静态链接库实际上是一个目标文件的集合。可执行文件在运行时不需要依赖于动态链接库。</li><li>动态链接：可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。使用动态链接能够加快编译速度、缩小可执行文件大小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。</li></ul></li></ul><hr /><h3 id="c-中重载和重写重定义的区别">C++ 中重载和重写，重定义的区别</h3><ul><li><p><strong>重载：</strong>overload，是指同一可访问区内被声明的几个具有不同参数列表的同名函数，依赖于C++函数名字的修饰会将参数加在后面，可以是参数类型，个数，顺序的不同（const成员函数）。根据参数列表决定调用哪个函数，重载不关心函数的返回类型。</p><p>拓展：C++中的函数签名（function signature）包含了一个函数的信息，包括<em>函数名、参数类型、参数个数、顺序以及它所在的类和命名空间</em>。不同的编译器有不同的修饰方式。[ <a href="https://blog.csdn.net/alzzw/article/details/108150803">C++ 符号修饰和函数签名_阿尔兹的博客</a> ]</p></li><li><p><strong>重写：</strong>override，派生类中重新定义父类中除了函数体外完全相同的<em>虚函数</em>（被重写的函数不能是static的）。要注意，重写和被重写的函数是<em>在不同的类当中</em>的，重写函数的访问修饰符是可以不同的（public/protected/private）。</p></li><li><p><strong>重定义（隐藏）：</strong>派生类重新定义父类中相同名字的<em>非 virtual 函数</em>，参数列表和返回类型都可以不同，即父类中除了定义成 virtual 且完全相同的同名函数才不会被派生类中的同名函数所隐藏（重定义）。</p></li></ul><hr /><h3 id="c构造函数">C++构造函数</h3><ul><li><strong>默认构造函数：</strong>没有明确写出无参数构造函数，编译器会自动生成默认的无参数构造函数，函数为空，什么也不做</li><li><strong>一般构造函数：</strong>基于重载可以有各种参数形式的构造函数。（特殊，explicit，静止类型转换）</li><li><strong>拷贝构造函数：</strong>拷贝构造函数的函数参数为对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象。（编译器会生成默认拷贝构造函数，但是涉及深拷贝的场景，应当自己实现）</li><li>赋值运算符的重载：类似拷贝构造函数但它不属于构造函数。＝左右两边的对象必需已经被创建。如果没有显式的赋值运算符的重载，系统也会生成默认的赋值运算符，做一些基本的拷贝工作。</li></ul><hr /><h3 id="构造函数和析构函数是否可以抛出异常">构造函数和析构函数是否可以抛出异常</h3><p>从语法上来说，构造函数和析构函数都可以抛出异常。 但从逻辑上和风险控制上，构造函数和析构函数中尽量不要抛出异常，要注意防止资源泄露。</p><ul><li><strong>构造函数抛出异常：</strong>构造函数抛出异常，对象可能未完全构造，因此析构函数无法被正常调用，特别时存在继承的情况下。</li><li><strong>析构函数抛出异常：</strong><ul><li>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</li><li>通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。</li></ul></li><li>解决方法：那就是把异常完全封装在析构函数内部，决不让异常抛出析构函数之外。</li></ul><hr /><h3 id="简述c-的四种强制转换">简述C++ 的四种强制转换</h3><ul><li><strong>static_cast：</strong>明确指出类型转换，一般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上行转换（派生类-&gt;基类）安全，下行转换（基类-&gt;派生类） 不安全，所以主要执行非多态的转换操作</li><li><strong>dynamic_cast：</strong>专门用于派生类之间的转换，type-id 必须是类指针，类引用或 void*，对于下行转换是安全的，当类型不一致时，转换过来的是空指针，而static_cast，当类型不一致时，转换过来的事错误意义的指针，可能造成非法访问等问题。</li><li><strong>const_cast：</strong>专门用于const属性的转换，去除const性质，或增加 const 性质，是四个转换符中唯一一个可以操作常量的转换符。[ <a href="https://www.cnblogs.com/QG-whz/p/4513136.html">C++强制类型转换操作符const_cast</a> ]</li><li><strong>reinterpret_cast：</strong>从底层对数据进行重新解释，依赖具体的平台。</li></ul><hr /><h3 id="指针和引用的区别">指针和引用的区别</h3><ul><li>指针和引用都是一种内存地址的概念，但是指针是一个实体，引用只是一个别名。在程序编译的时候，将指针和引用添加到符号表中。</li><li>指针它指向一块内存，指针的内容是所指向的内存的地址，指针包含的内容是可以改变的，允许拷贝和赋值，甚至可以为空。sizeof指针得到的是指针类型的大小。</li><li>引用来说，它只是一块内存的别名，在添加到符号表的时候，是将"引用变量名-引用对象的地址"添加到符号表中，符号表一经完成不能改变，所以引用必须而且只能在定义时被绑定到一块内存上，后续不能更改，也不能为空。sizeof引用得到代表对象的大小。</li></ul><hr /><h3 id="野指针与悬空指针有什么区别如何避免">野指针与悬空指针有什么区别，如何避免？</h3><ul><li><p><strong>野指针（wild）：</strong>就是没有被初始化过的指针。用 <code>gcc -Wall</code> 编译, 会出现 <code>used uninitialized</code>警告。</p></li><li><p><strong>悬空指针（dangling）：</strong>是指针最初指向的内存已经被释放了的一种指针。</p></li><li><p>无论是野指针还是悬空指针，都是指向无效内存区域，访问"不安全可控"(invalid)的内存区域将导致"Undefined Behavior"。</p></li><li><p>应当养成在定义指针后且在使用之前完成初始化的习惯或者使用智能指针。</p></li></ul><hr /><h3 id="函数指针">函数指针</h3><ul><li><p>首先从定义上：<em>函数指针是指向函数的指针变量</em>。即函数指针是一个指针变量，该指针变量指向一个具体的函数。在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址</p></li><li><p>其次用途上：可以调用函数和作为函数的参数。比如，回调函数（Linux中的signal）。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-keyword">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">sighandler_t</span> handler)</span></span>;<span class="hljs-comment">// 核心部分： signal(int, void (*)(int)); signal 函数名加上参数部分，而第二个参数是一个函数指针；</span><span class="hljs-comment">// 将这一部分设为x， 代入原型之后，其实就是返回值类型了： void (*x)(int);</span><span class="hljs-comment">// ...</span><span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * p)</span>  </span>&#123;…&#125;  <span class="hljs-comment">// 函数fun</span><span class="hljs-keyword">char</span> * (*pf)(<span class="hljs-keyword">char</span> * p);    <span class="hljs-comment">// 函数指针pf</span>pf = fun;                  <span class="hljs-comment">// 函数指针pf指向函数fun</span>pf(p);                     <span class="hljs-comment">// 通过函数指针pf调用函数fun</span></code></pre></li></ul><hr /><h3 id="深拷贝和浅拷贝的区别深拷贝和浅拷贝的区别c">深拷贝和浅拷贝的区别深拷贝和浅拷贝的区别C+</h3><ul><li><strong>何时需要拷贝构造函数：</strong><ul><li>一个对象以<em>值传递</em>的方式传入函数体，需要拷贝构造函数创建一个临时对象压入到栈空间中。</li><li>一个对象需要通过另外一个对象进行<em>初始化</em>。（A a, b = a; A a, b(a);）</li><li>*一个对象以值传递的方式从函数返回，需要执行拷贝构造函数创建一个临时对象作为返回值。（拓展：<a href="https://www.zhihu.com/question/29511959/answer/44617879">C++11 Copy Elision</a>拷贝消除，故返回值不一定拷贝）</li><li>[ <a href="https://www.cnblogs.com/xiaolincoding/p/11967842.html">拓展：=赋值运算符的深拷贝和浅拷贝</a> ]</li></ul></li><li>在未定义显示拷贝构造函数的情况下，编译器调用默认的拷贝函数，执行浅拷贝。对于基本数据类型，浅拷贝可行。但是当对象内包含指针（管理堆上的内存），浅拷贝后会出现两个指针指向同一个内存空间，若析构时多次析构则会引发<em>悬空指针</em>。而深拷贝会在堆内存中另外申请空间来存储数据，从而避免悬空指针的安全问题。</li></ul><hr /><h3 id="为什么拷贝构造函数必需时引用传递不能是值传递">为什么拷贝构造函数必需时引用传递，不能是值传递？</h3><p><em>防止递归调用</em>。当一个对象需要以值方式进行传递时，编译器会生成代码调用它的拷贝构造函数生成一个副本，如果类A的拷贝构造函数的参数不是引用传递，而是采用值传递，那么就又需要<em>为了创建传递给拷贝构造函数的参数的临时对象</em>，而又一次调用类A的拷贝构造函数，造成无限递归调用。</p><hr /><h3 id="newdelete与mallocfree辨析">new/delete与malloc/free辨析</h3><p>[ <a href="https://www.cnblogs.com/QG-whz/p/5140930.html">细说new与malloc的10点区别</a> ]</p><table><thead><tr class="header"><th style="text-align: center;">特征</th><th style="text-align: center;">new/delete</th><th style="text-align: center;">malloc/free</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">分配内存的位置</td><td style="text-align: center;">自由存储区</td><td style="text-align: center;">堆</td></tr><tr class="even"><td style="text-align: center;">内存分配成功的返回值</td><td style="text-align: center;">完整类型指针</td><td style="text-align: center;">void*</td></tr><tr class="odd"><td style="text-align: center;">内存分配失败的返回值</td><td style="text-align: center;">默认抛出异常</td><td style="text-align: center;">返回NULL</td></tr><tr class="even"><td style="text-align: center;">分配内存的大小</td><td style="text-align: center;">由编译器根据类型计算得出</td><td style="text-align: center;">必须显式指定字节数</td></tr><tr class="odd"><td style="text-align: center;">处理数组</td><td style="text-align: center;">有处理数组的new版本new[]</td><td style="text-align: center;">需要用户计算数组的大小后进行内存分配</td></tr><tr class="even"><td style="text-align: center;">已分配内存的扩充</td><td style="text-align: center;">无法直观地处理</td><td style="text-align: center;">使用realloc简单完成</td></tr><tr class="odd"><td style="text-align: center;">是否相互调用</td><td style="text-align: center;">可以，看具体的operator new/delete实现</td><td style="text-align: center;">不可调用new</td></tr><tr class="even"><td style="text-align: center;">函数重载</td><td style="text-align: center;">允许</td><td style="text-align: center;">不允许</td></tr><tr class="odd"><td style="text-align: center;">构造函数与析构函数</td><td style="text-align: center;">调用</td><td style="text-align: center;">不调用</td></tr><tr class="even"><td style="text-align: center;">分配内存时内存不足</td><td style="text-align: center;">客户能够指定处理函数或重新制定分配器</td><td style="text-align: center;">无法通过用户代码进行处理</td></tr></tbody></table><ul><li><p><strong>重载new/delete参考简单实现</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-keyword">sieze_t</span> size)</span> </span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">void</span> * mem = <span class="hljs-built_in">malloc</span>(size))     <span class="hljs-keyword">return</span> mem;  <span class="hljs-keyword">else</span>     <span class="hljs-keyword">throw</span> bad_alloc();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *mem)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;  <span class="hljs-built_in">free</span>(mem);&#125;</code></pre></li></ul><hr /><h3 id="多态的实现">多态的实现</h3><ul><li><strong>静态多态：</strong>重载，由编译器为函数生成符号表时的不同规则实现。重载只是一种语言特性，与多态无关，与面向对象也无关，是C++中增加的新规则。</li><li><strong>动态多态：</strong>继承+虚函数实现多态，通过子类重写父类的虚函数来实现在运行期间决定调用的函数，所以称为动态多态。</li><li>扩展：子类继承父类时， 父类的<em>纯虚函数</em>必须重写，否则子类也是一个虚类<em>不可实例化</em>。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li></ul><hr /><h3 id="析构函数一般写成虚函数的原因">析构函数一般写成虚函数的原因</h3><p><em>降低内存泄漏的可能性，确保对象正确析构</em>。如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执行派生类的析构函数，再执行基类的析构函数，成功释放内存。（举例来说就是，一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数（该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执行基类的析构，派生类的自身内容将无法被析构，造成内存泄漏。）</p><hr /><h3 id="构造函数为什么一般不定义为虚函数">构造函数为什么一般不定义为虚函数</h3><ul><li>创建一个对象需要知道对象的完整信息，而虚函数调用只需要知道“部分的”信息，即只需要知道函数接口，而不需要知道对象的具体类型。</li><li>虚函数的调用依赖虚函数表，但是对象实例未构造之前，虚函数表指针是不存在的，违反了先实例化后调用的准则。</li><li>拓展：<em>构造函数、内联函数（编译阶段进行函数体的替换操作）、静态函数（不属于对象属于类）、友元函数（不属于类的成员函数，不能被继承）、普通函数（不属于类成员）不可以定义为virtual</em>。</li></ul><hr /><h3 id="构造函数的执行顺序与析构函数的执行顺序">构造函数的执行顺序与析构函数的执行顺序</h3><ul><li><strong>构造函数顺序</strong><ul><li>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类<em>在类派生表中出现的顺序</em>，而不是它们在成员初始化表中的顺序。</li><li>成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是<em>对象在类中被声明的顺序</em>，而不是它们出现在成员初始化表中的顺序。</li><li>派生类构造函数。</li></ul></li><li><strong>析构函数顺序</strong><ul><li>调用派生类的析构函数。</li><li>调用成员类对象的析构函数。</li><li>调用基类的析构函数。</li></ul></li></ul><hr /><h3 id="c对象模型">C++对象模型</h3><p>*<em>C++对象的内存布局、虚表指针、虚基类指针。</em></p><p>[ <a href="https://www.cnblogs.com/QG-whz/p/4909359.html">⭐图说C++对象模型：对象内存布局详解</a>、<a href="https://blog.twofei.com/496/">⭐C++中的虚函数表实现机制与内存布局解析</a>、《深度探索C++对象模型》 ]</p><ul><li><p><strong>不带有虚函数的类：</strong>类对象的大小就是所有成员变量大小之和（严格说是成员变量<a href="https://cloud.tencent.com/developer/article/1727794">内存对齐</a>之后的大小之和）。</p></li><li><p><strong>若类中带有虚函数（非继承情况）：</strong>类中成员会产生8字节的偏移（在64位环境下），这是由于虚函数表指针<code>__vptr</code>被添加到该类最前部（可以通过<code>sizeof(A)</code>,<code>offsetof(A, x)</code>查看）。</p></li><li><p>同一个类的不同实例共用同一份虚函数表, 它们都通过一个所谓的虚函数表指针<code>__vfptr</code>（定义为<code>void **</code>类型）指向同一份虚函数表。</p></li><li><p><strong>单继承：</strong>对于一般继承（这个一般是相对于虚拟继承而言），若子类重写（overwrite）了父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数(<strong>注意子类与父类拥有各自的一个虚函数表</strong>)；若子类并无overwrite父类虚函数，而是声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后（在vs中无法通过监视看到扩充的结果，不过我们通过取地址的方法可以做到，子类新的虚函数确实在父类子物体的虚函数表末端）。</p></li><li><p><strong>多继承：</strong>按照<em>基类的继承声明顺序</em>, 基类的成员依次分布在派生类中；若派生类中新增虚函数，其虚函数表依然是保存到第1个拥有虚函数表的那个基类的后面。若按照继承顺序，有基类不包含虚函数，则在内存布局中<em>有虚函数表的基类放在对象内存前面</em>。</p></li><li><p><strong>虚继承：</strong>若子类overwrite父类虚函数，同样地将覆盖父类子物体中的虚函数表对应位置，而若子类声明了自己新的虚函数，则编译器将为子类增加一个新的虚表指针vptr。</p></li><li><p><strong>虚函数指针设计伪代码：</strong>定义成一个<em>指向指针数组的指针</em>，</p><pre><code class="hljs C++"><span class="hljs-keyword">void</span>*        __fun[<span class="hljs-number">1</span>] = &#123; &amp;Base1::base1_fun1 &#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>** __vfptr = &amp;__fun[<span class="hljs-number">0</span>];</code></pre></li><li><p><strong>通过函数指针访问虚函数表</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span> <span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Class A func() called.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125;&#125;;...A a;<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*Func)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-keyword">int</span>* vtb_addr = (<span class="hljs-keyword">int</span>*)(&amp;a);  <span class="hljs-comment">// 获取虚函数表的地址</span>Func vfunc = (Func) * ((<span class="hljs-keyword">int64_t</span>*)*(<span class="hljs-keyword">int64_t</span>*)(&amp;a));  <span class="hljs-comment">// 注意x64平台函数指针长度位8字节</span>vfunc();  <span class="hljs-comment">// 通过函数指针调用虚函数</span>...<span class="hljs-comment">// 函数指针转换的报错参考 https://blog.csdn.net/liu__ke/article/details/9235035</span></code></pre></li><li><p><em>虚函数表仅有一份，属于类；含有虚函数的类的对象内部包含指向一个虚表的指针，指向自己所使用的虚表。</em></p></li><li><p><strong>成员类型</strong></p><p>在C++对象中，有两种数据成员（class data members）：<em>static</em>和<em>nonstatic</em>,以及三种类成员函数（class member functions）：<em>static</em>、<em>non-static</em>和<em>virtual</em>。</p><p>在此模型下，non-static 数据成员被置于每一个类对象中，而static数据成员被置于类对象之外。static与nonstatic函数也都放在类对象之外，而对于virtual 函数，则通过虚函数表+虚指针来支持。（例子如下）</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span> <span class="hljs-keyword">public</span>:  Base(<span class="hljs-keyword">int</span> i) : baseI(i)&#123;&#125;;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> baseI; &#125;  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countI</span><span class="hljs-params">()</span></span>&#123;&#125;;  <span class="hljs-keyword">virtual</span> ~Base() &#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base::print()&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125; <span class="hljs-keyword">private</span>:  <span class="hljs-keyword">int</span> baseI;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> baseS;&#125;;<span class="hljs-comment">// sizeof(Base) = 16, Base b, sizeof(b) = 16</span></code></pre><p><img src="Snipaste_2022-07-15_21-11-46.png" /></p></li><li><p><strong>空类继承</strong></p><pre><code class="hljs C++"><span class="hljs-comment">// b、b1、b2、d分别为下列类的对象实例，sizeof值为1、4、4、8（32位）/1、8、8、16（64位）</span><span class="hljs-comment">// 编译器为空类安插1字节的char，以使该类对象在内存得以配置一个地址</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span>&#125;;<span class="hljs-comment">// b1虚继承于b，编译器为其安插一个4字节的虚基类表指针，此时b1已不为空，编译器不再为其安插1字节的char（优化）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B1</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> B &#123;&#125;;<span class="hljs-comment">// b2同理</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B2</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> B &#123;&#125;;<span class="hljs-comment">// d含有来自b1与b2两个父类的两个虚基类表指针。大小为8字节</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> B1, <span class="hljs-keyword">public</span> B2 &#123;&#125;;</code></pre></li></ul><hr /><h3 id="sizeof计算大小内存对齐">sizeof计算大小、内存对齐</h3><ul><li><p><strong>计算下面几个类的大小</strong></p><p>（**类只是一个类型定义，它是没有大小可言的。 用sizeof运算符对一个类型名操作，得到的是具有该类型实例的大小。*）</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span>&#125;; <span class="hljs-keyword">sizeof</span>(A) = <span class="hljs-number">1</span>; <span class="hljs-comment">//空类在实例化时得到一个独一无二的地址，所以为 1. </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>&#123;&#125; &#125;; <span class="hljs-keyword">sizeof</span>(A) = <span class="hljs-number">4</span>(<span class="hljs-number">32b</span>it)/<span class="hljs-number">8</span>(<span class="hljs-number">64b</span>it) <span class="hljs-comment">//当 C++ 类中有虚函数的时候，会有一个指向虚函数表的指针（vptr）</span>class A&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a; &#125;; <span class="hljs-keyword">sizeof</span>(A) = <span class="hljs-number">1</span>; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><span class="hljs-keyword">int</span> a; &#125;; <span class="hljs-keyword">sizeof</span>(A) = <span class="hljs-number">4</span>; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a; <span class="hljs-keyword">int</span> b; &#125;; <span class="hljs-keyword">sizeof</span>(A) = <span class="hljs-number">4</span>;</code></pre></li><li><p><strong>数组、指针、联合体、结构体</strong></p><p>[ <a href="https://murphypei.github.io/blog/2021/03/cpp-sizeof.html">C++ sizeof 总结 | 拾荒志</a> ]</p></li><li><p><strong>内存对齐的规则</strong></p><p>[ <a href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解</a> ]</p><ul><li>对于结构体中的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是 min(#pragma pack() 制定的数，数据成员本身长度) 的倍数。</li><li>在所有的数据成员完成各自对齐之后，结构体或联合体本身也要进行对齐，整体长度是 min(#pragma pack()制定的数，长度最长的数据成员的长度) 的倍数。</li><li>优点：字节对齐后提升CPU访存速度、有利于平台移植。</li></ul></li></ul><hr /><h3 id="类如何实现只能静态分配和只能动态分配">类如何实现只能静态分配和只能动态分配</h3><ul><li><p>静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。</p><p>方法：将new 和 delete 重载为私有。在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。 将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。</p></li><li><p>动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。</p><p>方法：将析构函数设为private/protected（考虑继承）。编译器管理了对象的整个生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。</p></li></ul><hr /><h3 id="forkwaitexec函数">fork，wait，exec函数</h3><ul><li><p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了<em>父进程的页表</em>，两个进程都<em>读同一块内存</em>。</p></li><li><p>当有进程写的时候使用<em>写时拷贝机制</em>分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。</p></li><li><p>fork从父进程返回子进程的pid，从子进程返回0，调用了wait的父进程将会发生阻塞，直到有子进程状态改变，执行成功返回0，错误返回 -1。</p></li><li><p>exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1。</p></li></ul><hr /><h2 id="stl相关问题">STL相关问题</h2><h3 id="stl中提供了那些容器">STL中提供了那些容器</h3><p>[ <a href="https://www.cnblogs.com/linuxAndMcu/p/10254542.html">STL各容器简单介绍</a>、<a href="https://oi-wiki.org/lang/csl/">OI-wiki参考</a> ]</p><p>标准模板库中提供了<em>容器、容器适配器、算法、迭代器、仿函数、空间配置器</em>六大组件。（暂时只总结以下三个）</p><ul><li><strong>容器</strong>（Containers）：用来管理某类对象的集合。每一种容器都有其优点和缺点，所以为了应付程序中的不同需求，STL 准备了七种基本容器类型。<ul><li>序列式容器：向量（vector）、双端队列（deque）、列表（list）</li><li>关联式容器：集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）</li></ul></li><li><strong>迭代器</strong>（Iterators）：用来在一个对象集合的元素上进行遍历动作。这个对象集合或许是个容器，或许是容器的一部分。每一种容器都提供了自己的迭代器，而这些迭代器了解该种容器的内部结构。</li><li><strong>算法</strong>（Algorithms）：用来处理对象集合中的元素，比如 Sort，Search，Copy，Erase 那些元素。通过迭代器的协助，我们只需撰写一次算法，就可以将它应用于任意容器之上，这是因为所有容器的迭代器都提供一致的接口。</li></ul><hr /><hr /><h2 id="c11141720新特性">C++11/14/17/20新特性</h2><h2 id="section"></h2><ul><li>[ <a href="https://harttle.land/2015/10/08/cpp11.html">新特性总结</a> ]</li><li>[ <a href="https://www.zhihu.com/question/65209863">当面试官问我C++ 11新特性的时候，应该怎样回答？</a> ]</li></ul><h3 id="新特性分类">新特性分类</h3><table><thead><tr class="header"><th>全新特性（革新）</th></tr></thead><tbody><tr class="odd"><td>decltype关键字，可变参数模板</td></tr></tbody></table><table><thead><tr class="header"><th>标准库</th></tr></thead><tbody><tr class="odd"><td>散列容器unordered_map、unordered_set，元组容器tuple、线程库</td></tr></tbody></table><table><thead><tr class="header"><th>语法糖</th></tr></thead><tbody><tr class="odd"><td>函数模板的默认模板参数，using与模板的别名，auto关键字，lambda表达式，统一的列表初始化方法</td></tr></tbody></table><table><thead><tr class="header"><th>安全</th></tr></thead><tbody><tr class="odd"><td>智能指针、原子操作</td></tr></tbody></table><ol type="1"><li><p>改善初始化方式的一致性（列表初始化）</p></li><li><p>类型推导</p></li><li><p>右值引用</p><p>[ <a href="https://zhuanlan.zhihu.com/p/99524127">现代C++之万能引用、完美转发、引用折叠 - 知乎</a> ]</p></li><li><p>（C++17）结构化绑定（Structured Binding）</p></li></ol><hr /><h3 id="auto关键字的作用c11">auto关键字的作用（C++11）</h3><p>[ <a href="https://www.cnblogs.com/QG-whz/p/4951177.html">C++11特性：auto关键字</a> ]</p><p>auto关键字在C++11之后作为类型占位符，在编译期间完成类型推导（C++98是自动变量，已废弃）。常用的几个场景是：容器迭代器等较长的类型可以用auto来简化代码；在定义模板函数时，使用auto声明编译期才能确定类型的变量；与decltype配合作为返回值占位符。</p><ul><li><p>相关的关键字还有decltype、typeid、invoke_of。</p></li><li><p>注意事项如下：</p><ul><li><p>auto 变量必须在定义时初始化</p></li><li><p>定义在一个auto序列的变量必须始终推导成同一类型（不建议<code>auto a4 = 10, a5 = 20, a6 = 30;</code>）</p></li><li><p>如果初始化表达式是引用，则去除引用语义</p></li><li><p>如果初始化表达式为const或volatile（或者两者兼有），则除去const/volatile语义</p></li><li><p>如果auto关键字带上&amp;号，则不去除const语意</p></li><li><p>初始化表达式为数组时，auto关键字推导类型为指针</p></li><li><p>若表达式为数组且auto带上&amp;，则推导类型为数组类型</p></li><li><p>函数形参或者模板参数不能被声明为auto</p></li></ul></li></ul><hr />]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从小爱刷题！</title>
    <link href="/2022/05/21/2022-05-21-%E4%BB%8E%E5%B0%8F%E7%88%B1%E5%88%B7%E9%A2%98/"/>
    <url>/2022/05/21/2022-05-21-%E4%BB%8E%E5%B0%8F%E7%88%B1%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="从小爱刷题">从小爱刷题！</h1><p>✅ 完成</p><p>❌ 未完成，置于标题前，补卡后变成🔺，🌀啊啊啊，没见过，非常规套路，技巧</p><p>⭐ 收藏 🟢 简单 🟠 中等 🟣 困难 🔵 其它</p><hr /><h2 id="剑指offer-第二版">剑指Offer 第二版</h2><ul><li>本章参考《剑指Offer》第二版。</li></ul><hr /><h3 id="年03月">2022年03月</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: left;">题目编号</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a>、<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>]；🟢[ <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a> ]；🟣[ <a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a> ]</td></tr><tr class="even"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a> ]；🟢[ ]；🟣[ <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">⭐25. K 个一组翻转链表</a>、<a href="https://leetcode-cn.com/problems/permutation-sequence/">60. 排列序列</a> ]</td></tr><tr class="odd"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a>、 ]；🟢[ <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a>、<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>、<a href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a> ]；🟣[ ]</td></tr><tr class="even"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a>、 <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a>]；🟢[ <a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a>、<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a>、<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a>、<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a> ]；🟣[ ]</td></tr><tr class="odd"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">⭐剑指 Offer 12. 矩阵中的路径</a> ]；🟢[ <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>、<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>、<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a>、<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>、<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a>、<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a>、<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a>、<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">⭐剑指 Offer 11. 旋转数组的最小数字</a> ]；🟣[ ]</td></tr><tr class="even"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a>、<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a> ]；🟢[ ]；🟣[ ]</td></tr><tr class="odd"><td style="text-align: left;">共计28题。</td></tr></tbody></table><hr /><h3 id="年04月">2022年04月</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th style="text-align: left;">题目编号</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a> ]；🟢[ ]；🟣[ ]</td></tr><tr class="even"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a>（整型取反溢出）、<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">⭐剑指 Offer 26. 树的子结构</a> ]；🟢[ <a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a>、<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a>（全排列或大数模拟解法）、<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a>（力扣无法使用delete?）、<a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a>（快排交换思想）、<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a>（快慢指针或顺序遍历）、<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a>、<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a>、 ]；🟣[ ]</td></tr><tr class="odd"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">⭐剑指 Offer 31. 栈的压入、弹出序列</a>（这题完成得不好）、<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a>、<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a>（递归） ]；🟢[ <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a>、<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a>、<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">⭐剑指 Offer 29. 顺时针打印矩阵</a>（简单模拟仍需多练）、<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a>（链表实现栈，头插法）、<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a> ]；🟣[ ]</td></tr><tr class="even"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a>（有点意思，哈希表遍历两边，或者回溯）、<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">⭐剑指 Offer 36. 二叉搜索树与双向链表</a>（递归，非常值得学习的题目） ]；🟢[ ]；🟣[ ]；🔵 [华为两道面试题，主要考察数据结构]</td></tr><tr class="odd"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">⭐剑指 Offer 33. 二叉搜索树的后序遍历序列</a>（递归分治、辅助单调栈）、<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">⭐剑指 Offer 38. 字符串的排列</a>（回溯、下一个排列） ]；🟢[ <a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a>（排序、哈希、<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/comments/280917">摩尔投票法</a>）、<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">⭐剑指 Offer 40. 最小的k个数</a>（快排思想、堆） ]；🟣[ <a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">⭐剑指 Offer 41. 数据流中的中位数</a>（双堆求中位数、技巧） ]</td></tr><tr class="even"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/next-permutation/">⭐31. 下一个排列</a>（next_permunation）、<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a>（找规律不是很有趣，溢出）、<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">⭐剑指 Offer 46. 把数字翻译成字符串</a>（记忆化搜索（自顶向下）、动态规划（自底向上））、<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a>（动态规划） ]；🟢[ <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">⭐剑指 Offer 42. 连续子数组的最大和</a> ]；🟣[ ]</td></tr><tr class="odd"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a>（滑动窗口、哈希） ]；🟢[ ]；🟣[ ]</td></tr><tr class="even"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>（回溯）、<a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a>（拓扑排序判环）、<a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a>（记忆化搜索、动态规划）、<a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a>（贪心）、<a href="https://leetcode-cn.com/problems/video-stitching/">1024. 视频拼接</a>（贪心）、<a href="https://leetcode-cn.com/problems/interval-list-intersections/">986. 区间列表的交集</a>（贪心）、<a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a>、<a href="https://leetcode-cn.com/problems/remove-covered-intervals/">1288. 删除被覆盖区间</a>、<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452 用最少数量的箭引爆气球</a>、<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435 无重叠区间</a>、<a href="https://leetcode-cn.com/problems/minimum-path-sum/">64 最小路径和</a>、<a href="https://leetcode-cn.com/problems/target-sum/">494 目标和</a>、<a href="https://leetcode-cn.com/problems/coin-change-2/">518 零钱兑换 II</a>、<a href="https://leetcode-cn.com/problems/coin-change/">322 零钱兑换</a>、<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416 分割等和子集</a>（动态规划）、<a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/">712 两个字符串的最小ASCII删除和</a>、<a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583 两个字符串的删除操作</a>、<a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143 最长公共子序列</a>、<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673 最长递增子序列的个数</a>、<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">931 下降路径最小和</a> 、<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300 最长递增子序列</a>]；🟢[ <a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674 最长连续递增序列</a>、<a href="https://leetcode-cn.com/problems/fibonacci-number/">509 斐波那契数</a> ]；🟣[ <a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a>（单调栈、动态规划）、<a href="https://leetcode-cn.com/problems/edit-distance/">72 编辑距离</a>（动态规划） ]；🔵 [最短路径（Dijkstra、Bellman-Ford、SPFA、Floyd）和最小生成树（Kruskal、Prim）、强连通分量（Tarjan）]</td></tr><tr class="odd"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a>（记忆化搜索、状压dp）、]；🟢[ ]；🟣[ <a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a>(回溯) ]；🔵 [华为时习之 <a href="https://ilearningx.huawei.com/portal/oj/problems/23/details">23. 代码缩进</a>]</td></tr><tr class="even"><td style="text-align: left;">🟠[ <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a>、<a href="https://leetcode-cn.com/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a>（总数减去连通边缘的岛屿数，即问题200）、<a href="https://leetcode-cn.com/problems/number-of-enclaves/">1020. 飞地的数量</a>（计算封闭岛屿格子数）、<a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a>、<a href="https://leetcode-cn.com/problems/count-sub-islands/">1905. 统计子岛屿</a>（这类题目注意dfs的完整性、先过滤不符合的岛屿） ]；🟢[ ]；🟣[ ]；🔵[ <a href="https://leetcode-cn.com/problems/number-of-distinct-islands/">694. 不同岛屿的数量</a>（plus题目） ]</td></tr><tr class="odd"><td style="text-align: left;">🟠[ ]；🟢[ ]；🟣[ <a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a> ]；🔵[ 集合划分问题、排列组合问题、“岛屿”问题、数独问题 ]</td></tr><tr class="even"><td style="text-align: left;">子集/组合/排列（无重复不复选）：🟠[ <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a>（回溯、位运算共 <span class="math inline">\(2^n\)</span> 个子集）、<a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a>（转化为78.子集，第k层返回）| ]；🟢[ ]；🟣[ ]</td></tr><tr class="odd"><td style="text-align: left;">共计68题。</td></tr></tbody></table><hr /><h3 id="年05月">2022年05月</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>题目编号</th></tr></thead><tbody><tr class="odd"><td>子集/组合/排列（重复元素不复选）：🟠[ <a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a>、<a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a>（记得排序）、<a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a>（组合总数，上面还有个<a href="https://leetcode-cn.com/problems/permutations/">全排列</a>） ]；🟢[ ]；🟣[ ]</td></tr><tr class="even"><td>🟠[ <a href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a>、<a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a>、<a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a>]；🟢[ ]；🟣[ ]</td></tr><tr class="odd"><td>🟠[ ]；🟢[ <a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a>、<a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">⭐剑指 Offer 52. 两个链表的第一个公共节点</a>（哈希表或双指针）、<a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a>（二分）、<a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a>（二分）、<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a>（反向中序遍历）、<a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a>、<a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a>（求高度，自底向上） ]；🟣[ <a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a>（归并排序） ]</td></tr><tr class="even"><td>🟠[ <a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a>（位运算）、<a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a>（位运算计数）、 ]；🟢[ <a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a>（哈希或双指针）]；🟣[ ]</td></tr><tr class="odd"><td>🟠[ <a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">⭐剑指 Offer 59 - II. 队列的最大值</a>（滑动窗口最大值，单调队列） ]；🟢[ <a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">⭐剑指 Offer 57 - II. 和为s的连续正数序列</a>（枚举或双指针）、<a href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a>、<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">⭐l剑指 Offer 58 - II. 左旋转字符串</a>（类似冒泡，原地翻转）、<a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a>]；🟣[ <a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">⭐剑指 Offer 59 - I. 滑动窗口的最大值</a>（堆、单调队列）]</td></tr><tr class="even"><td>🟠[ <a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">⭐剑指 Offer 63. 股票的最大利润</a> （维护最小值）、<a href="https://leetcode.cn/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a>（有趣的递归，好玩的<a href="https://leetcode.cn/problems/qiu-12n-lcof/comments/258086">语言特性</a>）、<a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a>（正反向遍历各一次）]；🟢[ <a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">⭐剑指 Offer 65. 不用加减乘除做加法</a>（位运算技巧）、<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">⭐剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a>、<a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">⭐剑指 Offer 68 - II. 二叉树的最近公共祖先</a> ]；🟣[ ]；🔵[ ]</td></tr><tr class="odd"><td>共计29题。</td></tr></tbody></table><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>未完成题目列表 ❌</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a>、<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a>、<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a>、<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a>、<a href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a>（自动机）</td></tr></tbody></table><center><font color='purple'>==========剑指offer完结==========</font></center><hr /><h2 id="专题练习">专题练习</h2><ul><li><p>本章参考《<a href="https://labuladong.github.io/algo/">labuladong的算法笔记</a>》《<a href="https://programmercarl.com/">代码随想录</a>》。</p></li><li><p>可能存在与《剑指Offer》重复的题目链接。</p></li></ul><hr /><h3 id="数组专题">数组专题</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>数组</th></tr></thead><tbody><tr class="odd"><td>（代码随想录）：<a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a>（参考lower_bound实现）、<a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a>（模拟std::remove()函数，last指向当前可覆盖的位置）、<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">⭐26. 删除有序数组中的重复项</a>（last指向“去重数组”的最后一个元素）、<a href="https://leetcode.cn/problems/backspace-string-compare/">⭐844. 比较含退格的字符串</a>（重构字符串或双指针）、<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a>、<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">⭐209. 长度最小的子数组</a>（双指针滑动窗口，前缀和+二分）、<a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a>（双指针滑动窗口，最大窗口）、<a href="https://leetcode.cn/problems/minimum-window-substring/">⭐76. 最小覆盖子串</a>（滑动窗口，最小窗口<a href="https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/">总结</a>）、<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">⭐剑指 Offer 29. 顺时针打印矩阵</a>（第二次做，边界还是没处理好，<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/">参考</a>）、<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a>（同剑指 Offer 29）、<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></td></tr><tr class="even"><td>🔺其它：</td></tr></tbody></table><hr /><h3 id="链表专题">链表专题</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>链表</th></tr></thead><tbody><tr class="odd"><td>（代码随想录）：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a>（迭代或递归）、<a href="https://leetcode.cn/problems/design-linked-list/">⭐707. 设计链表</a>、<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a>（递归+迭代）、<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>（递归+迭代）、<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a>（快慢指针）、<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a>（指针的哈希或双指针）、<a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a>（判环哈希，<span class="math inline">\(O(n)\)</span>空间，<a href="https://leetcode.cn/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">Floyd 判圈算法</a> <span class="math inline">\(O(1)\)</span>空间）、<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">⭐142. 环形链表 II</a>（快慢指针，数学，<a href="https://programmercarl.com/0142.环形链表II.html#总结">转化成找两个链表的交点</a>）、<a href="https://leetcode.cn/problems/find-the-duplicate-number/">🌀287. 寻找重复数</a>（快慢指针或<a href="https://leetcode.cn/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/">鸽巢原理+二分</a>）</td></tr><tr class="even"><td>🔺其它：<a href="https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">二分查找的技巧 - 力扣</a></td></tr></tbody></table><hr /><h3 id="哈希表">哈希表</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>哈希表</th></tr></thead><tbody><tr class="odd"><td>（代码随想录）：<a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a>、<a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a>、<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">⭐438. 找到字符串中所有字母异位词</a>（滑动窗口 + 哈希，利用vector operator=判断相等，可优化）、<a href="https://leetcode.cn/problems/4sum-ii/">⭐454. 四数相加 II</a>（不可暴力，参考两数之和+哈希实现<span class="math inline">\(O(n^2)\)</span>）、<a href="https://leetcode.cn/problems/3sum/">⭐15. 三数之和</a>（哈希去重较复杂，<a href="https://leetcode.cn/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/">排序+双指针</a>）、<a href="https://leetcode.cn/problems/4sum/">⭐18. 四数之和</a>（参考三数之和，考虑int溢出）</td></tr><tr class="even"><td>🔺其它：<a href="https://lxl2015.github.io/2019/09/01/Hash%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">哈希算法总结</a></td></tr></tbody></table><hr /><h3 id="字符串">字符串</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>字符串</th></tr></thead><tbody><tr class="odd"><td>(代码随想录)：<a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a>（学习reverse的实现）、<a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a>（同344）、<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a>(find，repalce方法)、<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 颠倒字符串中的单词</a>（reverse，erase用法）、<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a>（三次翻转思路）、<a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a>（暴力要会，巧解思路）</td></tr><tr class="even"><td>🔺字符串专题需要多加练习，出了力扣，还需要练习I/O操作，例如stringstream、Python字符串处理技巧等。<br />🔺其它：<a href="https://leetcode.cn/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">KMP算法</a>、</td></tr></tbody></table><hr /><h3 id="队列与栈">队列与栈</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>队列与栈</th></tr></thead><tbody><tr class="odd"><td>(代码随想录)：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a>（代码复用）、<a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a>（辅助队列用于que'ba交换队列或单队列方法）、<a href="https://leetcode.cn/problems/valid-parentheses/">⭐20. 有效的括号</a>（栈）、<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a>（直接在字符串上push_back, pop_back()）、<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a>（二叉树和逆波兰式、中缀表达式，注意除数和被除数的顺序）、<a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a>（哈希+堆求topK，<span class="math inline">\(O(nlogk)\)</span>）</td></tr></tbody></table><table><thead><tr class="header"><th>单调栈</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></td></tr></tbody></table><table><thead><tr class="header"><th>单调队列</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a>（单调队列（deque实现）、堆）</td></tr></tbody></table><hr /><h3 id="二叉树">二叉树</h3><table><thead><tr class="header"><th>二叉树</th></tr></thead><tbody><tr class="odd"><td></td></tr><tr class="even"><td></td></tr></tbody></table><hr /><h3 id="技巧类">技巧类</h3><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>双指针</th></tr></thead><tbody><tr class="odd"><td>（同上面专题存在重复）<a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a>、<a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a>、<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 颠倒字符串中的单词</a>、<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a>、<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a>、<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a>、<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a>、<a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a>、<a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></td></tr></tbody></table><table><tbody><tr class="odd"><td></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2022/05/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr /><h2 id="排序算法稳定性">排序算法稳定性</h2><h3 id="常用排序稳定性">常用排序稳定性</h3><p>我暂时还没具体分析锦标赛排序为什么是不稳定的。</p><blockquote><p>Stable Sorting Algorithms:</p><ul><li>Insertion Sort、Merge Sort、Bubble Sort、Tim Sort、Counting Sort、Block Sort、Quadsort、Library Sort、Cocktail shaker Sort、Gnome Sort、Odd–even Sort</li></ul><p>Unstable Sorting Algorithms:</p><ul><li>Heap sort、Selection sort、Shell sort、Quick sort、Introsort (subject to Quicksort)、Tree sort、Cycle sort、Smoothsort、Tournament sort(subject to Heapsort)</li></ul></blockquote><table><thead><tr class="header"><th style="text-align: center;"><strong>排序算法</strong></th><th style="text-align: center;"><strong>平均时间复杂度</strong></th><th style="text-align: center;"><strong>最坏时间复杂度</strong></th><th style="text-align: center;"><strong>最好时间复杂度</strong></th><th style="text-align: center;"><strong>空间复杂度</strong></th><th style="text-align: center;"><strong>稳定性</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>冒泡排序</strong></td><td style="text-align: center;">O(n²)</td><td style="text-align: center;">O(n²)</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;"><strong>直接选择排序</strong></td><td style="text-align: center;">O(n²)</td><td style="text-align: center;">O(n²)</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">不稳定</td></tr><tr class="odd"><td style="text-align: center;"><strong>直接插入排序</strong></td><td style="text-align: center;">O(n²)</td><td style="text-align: center;">O(n²)</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;"><strong>快速排序</strong></td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(n²)</td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">不稳定</td></tr><tr class="odd"><td style="text-align: center;"><strong>堆排序</strong></td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">不稳定</td></tr><tr class="even"><td style="text-align: center;"><strong>希尔排序</strong></td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(ns)</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">不稳定</td></tr><tr class="odd"><td style="text-align: center;"><strong>归并排序</strong></td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;"><strong>计数排序</strong></td><td style="text-align: center;">O(n+k)</td><td style="text-align: center;">O(n+k)</td><td style="text-align: center;">O(n+k)</td><td style="text-align: center;">O(n+k)</td><td style="text-align: center;">稳定</td></tr><tr class="odd"><td style="text-align: center;"><strong>基数排序</strong></td><td style="text-align: center;">O(N*M)</td><td style="text-align: center;">O(N*M)</td><td style="text-align: center;">O(N*M)</td><td style="text-align: center;">O(M)</td><td style="text-align: center;">稳定</td></tr></tbody></table><hr /><h2 id="交换的实现">交换的实现</h2><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span> </span>&#123;  T temp = a;  a = b;  b = temp;&#125;</code></pre><hr /><h2 id="简单选择排序">简单选择排序</h2><p>它的工作原理是每次找出第 <span class="math inline">\(i\)</span> 小的元素（也就是 <span class="math inline">\(A_{i\dots n}\)</span> 中最小的元素），然后将这个元素与数组第 <span class="math inline">\(i\)</span> 个位置上的元素交换。</p><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr)</span> </span>&#123;  <span class="hljs-keyword">int</span> len = arr.size();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;    <span class="hljs-keyword">int</span> idx = i;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; ++j) &#123;      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[idx]) idx = j;  <span class="hljs-comment">// 此处需要类型T重载&quot;&lt;&quot;运算符</span>    &#125;    <span class="hljs-built_in">std</span>::swap(arr[i], arr[idx]);  &#125;&#125;</code></pre><hr /><h2 id="冒泡排序">冒泡排序</h2><p>它的工作原理是<strong>每次检查相邻两个元素</strong>，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。经过 <span class="math inline">\(i\)</span> 次扫描后，数列的末尾 <span class="math inline">\(i\)</span> 项必然是最大的 <span class="math inline">\(i\)</span> 项，因此冒泡排序最多需要扫描 <span class="math inline">\((n-1)\)</span> 遍数组就能完成排序。 [ <a href="https://en.wikipedia.org/wiki/Bubble_sort">冒泡排序的两点优化</a> ]</p><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubble_sort_opt</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr)</span> </span>&#123;  <span class="hljs-keyword">int</span> len = arr.size();  <span class="hljs-keyword">bool</span> swapped = <span class="hljs-literal">true</span>;  <span class="hljs-keyword">while</span> (swapped) &#123;    swapped = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;      <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - <span class="hljs-number">1</span>]) &#123;        swapped = <span class="hljs-literal">true</span>;        <span class="hljs-built_in">std</span>::swap(arr[i - <span class="hljs-number">1</span>], arr[i]);      &#125;    &#125;    <span class="hljs-comment">// --len; // 可优化，第i轮扫描可以确定前i大的数字</span>  &#125;&#125;</code></pre><hr /><h2 id="插入排序">插入排序</h2><p>它的工作原理为将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。</p><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr)</span> </span>&#123;  <span class="hljs-keyword">int</span> len = arr.size();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;    T key = arr[i];    <span class="hljs-keyword">int</span> idx = i - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (idx &gt;= <span class="hljs-number">0</span> &amp;&amp; key &lt; arr[idx]) &#123;      arr[idx + <span class="hljs-number">1</span>] = arr[idx];      --idx;    &#125;    arr[idx + <span class="hljs-number">1</span>] = key;  <span class="hljs-comment">//可知arr[idx] &lt;= key, 插入位置为idx + 1</span>  &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr)</span> </span>&#123;  <span class="hljs-keyword">int</span> len = arr.size();  <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">1</span> &amp;&amp; arr[j] &lt; arr[j<span class="hljs-number">-1</span>]; --j) &#123;      <span class="hljs-built_in">std</span>::swap(arr[j], arr[j<span class="hljs-number">-1</span>]);    &#125;  &#125;&#125;</code></pre><hr /><h2 id="快速排序">快速排序</h2><p>快排，又被称作分区交换排序（partition-exchange sort），基本思想是分治，步骤如下：</p><ol type="1"><li>将数列划分为两部分（要求保证相对大小关系）；</li><li>递归到两个子序列中分别进行快速排序；</li><li>不用合并，因为此时数列已经完全有序。</li></ol><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;  T key = arr[low];  <span class="hljs-keyword">while</span> (low &lt; high) &#123;    <span class="hljs-comment">// 先处理右侧</span>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= key) --high;    arr[low] = arr[high];    <span class="hljs-comment">// 处理左侧</span>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= key) ++low;    arr[high] = arr[low];  &#125;  arr[low] = key;  <span class="hljs-keyword">return</span> low;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;  <span class="hljs-keyword">if</span> (low &lt; high) &#123;    <span class="hljs-keyword">int</span> idx = partition(arr, low, high);    quick_sort(arr, low, idx - <span class="hljs-number">1</span>);    quick_sort(arr, idx + <span class="hljs-number">1</span>, high);  &#125;&#125;</code></pre><p>快排的优化技巧：随机化选取key，取三个key的中间数，待排序序列规模较小时使用插入排序</p><hr /><h2 id="归并排序">归并排序</h2><p>归并排序分为三个步骤：</p><ol type="1"><li>将数列划分为两部分；</li><li>递归地分别对两个子序列进行归并排序；</li><li>合并两个子序列。</li></ol><pre><code class="hljs C++"><span class="hljs-comment">// 递归写法</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; tmp_arr;  tmp_arr.reserve(high - low + <span class="hljs-number">1</span>); <span class="hljs-comment">// 其实这里还不是很完美</span>  <span class="hljs-keyword">int</span> left_idx = low;  <span class="hljs-keyword">int</span> right_idx = mid + <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (left_idx &lt;= mid &amp;&amp; right_idx &lt;= high) &#123;    <span class="hljs-keyword">if</span> (arr[left_idx] &lt; arr[right_idx]) &#123;      tmp_arr.push_back(arr[left_idx]);      ++left_idx;    &#125; <span class="hljs-keyword">else</span> &#123;      tmp_arr.push_back(arr[right_idx]);      ++right_idx;    &#125;  &#125;  <span class="hljs-keyword">while</span> (left_idx &lt;= mid) &#123;    tmp_arr.push_back(arr[left_idx]);    ++left_idx;  &#125;  <span class="hljs-keyword">while</span> (right_idx &lt;= high) &#123;    tmp_arr.push_back(arr[right_idx]);    ++right_idx;  &#125;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; tmp_arr.size() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; tmp_arr.capacity() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; high - low + <span class="hljs-number">1</span>; ++i) arr[low + i] = tmp_arr[i];&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;  <span class="hljs-keyword">if</span> (low &lt; high) &#123;    <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;    merge_sort(arr, low, mid);    merge_sort(arr, mid + <span class="hljs-number">1</span>, high);    merge(arr, low, mid, high);  &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">// 迭代写法</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;  <span class="hljs-keyword">int</span> len = high - low + <span class="hljs-number">1</span>;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; tmp_arr;  tmp_arr.reserve(len);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; len; idx += seg * <span class="hljs-number">2</span>) &#123;      <span class="hljs-keyword">int</span> left = idx;      <span class="hljs-keyword">int</span> mid = <span class="hljs-built_in">std</span>::min(idx + seg, len);      <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">std</span>::min(idx + seg * <span class="hljs-number">2</span>, len);      <span class="hljs-keyword">int</span> tmp_idx = left;      <span class="hljs-keyword">int</span> idx1 = left;      <span class="hljs-keyword">int</span> idx2 = mid;      <span class="hljs-comment">// 归并</span>      <span class="hljs-keyword">while</span> (idx1 &lt; mid &amp;&amp; idx2 &lt; right) &#123;        tmp_arr[tmp_idx++] =            (arr[idx1] &lt; arr[idx2]) ? arr[idx1++] : arr[idx2++];      &#125;      <span class="hljs-keyword">while</span> (idx1 &lt; mid) tmp_arr[tmp_idx++] = arr[idx1++];      <span class="hljs-keyword">while</span> (idx2 &lt; high) tmp_arr[tmp_idx++] = arr[idx2++];    &#125;    <span class="hljs-built_in">std</span>::swap(arr, tmp_arr);  &#125;&#125;</code></pre><p>[ <a href="https://zh.wikipedia.org/wiki/归并排序">归并排序 - 维基百科</a> ]</p><hr /><h2 id="堆排序">堆排序</h2><p>数组从小到大排序应当建立大顶堆：将堆顶的元素取出，作为最大值，与数组尾部的元素交换，并维持残余堆的性质；之后将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换，并维持残余堆的性质；以此类推，在第 <span class="math inline">\(n-1\)</span> 次操作后，整个数组就完成了排序。</p><p><strong>在STL中，优先队列<code>priority_queue</code>默认是小顶堆，所以输出序列是从大到小排序。</strong></p><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sift_down</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;  <span class="hljs-keyword">int</span> parent = low;  <span class="hljs-keyword">int</span> child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (child &lt;= high) &#123;    <span class="hljs-keyword">if</span> (child + <span class="hljs-number">1</span> &lt;= high &amp;&amp; arr[child] &lt; arr[child + <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// 小顶堆改成arr[child] &gt; arr[child + 1]</span>      ++child;    &#125;    <span class="hljs-keyword">if</span> (arr[parent] &gt;= arr[child]) &#123;  <span class="hljs-comment">//  小顶堆改成arr[parent] &lt;= arr[child]</span>      <span class="hljs-keyword">break</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">std</span>::swap(arr[parent], arr[child]);      parent = child;      child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    &#125;  &#125;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr)</span> </span>&#123;  <span class="hljs-keyword">int</span> len = arr.size();  <span class="hljs-comment">// 建堆</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) sift_down(arr, i, len - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 排序, 将堆顶元素与第i个元素 (当前堆的最后一个) 交换位置</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;    <span class="hljs-built_in">std</span>::swap(arr[<span class="hljs-number">0</span>], arr[i]);    sift_down(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);  &#125;&#125;</code></pre><hr /><h2 id="希尔排序">希尔排序</h2><p>希尔排序又称<strong>递减增量排序算法</strong>，具体介绍见 [ <a href="https://zh.wikipedia.org/wiki/希尔排序">希尔排序 - 维基百科</a> ]</p><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;  <span class="hljs-keyword">int</span> len = high - low + <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step_size = len &gt;&gt; <span class="hljs-number">1</span>; step_size &gt; <span class="hljs-number">0</span>; step_size &gt;&gt;= <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = step_size; i &lt; len; ++i) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= step_size &amp;&amp; arr[j] &lt; arr[j - step_size];           j -= step_size) &#123;        <span class="hljs-built_in">std</span>::swap(arr[j], arr[j - step_size]);      &#125;    &#125;  &#125;&#125;</code></pre><hr /><center>分割线</center><hr /><p>下面几种排序的重要性较弱。</p><ul><li>计数排序适合数据范围不大的一组数进行排序。</li><li>基数排序要求数据之间明显存在可进行关键字比较的特征。</li><li>桶排序同样适用于数据范围不大的情况，它可以视作对计数排序的改进，减少了空间浪费。</li></ul><hr /><h2 id="计数排序">计数排序</h2><p>它的工作过程分为三个步骤：</p><ol type="1"><li>计算每个数出现了几次；</li><li>求出每个数出现次数的 <a href="https://oi-wiki.org/basic/prefix-sum/">前缀和</a>；</li><li>利用出现次数的前缀和，从右至左计算每个数的排名（保证排序算法的稳定性，即相同大小的数字，原先在右侧的仍然在右侧）。</li></ol><pre><code class="hljs C++"><span class="hljs-comment">// C++ Version</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> W = <span class="hljs-number">100010</span>;<span class="hljs-keyword">int</span> n, w, a[N], cnt[W], b[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cnt));  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ++cnt[a[i]];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= w; ++i) cnt[i] += cnt[i - <span class="hljs-number">1</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; --i) b[cnt[a[i]]--] = a[i];&#125;</code></pre><hr /><h2 id="基数排序">基数排序</h2><p>它的工作原理是将待排序的元素拆分为 <span class="math inline">\(k\)</span> 个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第 <span class="math inline">\(k\)</span> 关键字进行稳定排序，再对第 <span class="math inline">\((k-1)\)</span> 关键字进行稳定排序，再对第 <span class="math inline">\((k-2)\)</span> 关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。</p><p>==基数排序需要借助一种 <strong>稳定算法</strong> 完成内层对关键字的排序。==</p><pre><code class="hljs C++"><span class="hljs-comment">/* 基数排序</span><span class="hljs-comment"> * 假设所有数都是非负的整数, 关键字的排序使用计数排序</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mod)</span> </span>&#123;  <span class="hljs-keyword">int</span> len = arr.size();  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp_arr</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 计数</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : arr) &#123;    ++cnt[(n / mod) % <span class="hljs-number">10</span>];  &#125;  <span class="hljs-comment">// 求cnt前缀和</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; cnt.size(); ++i) &#123;    cnt[i] += cnt[i - <span class="hljs-number">1</span>];  &#125;  <span class="hljs-comment">// 自右向左排序</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;    <span class="hljs-keyword">int</span> key = (arr[i] / mod) % <span class="hljs-number">10</span>;    tmp_arr[cnt[key] - <span class="hljs-number">1</span>] = arr[i];    --cnt[key];  &#125;  arr = tmp_arr;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radix_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; &amp;arr)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> max_num = *<span class="hljs-built_in">std</span>::max_element(arr.begin(), arr.end());  <span class="hljs-comment">// 取出最大的数用于判断关键字数量，按关键字(0-9)排序，其余较短数字缺位补0</span>  <span class="hljs-comment">// 此处关键字比较顺序是从个位开始，向高位比较</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1</span>; max_num / mod &gt; <span class="hljs-number">0</span>; mod *= <span class="hljs-number">10</span>) &#123;    counting_sort(arr, mod);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; arr = &#123;<span class="hljs-number">53</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">542</span>, <span class="hljs-number">748</span>, <span class="hljs-number">14</span>, <span class="hljs-number">214</span>,                                   <span class="hljs-number">154</span>, <span class="hljs-number">14</span>, <span class="hljs-number">63</span>,  <span class="hljs-number">616</span>, <span class="hljs-number">589</span>&#125;;  radix_sort(arr);  <span class="hljs-built_in">std</span>::copy(arr.begin(), arr.end(),            <span class="hljs-built_in">std</span>::ostream_iterator&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>, <span class="hljs-string">&quot; &quot;</span>));  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr /><h2 id="桶排序">桶排序</h2><p>工作的原理是将数组分到有限数量的桶里，每个桶再各自排序（配合其它排序算法），步骤如下：</p><ol type="1"><li>设置一个定量的数组当作空桶。</li><li>寻访序列，并且把项目逐个放到对应的桶内。</li><li>对每个非空桶进行排序。</li><li>合并所有非空桶内数据，还原成有序序列。</li></ol><p>[ <a href="https://zh.wikipedia.org/wiki/桶排序">桶排序 - 维基百科</a> ] 这里有基于链表的桶排序实现。</p><pre><code class="hljs C++"><span class="hljs-comment">// 假设只有10个桶，数字范围是[0, 99]</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NUM_BUCKETS = <span class="hljs-number">10</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">int</span>&gt;<span class="hljs-keyword">void</span> _insertion_sort(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr) &#123;  <span class="hljs-keyword">int</span> len = arr.size();  <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]; --j) &#123;      <span class="hljs-built_in">std</span>::swap(arr[j], arr[j - <span class="hljs-number">1</span>]);    &#125;  &#125;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">int</span>&gt;<span class="hljs-keyword">void</span> bucket_sort(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high) &#123;  <span class="hljs-comment">// 元素分桶</span>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&gt; buckets(NUM_BUCKETS, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&#123;&#125;);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : arr) &#123;    <span class="hljs-keyword">int</span> idx = n / NUM_BUCKETS;    buckets.at(idx).push_back(n);  &#125;  <span class="hljs-comment">// 桶内排序, 同时合并结果</span>  <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_BUCKETS; ++i) &#123;    _insertion_sort(buckets.at(i));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : buckets.at(i)) &#123;      arr[k++] = n;    &#125;  &#125;&#125;</code></pre><hr />]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++知识点小结</title>
    <link href="/2022/04/22/2022-04-22-cpp%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <url>/2022/04/22/2022-04-22-cpp%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="c必备知识点">C++必备知识点</h2><ol type="1"><li><p>C++中指针常量和常量指针的区别 [ <a href="https://www.cnblogs.com/lizhenghn/p/3630405.html">参考链接</a> ]</p><p>常量指针，又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</p><p>指针常量，本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以是只读的，指向的地址不可以变化，但是指向的地址所对应的内容可以变化 。</p><p><strong>指向常量的指针常量</strong>就是一个常量，且它指向的对象也是一个常量。</p><ul><li><p>如何使用cout打印<code>char *</code>指针所指向的地址</p><blockquote><p>如果给cout提供一个指针，它将打印指针所指向的地址单元的地址，但如果指针类型为char <em>，则cout将打印char </em>指针所指向的字符串。如果要显示char <em>指针所指向的地址单元的地址，需要将char </em>类型的指针强制转化为另一种类型的指针，我将char <em>类型的指针强制转化为int </em>类型指针。</p></blockquote></li><li><p>一个递归中使用指针出现的错误</p><p>下面代码的基本逻辑是在递归中序遍历过程中判断序列是否为升序。代码中并没有使用全局变量pre，而是将pre作为函数的参数，此时本质上相当于按照“值”传递参数，即传递的是一个地址。本来，预期的结果是，在递归遍历到第一个叶子节点后会返回，然后pre被赋值为这个叶子节点。但是，当递归调用返回上一层父节点时，pre的值仍然为nullptr，并没有被修改为左叶子的地址。</p><p>实际上递归调用的时候会生成"栈帧"保存当前调用的pre、curr指针的值，所以后续递归中改变pre的值并不会对之前的“栈帧“中的pre造成影响。今后遇到这类递归，应当改写成非递归形式，或者使用全局变量。（指针是按值传参）</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-keyword">public</span>:  <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;    inorderTraversal(root, <span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">return</span> res;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *curr, TreeNode *pre)</span> </span>&#123;    <span class="hljs-keyword">if</span> (curr == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;    inorderTraversal(curr-&gt;left, pre);    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">nullptr</span> &amp;&amp; pre-&gt;val &gt;= curr-&gt;val) &#123;      res = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; curr-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (pre ? pre-&gt;val : <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    pre = curr;    inorderTraversal(curr-&gt;right, pre);  &#125;&#125;;</code></pre></li></ul><hr /></li><li><p>C语言中各种类型的全局变量默认值</p><p>[ <a href="https://blog.csdn.net/qq_36553031/article/details/85321513">C语言中各种类型的全局变量默认值</a> ]</p><p>int: 0、char: '\0'也就是字符结束的标记、float: 0、double：0、string：默认是空字符串也就是""或者NULL、bool: 0、int* 0、float* 0 double* 0、string* 0、char*：针类型除了char*默认是空字符串''或者NULL，其他就默认都是0。</p><pre><code class="hljs C++"><span class="hljs-keyword">char</span> *a = “abc”;<span class="hljs-keyword">char</span> b[<span class="hljs-number">3</span>] = &#123; ‘a’,’b’ &#125;;b[<span class="hljs-number">0</span>] = ‘b’;a[<span class="hljs-number">0</span>] = ‘b’;</code></pre><p>char*a = ”abc“ 的 ”abc“ 是常量所以被分配在常量存储区。a为字符指针类型是存放在栈区可以被更改，而常量存储区是不能更改的，是只读区域。所以当你试图去写入数据的时候，会报错。而char b[3] = {‘a’，‘b’}的字符a和b是存放在栈区的所以可以进行写操作。</p><hr /></li><li><p>函数指针与指针函数</p><ul><li>定义方式</li></ul><pre><code class="hljs C++"><span class="hljs-comment">// 函数原型 int func(int a, int b);</span><span class="hljs-keyword">int</span> (*pfun)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>);<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*pf)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-keyword">using</span> PF = <span class="hljs-keyword">int</span> (*)(<span class="hljs-keyword">int</span>)(<span class="hljs-keyword">int</span>);</code></pre><p>指针函数即返回指针的函数，首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量 。</p><p><code>　int (*f) (int x); /* 声明一个函数指针 */</code> <code>f=func; /* 将func函数的首地址赋给指针f*/</code></p><ul><li><p>C/C++规定函数名就表示函数入口地址，函数名赋值时函数名前面加不加取地址符<code>&amp;</code>均可，也就是说<code>PF f = func</code>等价于<code>PF f = &amp;func</code>。</p></li><li><p><strong>回调函数（Callback function）</strong>：函数指针本质是一个指针，只不过这个指针指向一个函数。 函数指针变量也是一个变量，那么作为变量当然也可以当做参数来使用。 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。 (对比之下，在函数过程中调用别的函数，可以称作调用)。在C语言中提供了快速排序的函数：<code>void qsort( void *base, size_t num, size_t width, int (__cdecl *compare )(const void *elem1, const void *elem2 )</code>，qsort函数中包含一个函数指针compare，用于比较两个元素，该函数由用户传入，即回调函数。关于回调函数，也可以从调用方的角度考虑，平时写代码我们会<em>调用</em>系统提供的API，如果我们将自行实现的函数作为参数传递给系统去调用，那么可以被称作“<em>回调</em>”。</p><blockquote><p>A "callback" is any function that is called by another function which takes the first function as a parameter. （From StackOverflow）</p></blockquote></li><li><p><a href="https://stackoverflow.com/questions/3706704/whats-the-meaning-of-this-piece-of-code-void-signalint-sig-void-funcin">经典例子</a></p><p>[ <a href="https://blog.csdn.net/nirendao/article/details/118004231">易于理解的解释</a> ]：先看核心部分： <code>signal(int, void (*)(int))</code>，这就是signal函数名 加上 参数部分，而第二个参数是一个函数指针；将这一部分设为x，代入原型之后，其实就是返回值类型了：<code>void (*x)(int);</code>。</p><pre><code class="hljs C++"><span class="hljs-keyword">void</span> (*signal(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">int</span>)))(<span class="hljs-keyword">int</span>);<span class="hljs-comment">// 等价于</span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-keyword">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">sighandler_t</span> func)</span></span>;</code></pre></li></ul><hr /></li><li><p>C++面向对象三大特征</p><p>[ <a href="https://blog.csdn.net/lixungogogo/article/details/51118524">c++继承详解之一——继承的三种方式、派生类的对象模型</a> ]</p><p>封装、继承、多态。</p><p>其中，继承分为：</p><ul><li><strong>实现继承</strong>是指直接使用基类的属性和方法而无需额外编码的能力；</li><li><strong>接口继承</strong>是指仅使用属性和方法的名称、但是子类必须提供实现的能力。</li></ul><p>多态可以概括为“一个接口，多种方法”。分为两种：</p><ul><li><p>编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding</p></li><li><p>运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding</p></li></ul><hr /></li><li><p>重写、覆写、重载</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &#123;</span> <span class="hljs-keyword">private</span>:  <span class="hljs-keyword">int</span> a; <span class="hljs-keyword">public</span>:  Parent(<span class="hljs-keyword">int</span> s = <span class="hljs-number">10</span>) : a(s) &#123;&#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">F</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent.F()/n&quot;</span>); &#125;  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">G</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent.G()/n&quot;</span>); &#125;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x + y; &#125;  <span class="hljs-comment">//重载(overload)Add函数</span>  <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x + y; &#125;  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Parent&amp; t)</span></span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildOne</span> :</span> <span class="hljs-keyword">public</span> Parent &#123; <span class="hljs-keyword">public</span>:  <span class="hljs-comment">//重写(overwrite)父类函数</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">F</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ChildOne.F()\n&quot;</span>); &#125;  <span class="hljs-comment">//覆写(override)父类虚函数,主要实现多态</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">G</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ChildOne.G()\n&quot;</span>); &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Parent&amp; t)</span> </span>&#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; t.a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  ChildOne childOne;  <span class="hljs-comment">// = new ChildOne();</span>  Parent* p = &amp;childOne;  <span class="hljs-comment">//调用ChildOne.F</span>  <span class="hljs-comment">// childOne.F();</span>  show(*p);  <span class="hljs-comment">//调用Parent.F()</span>  p-&gt;F();  <span class="hljs-comment">//实现多态</span>  p-&gt;G();  Parent* p2 = <span class="hljs-keyword">new</span> Parent();  <span class="hljs-comment">//重载(overload)</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d/n&quot;</span>, p2-&gt;Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f/n&quot;</span>, p2-&gt;Add(<span class="hljs-number">3.4f</span>, <span class="hljs-number">4.5f</span>));  <span class="hljs-keyword">delete</span> p2;  system(<span class="hljs-string">&quot;PAUSE&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr /></li><li><p>extern作用：<strong>声明</strong> 全局变量和全局函数 [ <a href="https://www.cnblogs.com/honernan/p/13431431.html">参考</a> ]</p><p>函数的声明extern关键词是可有可无的，因为函数本身不加修饰的话就是extern的。但是引用的时候一样是需要声明的。</p><p>而全局变量在外部使用声明时（注意只有全局变量才能在外部使用），extern关键词是必须的。如果变量无extern修饰且没有显式的初始化，同样属于变量定义而非声明。因此，此时必须加extern，而编译器在此标记存储空间，在执行时加载入内存并初始化为0。而局部变量的声明不能有extern的修饰，且局部变量在运行时才在堆栈部分分配内存。</p><p>使用全局变量或函数的两种方式：</p><ul><li><p>在头文件中中显式使用<code>extern</code>声明全局变量或函数，然后在<code>*.cpp</code>文件下<code>#include</code>头文件调用；另外一种方式是需调用的源文件<code>base.cpp</code>中已经存在定义好的“全局变量和函数”（仅限<code>base.cpp</code>），则在当前源文件中调用需要使用<code>extern</code>显式声明。</p></li><li><p>extern "C" 和extern "C++"函数声明用于指明链接规范，如extern "C"，就指明使用C语言的链接规范。</p><p>适用场景：C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定。</p><pre><code class="hljs C++"><span class="hljs-comment">// 声明printf函数使用C链接</span><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)</span></span>;<span class="hljs-comment">// 声明函数ShowChar和GetChar使用 C 链接</span><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">ShowChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">GetChar</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;&#125;</code></pre></li></ul></li></ol><pre><code class="hljs yaml"><span class="hljs-meta">---</span></code></pre><ol start="6" type="1"><li><p>左值与右值 [ <a href="https://zhuanlan.zhihu.com/p/138210501">参考</a> ]</p><p>左值：指向内存位置的表达式被称为左值（lvalue）表达式，。左值可以出现在赋值号的左边或右边。</p><p>右值：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</p><p><strong>对于左值的引用就是左值引用，而对于右值的引用就是右值引用</strong>。</p><blockquote><p>规则简化如下：</p><p>左值引用 {左值}</p><p>右值引用 {右值}</p><p>常左值引用 {右值}</p></blockquote><p>C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值（pvalue）、将亡值（xvalue，expiring value，即将被销毁、却能够被移动的值）。</p><p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; v;v.push_back(str);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;After copy, str is &quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">//输出结果为 After copy, str is &quot;Hello&quot;</span>v.push_back(<span class="hljs-built_in">std</span>::move(str));<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;After move, str is &quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">//输出结果为 After move, str is &quot;&quot;</span></code></pre></p><hr /></li><li><p>全局变量、局部变量、形式参数</p><p>局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。</p><p>当局部变量被定义时，系统不会对其初始化，定义全局变量时，系统会自动初始化。</p><hr /></li><li><p>常量与进制</p><blockquote><p>二进制：0b+ 数字(0-1) ； 0b1010101</p><p>八进制：0+ 数字(0-7)； 0125</p><p>十进制： 数字(0-9)； 85</p><p>十六进制：0x+数字(0-9，A-F)；0x55 #前缀可大写</p></blockquote><hr /></li><li><p>volatile、static</p><p><code>volatile</code> 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，例如多任务环境下各任务间共享的标志应该加 <code>volatile</code>。</p><p>当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期，但未改变作用域； <code>static</code>修饰全局变量，并为改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量。用<code>static</code>修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化(初始化格式： int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用<code>const</code>修饰<code>static</code>数据成员在类内初始化 。[ <a href="https://blog.csdn.net/shihuboke/article/details/79286669">原文链接</a> ]</p><p><strong><code>static</code>和<code>const</code>是否可以联合使用？</strong>： 可以使用<code>static</code>和<code>const</code>修饰成员；但是不能用于同时修饰函数，存在语义矛盾，<code>const</code>修饰的函数会为函数隐式添加参数<code>this</code>，并且将<code>this</code>指针指向的对象置为<code>const</code>，<code>static</code>修饰的函数没有<code>this</code>指针，与<code>const</code>的用法冲突。。</p><hr /></li><li><p>运算符优先级 [ <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">C++ Operator Procedure</a> ]</p><p>[ <a href="https://www.zhihu.com/question/51601604">关于后缀自增运算符优先级问题</a> ]</p><blockquote><p>在"c=d++"中，后缀运算符的优先级更高的意义在于这个表达式应该被理解为"c=(d++)"而不是"(c=d)++"。而且，后一个表达式是不正确的，这就涉及到 lvalue 的问题了。后缀运算符"++"要求其修饰的表达式是 lvalue 的。所以后边一个表达式通常会无法编译。</p></blockquote><p>[ <a href="https://stackoverflow.com/questions/4261708/i-or-i-in-for-loops"><code>for-loop</code>中使用<code>++i</code>和<code>i++</code>的性能区别</a> ]</p><hr /></li><li><p><code>printf()</code>输出控制符号</p><p>[ <a href="https://www.runoob.com/cprogramming/c-function-printf.html">format</a> ] （#include &lt;cstdio&gt;）</p></li><li><p><code>std::ostream::operator&lt;&lt;</code> 输出控制符号</p><p>[ <a href="https://www.cplusplus.com/reference/ostream/ostream/operator%3C%3C/">manipulators</a> ] （#include &lt;iomanip&gt;）</p><hr /></li><li><p>C/C++中的数学运算支持与随机数</p><ul><li><p>cmath支持的函数 [ <a href="https://www.cplusplus.com/reference/cmath/">参考文档</a> ]</p></li><li><p>随机数字</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;         srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">// 不属于std命名空间</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>;i++ )                 cout &lt;&lt; rand() &lt;&lt; &#x27;/t&#x27;;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>要取得[a,b)的随机整数，使用(rand() % (b-a))+ a; 要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a; 要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1; 通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。 要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。 要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。</p></blockquote></li></ul><hr /></li><li><p>C++传递数组的三种方式</p><p>==主要需要复习的知识点的数组名与数组指针==</p><p><pre><code class="hljs c++">void myFunction(int *param)；void myFunction(int param[10])；void myFunction(int param[])；</code></pre></p><hr /></li><li><p>cstring中的字符数组操作和C++的string类别</p><p><code>strcpy(t, s)</code> <code>strcat(t, s)</code> <code>strlen(s)</code> <code>strcmp(s1, s2)</code> <code>strchr(s1, ch)</code> <code>strstr(s1, s2)</code></p><hr /></li><li><p>指针（C和C++中的重要概念）</p><p>详见<code>C++面向对象编程.md</code></p><ul><li>指针与引用的区别</li></ul><blockquote><ol type="1"><li>引用必须在创建时被初始化；指针可以在任何时间被初始化。</li><li>引用被初始化为一个对象就不可改变；指针可以在任何时候指向到另一个对象。</li><li>不存在空引用。引用必须连接到一块合法的内存。</li></ol></blockquote><hr /></li><li><p><code>swap</code>的注意点</p><p>在标准库中，swap的实现是基于引用的，可用于交换两个同类型变量的值。</p><p><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">swap</span>(<span class="hljs-title">T</span>&amp; <span class="hljs-title">a</span>, <span class="hljs-title">T</span>&amp; <span class="hljs-title">b</span>) &#123;</span>  <span class="hljs-function">T <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::move(a))</span></span>;  a = <span class="hljs-built_in">std</span>::move(b);  b = <span class="hljs-built_in">std</span>::move(c);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">size_t</span> <span class="hljs-title">N</span>&gt;</span><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">swap</span>(<span class="hljs-title">T</span> (&amp;<span class="hljs-title">a</span>)[<span class="hljs-title">N</span>], <span class="hljs-title">T</span> (&amp;<span class="hljs-title">b</span>)[<span class="hljs-title">N</span>]) &#123;</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) swap(a[i], b[i]);&#125;</code></pre></p><ul><li>需要注意，交换迭代器指向的内容，应当使用<code>iter_swap</code>，等价于<code>swap(*it1, *it2)</code>。</li><li>亦可以使用<code>swap</code>或<code>std::vector::swap</code>交换两个vector的所有内容，容器长度可以不同。</li></ul><hr /></li><li><p><code>auto</code>与<code>decltype</code> 自动类型推导</p><p>[ <a href="https://www.zhihu.com/question/35517805/answer/63304992">如何评价 C++ 11 auto 关键字</a> ]</p><hr /></li><li><p>运算符重载</p><ul><li><p>不可重载的运算符</p><p><code>.</code>成员访问运算符 <code>.*, -&gt;*</code>成员指针访问运算符 <code>::</code>域运算符</p><p><code>sizeof</code>长度运算符 <code>? :</code>条件运算符 <code>#</code>预处理符号</p></li><li><p>可重载运算符</p><table><thead><tr class="header"><th>双目算术运算符</th><th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th></tr></thead><tbody><tr class="odd"><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr class="even"><td>逻辑运算符</td><td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr class="odd"><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr class="even"><td>自增自减运算符</td><td>++(自增)，--(自减)</td></tr><tr class="odd"><td>位运算符</td><td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr class="even"><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr class="odd"><td>空间申请与释放</td><td>new, delete, new[ ] , delete[]</td></tr><tr class="even"><td>其他运算符</td><td>()(函数调用)，-&gt;(成员访问)，,(逗号)，[] (下标)</td></tr></tbody></table></li></ul><hr /></li><li><p><code>map</code>、<code>set</code>、<code>priority_queue</code>的自定义排序顺序</p><p>上述三类容器中的元素在STL中默认升序排列，需要注意此时<code>priority_queue</code>是大顶堆。优先队列默认是大根堆，即最大元素在数组开头，而使用的默认less比较方式是因为，在堆进行上浮或者下沉的操作中会使用less比较，判断若根节点元素小于其子节点，则返回true，进行调整，较大元素上浮。</p><p>==所以，less表现为大顶堆而greater表现为小顶堆。==</p><p>可以通过自定义一个比较类（<strong>仿函数类</strong>）并重载函数调用运算符<code>()</code>，例子如下：</p><p><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CMP</span> &#123;</span>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> Type&amp; lhs, <span class="hljs-keyword">const</span> Type&amp; rhs)</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> lhs &lt; rhs;&#125; <span class="hljs-comment">// pq大顶堆，小的向下交换</span>&#125;;<span class="hljs-built_in">priority_queue</span>&lt;Type, <span class="hljs-built_in">vector</span>&lt;Type&gt;, CMP&lt;Type&gt;&gt; pq;</code></pre></p><p>第二种方式是重载关系运算符<code>&lt;</code>实现对象的比较，例子如下：</p><p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>  <span class="hljs-keyword">int</span> val;  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Node a) <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> val &gt; a.val;&#125; <span class="hljs-comment">// pq小顶堆，大的向下交换</span>&#125;;<span class="hljs-built_in">priority_queue</span>&lt;Node&gt; pq;</code></pre></p><p>而对于<code>&lt;algorithm&gt;</code>中的<code>sort</code>函数，则还可以自定义比较函数，例子如下：</p><p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> Node a, <span class="hljs-keyword">const</span> node b)</span> </span>&#123; <span class="hljs-keyword">return</span> (a.val &lt; b.val);&#125; <span class="hljs-comment">// 数组元素升序排列</span>sort(nodes.begin(), nodes.end(), cmp);</code></pre></p><p>最后一种我用得比较少，使用lambda函数，例子如下：</p><p><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &amp;l, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &amp;r) &#123;  <span class="hljs-keyword">return</span> l.second &lt; r.second;&#125;;std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; pq(cmp);</code></pre></p><blockquote><p><strong>The type of the <em>lambda-expression</em> (which is also the type of the closure object) </strong> is a unique, unnamed non-union class type -- called the <code>closure type</code> ...</p></blockquote><p>此外，当重载关系运算成对时，可以把一个运算符的比较工作委托给另外一个已经实现的运算，例如<code>&gt;</code>和<code>&lt;</code>。</p><hr /></li><li><p>访问修饰符</p><p><code>public</code>， <code>private</code>， <code>protected</code>。一个类可以有多个标记区域，有效区间为当前位置到下一个访问修饰符。</p><hr /></li><li><p>函数重载与运算符重载</p><blockquote><p>函数的参数个数不同。函数的参数类型不同或者参数类型顺序不同。</p></blockquote><ul><li>运算符重载，算法题常用的是自定义对象（或结构体）的比较，比如用于优先队列的重载有<a href="https://blog.csdn.net/AAMahone/article/details/82787184">三种实现方式</a>。</li></ul><hr /></li><li><p>构造函数相关</p><ul><li><p>拷贝构造函数</p><blockquote><p>用途：(1) 通过使用另一个同类型的对象来初始化新创建的对象；(2) 复制对象把它作为参数传递给函数；(3) 复制对象，并从函数返回这个对象。</p><p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。<strong>如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。</strong></p></blockquote></li></ul><hr /></li><li><p>友元函数</p><blockquote><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p></blockquote><hr /></li><li><p>前缀自增/减运算符（<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/prefix-increment-and-decrement-operators-increment-and-decrement?view=msvc-170">++ unary-expression</a>）、后缀自增/减运算符（postfix-expression ++）</p><ul><li><p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/increment-and-decrement-operator-overloading-cpp?view=msvc-170">重载方式</a></p><pre><code class="hljs cpp"><span class="hljs-comment">// Declare prefix and postfix increment operators.</span>Point&amp; <span class="hljs-keyword">operator</span>++();    <span class="hljs-comment">// Prefix increment operator.</span>Point <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>);  <span class="hljs-comment">// Postfix increment operator. </span><span class="hljs-comment">// Declare prefix and postfix decrement operators.</span>Point&amp; <span class="hljs-keyword">operator</span>--();    <span class="hljs-comment">// Prefix decrement operator.</span>Point <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>);  <span class="hljs-comment">// Postfix decrement operator.</span></code></pre></li></ul><hr /></li><li><p>匿名函数Lambda</p><pre><code><pre><code class="hljs C++">[capture <span class="hljs-built_in">list</span>] (params <span class="hljs-built_in">list</span>) <span class="hljs-keyword">mutable</span> exception-&gt; <span class="hljs-keyword">return</span> type &#123; function body &#125;</code></pre>基本形式如上，`capture list`：捕获外部变量列表，`params list`：形参列表，`mutable`指示符：用来说用是否可以修改捕获的变量，`exception`：异常设定，`return type`：返回类型，`function body`：函数体。</code></pre><ul><li><a href="https://www.cnblogs.com/yajiu/p/15693724.html">lambda表达式如何捕获成员变量 - 亚九 - 博客园 (cnblogs.com)</a></li></ul><hr /></li><li><p>C/C++的<a href="https://blog.csdn.net/gongjianbo1992/article/details/102834556">可变长参数</a></p><blockquote><p>C语言通过三个宏（va_start、va_end、va_arg）和一个类型（va_list）实现，<code>__VA_ARGS__</code>(C99?)在调用时替换成可变参数。由于无类型检查，存在安全问题，并且<a href="https://blog.csdn.net/Erice_s/article/details/101811535">不能自动识别可变参数的数量</a>。</p><p>C++可以使用<code>std::initializer_list参数列表</code>、<code>模板参数包（变长模板variadic templates）</code>。</p><p>可变长参数最需要关注的是如何展开可变参数，一种是通过<code>递归函数</code>来展开参数包，另外一种是通过<code>逗号表达式</code>来展开参数包。</p></blockquote><ul><li><p><a href="https://www.cnblogs.com/chinazhangjie/archive/2012/08/18/2645475.html">C语言中的宏</a></p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdarg.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(...) printf(__VA_ARGS__)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stdarg_counter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count, ...)</span> </span>&#123;  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;  <span class="hljs-comment">//这是一个适用于 va_start()、va_arg() 和 va_end() 这三个宏存储信息的类型</span>  <span class="hljs-built_in">std</span>::va_list args;  <span class="hljs-comment">//这个宏初始化args变量，它与 va_arg 和 va_end 宏是一起使用的。</span>  <span class="hljs-comment">//第二个参数count是最后一个传递给函数的已知的固定参数，即省略号之前的参数。</span>  va_start(args, count);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;    <span class="hljs-comment">//这个宏检索函数参数列表中类型为 type 的下一个参数</span>    sum += va_arg(args, <span class="hljs-keyword">int</span>);  &#125;  <span class="hljs-comment">//这个宏允许使用了 va_start 宏的带有可变参数的函数返回。</span>  <span class="hljs-comment">//如果在从函数返回之前没有调用 va_end，则结果为未定义。</span>  va_end(args);  <span class="hljs-keyword">return</span> sum;&#125;</code></pre></li><li><p>参数列表</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;initializer_list&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">list_counter</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;T&gt; args)</span> </span>&#123;  T temp = T();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> T &amp;item : args) &#123;    temp += item;  &#125;  <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; list_counter&lt;<span class="hljs-keyword">double</span>&gt;(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.5</span>&#125;) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">//  1.5</span>  system(<span class="hljs-string">&quot;pause&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><a href="https://zh.cppreference.com/w/cpp/language/parameter_pack">Parameter Pack</a> 让编译器能够轻松地唯一地确定包到底有多大</p><pre><code class="hljs C++"><span class="hljs-comment">// 递归解包</span><span class="hljs-comment">// 需要考虑递归效率，编译时也需要生成不少版本的_write  (重载)</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">void</span> _write(<span class="hljs-keyword">const</span> T&amp; t) &#123;  <span class="hljs-built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-keyword">void</span> _write(<span class="hljs-keyword">const</span> T&amp; t, Args... args) &#123;  <span class="hljs-built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span>;  _write(      args...);  <span class="hljs-comment">//递归解决，利用模板推导机制，每次取出第一个，缩短参数包的大小。</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write_line</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; t, <span class="hljs-keyword">const</span> Args&amp;... data)</span> </span>&#123;  _write(t, data...);&#125;<span class="hljs-comment">// 第二种</span><span class="hljs-comment">// 参数包在展开的时候，是从右（结束）向左（开始）进行的</span><span class="hljs-comment">// 所以unpacker(data)...所打印出来的东西可能是反序的</span><span class="hljs-comment">// 这与编译器的具体实现相关（gcc会，clang不会）</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DummyWrapper</span><span class="hljs-params">(T... t)</span> </span>&#123;&#125; <span class="hljs-comment">// 编译器会优化掉</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">T</span> <span class="hljs-title">unpacker</span>(<span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">t</span>) &#123;</span>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; t;  <span class="hljs-keyword">return</span> t;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_line1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; t, <span class="hljs-keyword">const</span> Args&amp;... data)</span> </span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; t;  <span class="hljs-comment">//直接用unpacker(data)...是非法的，（可以认为直接逗号并列一堆结果没有意义）</span>  DummyWrapper(unpacker(data)...);  <span class="hljs-comment">//也可以使用 int arr[] = &#123;(unpacker(data), 0)...&#125;;</span>  <span class="hljs-comment">//所以需要用一个函数包裹一下，就好像这些结果后面还有用</span>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;<span class="hljs-comment">//C++ 17</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_line2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; t, <span class="hljs-keyword">const</span> Args&amp;... data)</span> </span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; t;  (unpacker(data), ...);  <span class="hljs-comment">//展开成(((unpacker(data_1), unpacker(data_2)),</span>                          <span class="hljs-comment">// unpacker(data_3), ... ),unpacker(data_n)</span>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre><p>[ <a href="https://blog.csdn.net/yanxiangtianji/article/details/21045525">特殊情况</a> ] [ <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">C++17 Deduction Guide</a> ]</p><p>[ <a href="https://www.cnblogs.com/qicosmos/p/4325949.html">泛化之美--C++11可变模版参数的妙用</a> ， <a href="https://www.cnblogs.com/pandamohist/p/13856489.html">c++11之函数参数包展开 - 博客园</a> ] (这两篇总结得非常好)</p></li></ul><hr /></li><li><p>可变模版参数类</p><p>可变参数模板类是一个带可变模板参数的模板类，比如C++11中的元祖std::tuple就是一个可变模板类。</p><p>请参考 [ <a href="https://www.cnblogs.com/qicosmos/p/4325949.html">泛化之美--C++11可变模版参数的妙用</a> ]</p><hr /></li><li><p>类的静态成员</p><blockquote><p>静态成员为所有类对象所共享，不属于某个具体的实例；</p><p>静态成员必须在类外定义，定义的时候不添加static关键字；</p><p>类静态成员即可用<code>类名::静态成员</code>或者<code>对象.静态成员</code>来访问；</p><p>静态成员函数没有隐藏的this指针，不能访问任何静态成员；</p><p>静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值、const修饰符等参数。</p></blockquote><p>[ <a href="https://blog.csdn.net/zgaoq/article/details/68069502">成员变量的初始化</a> ]</p><hr /></li><li><p><code>std::bind</code>与<code>std::function</code></p><p>[ <a href="https://www.jianshu.com/p/f191e88dcc80">参考资料</a> ]</p><p>结论：在C和C++中，函数指针非常重要，关注==指向成员函数的指针==。</p><p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span> &#123;</span>    <span class="hljs-keyword">int</span> value;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;f(&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;value &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;g(&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;value &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>; &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(Foo* foo1, Foo* foo2, <span class="hljs-keyword">void</span> (Foo::*fun)())</span> </span>&#123;    (foo1-&gt;*fun)();  <span class="hljs-comment">// call fun on the object foo1</span>    (foo2-&gt;*fun)();  <span class="hljs-comment">// call fun on the object foo2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Foo foo1&#123;<span class="hljs-number">1</span>&#125;;    Foo foo2&#123;<span class="hljs-number">2</span>&#125;;    apply(&amp;foo1, &amp;foo2, &amp;Foo::f);    apply(&amp;foo1, &amp;foo2, &amp;Foo::g);&#125;</code></pre></p><ul><li><p>成员函数指针的定义：void (Foo::*fun)()，调用是传递的实参: &amp;Foo::f；注意此时复制不可省略<code>&amp;</code>符号。</p></li><li><p>fun为类成员函数指针，所以调用是要通过解引用的方式获取成员函数*fun,即<code>(foo1-&gt;*fun)();</code></p></li></ul><hr /></li><li><p>结构体赋值方法</p><p>主要包括：定义时赋值、定义后逐个赋值、定义时乱序赋值（C风格）、定义时乱序赋值（C++风格） [ <a href="https://blog.csdn.net/ericbar/article/details/79567108">参考</a> ] [ <a href="https://www.zhihu.com/question/27862634">结构体内存对齐</a> ]</p><ul><li><p>C风格</p><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InitMember</span> <span class="hljs-title">test</span> = &#123;</span>    .second = <span class="hljs-number">3.141590</span>,    .third = <span class="hljs-string">&quot;method three&quot;</span>,    .first = <span class="hljs-number">-10</span>,    .four = <span class="hljs-number">0.25</span>&#125;;</code></pre></li><li><p>C++风格</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InitMember</span> <span class="hljs-title">test</span> = &#123;</span>    .second = <span class="hljs-number">3.141590</span>,    .third = <span class="hljs-string">&quot;method three&quot;</span>,    .first = <span class="hljs-number">-10</span>,    .four = <span class="hljs-number">0.25</span>&#125;;</code></pre></li></ul><hr /></li><li><p>逻辑<code>&amp;&amp;</code>、<code>||</code></p><p>写代码的时候，递归中返回布尔值的时候，需要注意“逻辑短路”问题。</p><p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m)</span> </span>&#123;  <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= n || y &lt; <span class="hljs-number">0</span> || y &gt;= m) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-keyword">if</span> (grid[x][y] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  grid[x][y] = <span class="hljs-number">1</span>;  <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;dir : dirs) &#123;    <span class="hljs-comment">// 这行代码被优化了，别用，“或”逻辑前面为1，“与”逻辑前面为0就会发生短路,dfs不会继续进行</span>    <span class="hljs-comment">// flag = flag &amp;&amp; dfs(grid, x + dir[0], y + dir[1], n, m);</span>    <span class="hljs-keyword">if</span> (!dfs(grid, x + dir[<span class="hljs-number">0</span>], y + dir[<span class="hljs-number">1</span>], n, m)) &#123;      flag = <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-keyword">return</span> flag;&#125;</code></pre></p><hr /></li><li><p><font color='red'>C++中内存管理（存疑）</font></p><blockquote><p>（结构）在C++中，内存分成4个区，他们分别是堆（自由存储区C++概念）、栈、全局/静态存储区和常量存储区。 （问，堆(malloc/free)和自由存储(new/delete)的区别吗，自由存储区可以借堆实现）（代码区 算运行时的第五个区？）</p><p>（管理）指针（申请释放过程）、构造函数与析构函数、智能指针</p></blockquote><p>在C++中有两种创建对象的方式：栈上<code>Object obj</code>或自由存储区（堆）上<code>Object *pt = new Object()</code>。</p><p>局部静态变量和全局静态变量都是编译时分配空间，区别在于作用域，局部静态变量仅对定义它的作用域（例如，函数）可见。</p><ul><li><p>C++中delete this是对象先析构还是delete语句先返回？</p><p>先析构。[ <a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this">delete this合法，但需要满足一定条件</a> ]</p></li><li><p><a href="https://interview.huihut.com/#/?id=如何定义一个只能在堆上（栈上）生成对象的类？">如何定义一个只能在堆上（栈上）生成对象的类？</a></p></li></ul><hr /></li><li><p>智能指针（管理堆内存）</p><p>C++11中的智能指针：<code>unique_ptr</code>，<code>shared_ptr</code>，<code>weak_ptr</code>。方便管理==<strong>堆内存</strong>==，避免内存泄漏。其原理是，在智能指针对象析构时，会自动释放堆内存，若其指向的堆内存存在特殊的回收机制，可以自定义析构函数。</p><ul><li><p>unique_ptr</p><p>独占型指针，不允许拷贝和赋值。禁止拷贝语义也存在特例，即可以通过一个函数返回一个 std::unique_ptr。如果需要转移内存的持有权，可以使用std::move移动构造。</p><p>C++14才支持<code>std::make_unique</code>初始化方式</p><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; uptr = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">123</span>);<span class="hljs-comment">// C++11标准库中未提供，可采用如下实现</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt; <span class="hljs-comment">// T为对象类型，Ts为对象初始化参数</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp; ...params)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T(<span class="hljs-built_in">std</span>::forward&lt;Ts&gt;(params)...));&#125;<span class="hljs-comment">// 用法</span><span class="hljs-built_in">unique_ptr</span>&lt;Node&gt; up = MakeUnique&lt;Node&gt;(<span class="hljs-number">99</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre></li><li><p>shared_ptr</p><p>堆内存资源可以在多个shared_ptr之间共享，该智能指针包含了一个资源引用计数器（多线程安全），并提供use_count()来获取引用计数。</p><p><code>std::make_shared</code></p></li><li><p>weak_ptr</p><p>std::weak_ptr是一个不控制资源生命周期的智能指针，是对对象的一种<strong>弱引用</strong>，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助std::shared_ptr工作（例如，可用来解决两个std::shared_ptr相互引用时的死锁问题）。[ <a href="https://blog.csdn.net/Xiejingfa/article/details/50772571">参考博客</a> ]</p><p>std::weak_ptr不控制资源生命周期，但提供了`<code>expired()</code>方法来检测引用的资源是否存在。也可以通过<code>lock()</code>方法的返回值判断，若对象存在则返回一个shared_ptr，若不存在则返回nullptr。另外，std::weak_ptr并没有重载<code>operator-&gt;</code>，<code>operator*</code>和<code>operator!</code>，因此无法直接通过引用对象来判断是否存在。</p><p>典型例子：订阅者模式或者观察者模式</p></li></ul><p>若类继承自<code>std::enable_shared_from_this</code>，则可以通过<code>return_from_this()</code>返回当前对象指针this（但是<strong>不应该共享栈对象的 this 给智能指针对象</strong>；应当避免<strong>循环引用</strong>，即一个资源A的生命周期可以交给一个智能指针对象，但是该智能指针的生命周期不可以再交给整个资源A来管理）。</p><ul><li><p>使用智能指针管理数组</p><p>[ <a href="https://blog.csdn.net/DumpDoctorWang/article/details/88600780">如何使用智能指针管理数组</a>、<a href="https://blog.csdn.net/wks19891215/article/details/50992171">管理动态数组</a>、<a href="https://www.cnblogs.com/apocelipes/p/10346928.html">shared_ptr和动态数组 - apocelipes - 博客园</a>、<a href="https://wangjunstf.github.io/2021/09/12/c-dong-tai-nei-cun-yu-zhi-neng-zhi-zhen/">不支持下标运算和指针算数时如何获取数组元素</a> ]</p><p>shared_ptr和unique_ptr均可以通过自定义deleter（删除器）的方式实现。</p><pre><code class="hljs C++"><span class="hljs-comment">// 方式1</span><span class="hljs-keyword">auto</span> Deleter = [](Connection *connection) &#123; <span class="hljs-keyword">delete</span>[] connection; &#125;;Connection *c1 = <span class="hljs-keyword">new</span> Connection[<span class="hljs-number">2</span>]&#123;<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;c1&quot;</span>), <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;c2&quot;</span>)&#125;;<span class="hljs-comment">// 新建管理连接Connection的智能指针</span>unique_ptr&lt;Connection, decltype(Deleter)&gt; up(c1, Deleter);<span class="hljs-comment">// 方式2</span>Connection *c1 = <span class="hljs-keyword">new</span> Connection[<span class="hljs-number">2</span>]&#123;<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;c1&quot;</span>), <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;c2&quot;</span>)&#125;;<span class="hljs-comment">// 新建管理连接Connection的智能指针</span>unique_ptr&lt;Connection[]&gt; up(c1);<span class="hljs-comment">// 方式1的局限在于不支持[]和ptr运算</span><span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-keyword">int</span> *p)&#123;delet[] p&#125;)</span></span><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; i++)</span> *<span class="hljs-params">(sp.get() + i)</span> </span>= i;  <span class="hljs-comment">//使用get获取动态数组的第一个元素的指针</span></code></pre></li><li><p>unique_ptr和shared_ptr模板参数上的区别</p><p>[ <a href="https://fuzhe1989.github.io/2017/05/19/cpp-different-role-of-deleter-in-unique-ptr-and-shared-ptr/">为什么unique_ptr的Deleter是模板类型参数，而shared_ptr的Deleter不是？</a>、<a href="https://blog.csdn.net/DumpDoctorWang/article/details/88598015">C++ 智能指针自定义删除器 - CSDN博客</a> ]</p><pre><code class="hljs C++">A *pA = <span class="hljs-keyword">new</span> A[<span class="hljs-number">3</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;A *pA2 = <span class="hljs-keyword">new</span> A[<span class="hljs-number">2</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">auto</span> arr_deleter = [](A *arr) &#123; <span class="hljs-keyword">delete</span>[] arr; &#125;;unique_ptr&lt;A, decltype(arr_deleter)&gt; uptr(pA, arr_deleter);<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; <span class="hljs-title">sptr</span><span class="hljs-params">(pA2, arr_deleter)</span></span>;</code></pre><p>unique_ptr的第二个模板类型参数是Deleter，而shared_ptr的Delete则只是构造函数参数的一部分。出于效率考虑，unique_ptr的设计目标之一是尽可能的高效，如果用户不指定Deleter，就要像原生指针一样高效。</p></li></ul><hr /></li><li><p><code>::</code>作用域符</p><ol type="1"><li><p>global scope(全局作用域符），用法（::name)</p><pre><code class="hljs C++"><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;1&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;2&#x27;</span>;  <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(c + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(::c + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre></li><li><p>class scope(类作用域符），用法(class::name)</p></li><li><p>namespace scope(命名空间作用域符），用法(namespace::name)</p></li></ol><p>PS：<code>&#123;&#125;</code>可以用于在函数中限定局部变量或对象和的作用域，出了作用域则无法访问或析构。</p><hr /></li><li><p><code>using</code>的<a href="http://bitdewy.github.io/blog/2013/05/21/cpp11-keywords-using/">其它用法</a></p><ul><li><p>函数别名与模板别名</p></li><li><p>命名空间与空间成员</p></li><li><p>派生类中使用基类同名函数</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span>  A(<span class="hljs-keyword">int</span> i) &#123;&#125;  A(<span class="hljs-keyword">double</span> d,<span class="hljs-keyword">int</span> i)&#123;&#125;  A(<span class="hljs-keyword">float</span> f,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* c)&#123;&#125;  <span class="hljs-comment">//...等等系列的构造函数版本号</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>:</span>A &#123;  <span class="hljs-keyword">using</span> A::A;  <span class="hljs-comment">//关于基类各构造函数的继承一句话搞定</span>  <span class="hljs-comment">//......</span>&#125;;</code></pre></li></ul></li></ol><pre><code class="hljs yaml"><span class="hljs-meta">---</span></code></pre><ol start="37" type="1"><li><p>namespace命名空间</p><p>[ <a href="https://blog.csdn.net/PecoHe/article/details/112505385">C++命名空间：默认命名空间与匿名命名空间 - CSDN</a> ]</p><hr /></li><li><p>结构体的四种初始化方法</p><p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InitMember</span> &#123;</span>    <span class="hljs-keyword">int</span> first；    <span class="hljs-keyword">double</span> second；    <span class="hljs-keyword">char</span>* third；    <span class="hljs-keyword">float</span> four;&#125;;</code></pre></p><ul><li><p>定义时赋值</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InitMember</span> <span class="hljs-title">test</span> = &#123;</span><span class="hljs-number">-10</span>,<span class="hljs-number">3.141590</span>，<span class="hljs-string">&quot;method one&quot;</span>，<span class="hljs-number">0.25</span>&#125;；</code></pre></li><li><p>定义后逐个赋值</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InitMember</span> <span class="hljs-title">test</span>；</span><span class="hljs-class"></span><span class="hljs-class"><span class="hljs-title">test</span>.<span class="hljs-title">first</span> = -10;</span>test.second = <span class="hljs-number">3.141590</span>;test.third = <span class="hljs-string">&quot;method two&quot;</span>;test.four = <span class="hljs-number">0.25</span>;</code></pre></li><li><p>C风格乱序赋值</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InitMember</span> <span class="hljs-title">test</span> = &#123;</span>    .second = <span class="hljs-number">3.141590</span>,    .third = <span class="hljs-string">&quot;method three&quot;</span>,    .first = <span class="hljs-number">-10</span>,    .four = <span class="hljs-number">0.25</span>&#125;;</code></pre></li><li><p>C++风格乱序赋值</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InitMember</span> <span class="hljs-title">test</span> = &#123;</span>    second：<span class="hljs-number">3.141590</span>,    third：<span class="hljs-string">&quot;method three&quot;</span>,    first：<span class="hljs-number">-10</span>,    four：<span class="hljs-number">0.25</span>&#125;;</code></pre></li></ul><hr /></li><li><p>非类型类模板参数(Nontype Class Template Parameters)</p></li><li><p>Pimpl惯用法解析（pointer to implementation, <a href="https://blog.csdn.net/lihao21/article/details/47610309">指向实现的指针</a>）</p></li><li><p>定义在类内部的类型，需要只用下面的方法获取 [ <a href="https://stackoverflow.com/questions/26415054/return-type-out-of-line-definition-differs-from-that-in-the-declaration">stackoverflow</a> ]</p><p><pre><code class="hljs C++"><span class="hljs-comment">// ListNode定义在MyLinkedList内部</span><span class="hljs-function">MyLinkedList::ListNode *<span class="hljs-title">MyLinkedList::findNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;  <span class="hljs-comment">// 确保输入的index合法</span>  <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;  ListNode *curr = hair;  <span class="hljs-keyword">while</span> (cnt &lt; index) &#123;    curr = curr-&gt;next;    ++cnt;  &#125;  <span class="hljs-keyword">return</span> curr;&#125;</code></pre></p><hr /></li><li><p><code>typename</code>的<a href="https://feihu.me/blog/2014/the-origin-and-usage-of-typename/">几种用法</a></p></li><li><p>关于拷贝构造函数为什么可以访问另一个对象的私有成员 [ <a href="https://www.cnblogs.com/dwdxdy/archive/2012/07/17/2595741.html">解释</a> ]</p><blockquote><p>封装是编译期的概念，是针对类型而非对象的，在类的成员函数中可以访问同类型实例对象的私有成员变量</p></blockquote><hr /></li><li><p>⭐虚函数</p><p>[ <a href="https://zhuanlan.zhihu.com/p/148290103">C++基类的析构函数为何要声明为虚函数 - 知乎</a> 、<a href="https://blog.twofei.com/496/">⭐C++中的虚函数表实现机制与内存布局解析</a> ]</p><ul><li><strong>析构函数</strong>可定义为虚函数。基类指针可以指向派生类的对象（多态性），如果删除该指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。析构函数不定义为虚函数时，编译器实施静态绑定，在删除基类指针时只会调用基类析构函数，导致析构不完全。</li><li><strong>构造函数</strong>不能是虚函数。构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。构造函数调用完成后才会形成虚函数表指针。</li><li>静态函数、内联函数、非成员函数不可定义为虚函数。</li></ul><hr /></li><li><p>纯虚函数与抽象基类</p><p>纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。（作用是提供接口）</p><hr /></li><li><p>强制类型转换运算符</p><ul><li><p>static_cast</p><p>用于非多态类型的转换，例如数值类型转换，转换时不执行运行时类型检查。父类向派子类转化不安全，子类向父类转化安全。</p></li><li><p>dynamic_cast</p><p>用于多态类型转换，仅用于指针和引用，转换时执行运行时类型检查。可在父类与子类间转换。</p></li><li><p>const_cast</p><p>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</p></li><li><p>reinterpret_cast</p></li><li><p>bad_cast</p><p>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常</p></li><li><p>RTTI查看运行时类型信息</p><p>使用头文件typeinfo。</p><p>typeid 运算符允许在运行时确定对象的<strong>实际类型</strong>，可返回一个 type_info 对象的引用。</p></li></ul><hr /></li><li><p>C/C++ 函数调用约定</p><p>[ <a href="https://zhuanlan.zhihu.com/p/181467546">C/C++ 函数调用规范 - 知乎</a> ]</p><hr /></li><li><p>静态成员不能在类内初始化</p><p>[ <a href="https://blog.csdn.net/digitalkee/article/details/105301444">为什么类中静态(static)成员不能在类的定义内初始化</a>、<a href="https://www.runoob.com/cplusplus/cpp-static-members.html">C++ 类的静态成员</a>、<a href="https://www.runoob.com/w3cnote/cpp-static-const.html">static、const 和 static const成员变量声明以及初始化</a>（类内初始化是C++11的新特性）、<a href="https://blog.csdn.net/lanchunhui/article/details/50772363">C++ 类中特殊成员变量（常量、静态、引用）的初始化方法</a>]</p><pre><code class="hljs C++">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span> <span class="hljs-keyword">public</span>:  Test() : a(<span class="hljs-number">0</span>) &#123;&#125;  <span class="hljs-keyword">enum</span> &#123; size1 = <span class="hljs-number">100</span>, size2 = <span class="hljs-number">200</span> &#125;; <span class="hljs-keyword">private</span>:  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a;        <span class="hljs-comment">//只能在构造函数初始化列表中初始化</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b;       <span class="hljs-comment">//在类的实现文件中定义并初始化</span>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c;  <span class="hljs-comment">//与 static const int c;相同</span>&#125;;<span class="hljs-keyword">int</span> Test::b=<span class="hljs-number">0</span>;  <span class="hljs-comment">//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象</span>cosnt intTest::c=<span class="hljs-number">0</span>;  <span class="hljs-comment">//注意：给静态成员常量赋值时，不需要加static修饰符，但要加cosnt</span></code></pre><p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化。注意 static 关键字只能用于类定义体内部的声明中，定义时不能标示为 static。</p><hr /></li><li><p>C++异常处理</p><p>[ <a href="https://blog.csdn.net/jiemashizhen/article/details/123907897">C++析构函数默认是noexcept</a> ]</p><hr /></li><li><p>#与##用途</p><p><code>#</code>的功能是将其后面的宏参数进行字符串化操作（Stringfication），简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号。</p><p><code>##</code>连接符号由两个井号组成，其功能是在带参数的宏定义中将两个子串(token)联接起来，从而形成一个新的子串。但它不可以是第一个或者最后一个子串。所谓的子串(token)就是指编译器能够识别的最小语法单元。</p><hr /></li><li><p>vector的内存结构</p><p>[ <a href="https://www.codeleading.com/article/16195448865/">关于vector变量名的地址和元素地址不相同的问题</a> ]</p><p>在C++中，vector的<strong>对象存放在栈区，元素存放在堆区</strong>，且变量名地址中存放的是堆区元素的首地址。</p><hr /></li><li><p>右值返回值</p><p>[ <a href="https://www.zhihu.com/question/443571654/answer/1723219351">c++17具名返回值优化NRVO</a> ]</p><hr /></li><li><p>std::bind的返回类型</p><ul><li><p>std::bind返回的function类型，一要看被绑定函数的参数列表，二要看bind有没有指定参数。如下所示：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; f1 = <span class="hljs-built_in">std</span>::bind(&amp;func, <span class="hljs-built_in">std</span>::placeholders::_1, <span class="hljs-number">10</span>);<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>()&gt; f0 = <span class="hljs-built_in">std</span>::bind(&amp;func, <span class="hljs-number">90</span>, <span class="hljs-number">10</span>);</code></pre></li><li><p>std::bind按值拷贝以及std::ref的用处</p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<span class="hljs-comment">// 显示利用std::ref来进行引用绑定，可以发现x的值变化了</span><span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">std</span>::bind([](<span class="hljs-keyword">int</span> &amp;y) &#123; y = <span class="hljs-number">99</span>; &#125;, <span class="hljs-built_in">std</span>::ref(x));<span class="hljs-comment">// 此处是按值拷贝，所以并不会修改x的值</span><span class="hljs-comment">// auto f = std::bind([](int &amp;y) &#123; y = 99; &#125;, x);</span>f(); <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;</code></pre></li></ul><hr /></li><li><p>std::future</p><p>[ <a href="https://www.cnblogs.com/haippy/p/3280643.html">C++11 并发指南四( 详解三 std::future &amp; std::shared_future)</a> ]</p><p>std::future可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。std::future 通常由某个 Provider 创建，此处Provider相当于一个异步任务的提供者。Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会<strong>阻塞</strong>当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），std::future::get 返回异步任务的值或异常（如果发生了异常）。</p><hr /></li><li><p>如何理解面向对象（C++）中的封装、继承、多态？</p><p>[<a href="https://www.stroustrup.com/bsfaqcn.html">Bjarne Stroustrup's FAQ（中文版）</a> ]</p><p>[ <a href="https://www.zhihu.com/question/52767718/answer/143989505">这样理解面向对象的封装，继承，多态是否正确？ - DarkZero的回答 - 知乎</a> ]</p><blockquote><p><strong>封装：</strong>封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项，或者叫接口，同时实现了信息隐藏。</p><p><strong>继承：</strong>其一、类间继承可以实现代码复用（单继承、多重继承（虚基类））；其二、表明兼容性，即派生类与基类的接口完全兼容（抽象基类ABC，规范接口但无需实现）。</p><p><strong>多态：</strong> 基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑表现为多种状态（子类型多态）。</p><p><strong>广义上的多态如下：</strong></p><ol type="1"><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></blockquote><hr /></li><li><p>泛型编程</p><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。泛型编程的好处是在算法与参数类型无关的情况下，可以避免重复的代码（参数多态）。在C++中的体现时函数模板和类模板，并且C++中提供了更加完备的标准模板库STL。</p><hr /></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图神经网络论文清单</title>
    <link href="/2021/06/30/2021-06-30-GNN%E8%AE%BA%E6%96%87%E6%B8%85%E5%8D%95/"/>
    <url>/2021/06/30/2021-06-30-GNN%E8%AE%BA%E6%96%87%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="论文清单gnn的分布式加速">论文清单：GNN的分布式加速</h1><hr /><h2 id="gnn的分布式训练">GNN的分布式训练</h2><ol type="1"><li><p>[USENIX ATC 19， <a href="https://xysmlx.github.io/#intro">Linxiao Ma</a>] <strong>Neugraph: Parallel Deep Neural Network Computation on Large Graphs</strong></p><ul><li><p>概述：设计了一个支持muti-GPUs的分布式GNN训练框架，提出SAGA-NN的抽象模型，对于符合SAGA-NN的GNN都可以得到支持。</p></li><li><p>核心技术：图转换引擎（图划分，chunk粒度，类似缩点），流调度器（edge/vertex chunk的调度策略，overlap），图传播引擎（自己优化的kernel，减少数据移动的策略，可惜不开源），基于dataflow的运行时</p></li><li><p>总结：具有较为完整的系统设计，考虑到了GNN训练中的关键问题，并且具有较为完备的实验评估与分析。其划分图，SAGA-NN的抽象模型值得学习。但是无可供参考的开源代码，图划分的细节没有给出（3.2举例 Kernighan-Lin算法），vertex chunk的内部的传播计算如何实现（sub-chunk?），chain-based的调度方法首次看到（可能以前没发现），并且实验结果的准确性有待商榷。实验部分有关于多GPU加速效果的实验，结果可以参考一下。</p></li></ul></li><li><p>[IPDPS 20] <strong>PCGCN: Partition-Centric Processing for Accelerating Graph Convolutional Network</strong></p><ul><li><p>概述：这是NeuGraph的“小弟”，投到CCF B类会议。论文的总体内容与NeuGraph相近，但是在System Design的一些细节表述上存在区别。本文的实验重点落在单GPU上加速GCN单一类型。（是否是一条思路）</p></li><li><p>优点：系统的设计还是比较完整的，针对GCN在<strong>单GPU</strong>上的性能进行优化，亮点在于实验部分涵盖了文中提及的技术要点。特别是对于数据集的特征的研究，是其它论文所欠缺的。此外，对于GCN网络的hidden size以及层数对执行性能的影响分别做了实验。</p></li><li><p>结论：相比较于NeuGraph，这一篇的重点在于dual-mode的执行模式，简言之，就是依据稀疏程度来选择使用CSR的压缩方式还是邻接矩阵的形式存储图。</p></li></ul></li><li><p>[ IEEE Computer Architecture Letters 20] <strong>Characterizing and Understanding GCNs on GPU</strong></p><ul><li><p>概述：分析GCN类负载在GPU上的特征，给出了一些软件优化和硬件设计的思路。</p></li><li><p>要点</p><p>GCN的两个执行模式Aggregation与Combination，两者的执行先后顺序会影响执行性能。</p><p>与传统graph processing和神经网络的区别：更长且多变的feature length；NN的参数由所有结点共享；交替执行的训练模式。</p></li><li><p>结论：软件设计要提高"高度"结点的重复利用率；原子操作向量化（GPU的访存与计算特性）；基于数据流的优化。</p></li></ul></li><li><p>[HPCA 20] <strong>HyGCN: A GCN accelerator with hybrid architecture</strong></p></li><li><p>[ICCAD 20] <strong>fuseGNN : Accelerating Graph Convolutional Neural Network Training on GPGPU</strong></p></li><li><p>[SoCC20, <a href="http://staff.ustc.edu.cn/~chengli7/#pub">Cheng Li</a>] <strong>PaGraph: Scaling GNN Training on Large Graphs via Computation-aware Caching</strong></p></li><li><p>[MICRO 20] <strong>AWB-GCN: A Graph Convolutional Network Accelerator with Runtime Workload Rebalancing</strong></p></li></ol><p><b><font color=darkcyan>这块需要补充几篇论文</font></b></p><ol start="8" type="1"><li><p>[MLSys21 - <a href="https://gnnsys.github.io/">GNNSys</a>, ] <strong>Analyzing the Performance of Graph Neural Networks with Pipe Parallelism</strong></p><p><a href="https://gnnsys.github.io/papers/GNNSys21_paper_12.pdf">paper</a></p><p>我去。。原来还能这样玩~去年两级流水做出来慢了25%左右，然后就没关注。没想到有人用GPipe的思路也试了一下，结论是慢了，最终发了个Workshop，可以follow一下。</p></li></ol><h3 id="arxiv">ArXiv</h3><ol type="1"><li><p>[] DistGNN: Scalable Distributed Training for Large-Scale Graph Neural Networks</p><p><a href="https://arxiv.org/pdf/2104.06700.pdf">paper</a></p></li></ol><hr /><h2 id="图神经网络采样算法概述">图神经网络采样算法概述</h2><p>NeuGraph中详细介绍了GNN的计算模式，其中一个关键步骤是邻居结点特征的聚合。由于大图中邻居结点数量众多，聚合过程所需占用的资源可能超过单机所能提供的最大值。一种解决方案是划分大图并采用分布式的训练方式，这种方式维持了原有GNN的算法形式，且可以保证收敛性与准确性；另一中解决方案则从算法层面做出改进，对邻居结点进行采样来降低邻居数目，从而减少计算和内存资源占用。</p><p>邻居采样算法（Neighbor Sampling Algorithm, 下文简称NS）从采样的层次来看可以分为三类：</p><ol type="1"><li>Node-level</li><li>Layer-level</li><li>subgraph-level</li></ol><p>下面提到的NS算法都是基于GCN进行设计的，所以对<strong>其它类型GNN的支持</strong>（通用性）是否可以算一个贡献呢。（ 最近涌现很多关于GNN的新文章，感觉这是个趋势，可以考虑Versatility of Our Future Programming Model）</p><p><img src="Snipaste_2021-04-28_20-15-10.png" /></p><hr /><h3 id="采样算法">采样算法</h3><ol type="1"><li><p>[NIPS 17 , <a href="https://williamleif.github.io/#panel3">William L. Hamilton</a>] <strong>Inductive Representation Learning in Large Attributed Graphs</strong> (GraphSAGE)</p><p>不同于transductive的学习方式，本文提出了基于“节点-邻居”信息聚合的Inductive学习方法：任意一点 <span class="math inline">\(v_i\)</span>，对其邻居采样（<span class="math inline">\(k\)</span> 跳采样数为 <span class="math inline">\(n_k\)</span>）；从第 <span class="math inline">\((k-1)\)</span> 跳开始聚合信息，聚合函数为 <span class="math inline">\(aggr_k\)</span>，直到点 <span class="math inline">\(v_i\)</span> 拥有所有邻居信息，生成的嵌入为 <span class="math inline">\(E_i\)</span>；将生成的嵌入作为MLP的输入，进行节点标签分类。</p><p>文中定义的聚合函数有三种：Mean Aggregator，LSTM Aggregator，Pooling Aggregator。（还有一个归纳聚合，与Mean的区别在于，目标节点的特征也会一起求平均，而非拼接）</p><p>PS：支持无监督和有监督的学习，需要使用不同的损失函数。</p><ul><li>无监督学习希望目标节点的特征与邻居相似，得到的嵌入可以供下游任务使用。</li><li>有监督学习，结合具体任务设置损失函数，比如节点分类，可以使用交叉熵。</li></ul><p>实验部分和Random Walk、GCN等方法进行对比，且给出了不同聚合函数的表现。</p><p><a href="https://github.com/williamleif/GraphSAGE">代码链接</a></p></li><li><p>[ICML 18, <a href="http://ml.cs.tsinghua.edu.cn/~jianfei/">Jianfei Chen</a>] <strong>Stochastic Training of Graph Convolutional Networks with Variance Reduction</strong> (VR-GCN) 数学</p><p>GCN的计算模式需要聚合所有邻居结点的信息，在此之前的方法的主要贡献是降低采样数量，并提升在“深”层网络中的训练效果。但是，诸如GraphSAGE的采样方法并没有理论证明保障收敛性，并且（<span class="math inline">\(D^1 \times D^2 = 250\)</span>） 的采样数量还是过大。所以，本文的亮点（亦部分reviewer是槽点）是大段理论证明：证明能收敛。</p><p>实验选取了六个数据集，结果显示本文的方法能够减小NS在相同感受野的梯度的bias和variance（GraphSAGE是存在bias的，这个可以理解为用mini-batch来估计full-batch的梯度）。特别的，仅采样<span class="math inline">\(D^l=2\)</span>的邻居，其算法可获得与精确（Exact）算法一样 <u><b>预测</b></u> 精度。</p><p><a href="https://github.com/thu-ml/stochastic_gcn">代码链接</a></p></li><li><p>[ICLR 18, <a href="https://jiechenjiechen.github.io/">Jie Chen</a>] <strong>FastGCN: Fast Learning with Graph Convolutional Networks via Importance Sampling</strong></p></li><li><p>[SIGKDD 18, <a href="https://faculty.sites.iastate.edu/hygao/">Hongyang Gao</a>] <strong>Large-Scale Learnable Graph Convolutional Networks</strong></p><p><span class="math inline">\(LGCN_{sub}\)</span>结构融合了邻居节点的特征采样以及图像上的卷积运算，感觉并这种结构不适用于大规模的图以及特征较长的图（实验中用的是三个小图）。</p><p>也是基于采样的学习方式，支持<strong>Transductive和Inductive Learning</strong>：</p><ul><li>对于一张完整的图，LGCN会<strong>采样</strong>出若干张子图作为一个batch，以此解决大图上的训练问题，降低计算和内存开销。</li><li>依据特征各个维度排序大小关系，仅选取 <span class="math inline">\(k\)</span> 个最大的特征构建为grid-like的输入（CNN中的image），然后利用<strong>1-D卷积</strong>提取特征。</li><li>LGCN的设计还使用了类似DenseNet的连接结构，这点在深层网络中有好的效果。（DeepGCN用的ResNet形式的结构解决多层GCN层叠加后训练效果下降的问题）</li></ul><p>实验部分的表述方式值得学习，但是所用数据集都比较小，方法在大数据集上的表现有待验证。</p><p><a href="https://github.com/divelab/lgcn">代码链接</a> <a href="https://blog.csdn.net/yyl424525/article/details/100057863">博客</a></p></li><li><p>[SIGKDD 19, <a href="https://infwinston.github.io/">Wei-Lin Chiang</a>, <a href="https://xuanqing94.github.io/">Xuanqing Liu</a>] <strong>Cluster-GCN: An Efficient Algorithm for Training Deep and Large Graph Convolutional Networks</strong></p><p>这篇的想法和之前讨论的求SCC的很相似，应用图聚类算法得到若干个点的聚簇（子图），目的是让聚簇中的边尽量的多，让聚簇间的边尽量少（SCC也可以有这种功效）。而且实验部分表述很详细，实验的设施可以学习，有必要复现以下。</p><p>划分图的方式：Metis聚类得到 <span class="math inline">\(p\)</span> 个独立子图，子图间的边暂时忽略（应该是 <span class="math inline">\(p\)</span> 等分）</p><p>问题：依赖于cluster的结果、去掉了一些边所以需考虑收敛性。</p><p>训练：每个batch <span class="math inline">\(B\)</span> 都会随机选取 <span class="math inline">\(c\)</span> 个子图参与训练，此时子图间被去除的边需要再连接起来，同样的，特征和标签也需要对应重新编号和分割。</p><p>深层次的网络：不同于大多数人选择的类似ResNet中“short-cut”的方法，Cluster-GCN使用“diagonal enhancement”来解决深层网络训练问题。</p><p>内存开销：相比VRGCN和GraphSAGE，内存占用有显著下降。（和GraphSAGE类似，可以只保存当前batch的中间数据用于计算梯度--这玩意儿可以用冲计算嘛？是个可以探究以下的点，目前没有看到有人把DNN分布式训练的一些技巧用于GNN）</p><p>求出SCC之后需要解决的问题有三个：SCC的大小不一致；去掉一些边之后可能对训练精度有影响；SCC分割之后标签的分布可能出现偏斜。<font color="#4169E1">(需要确认一下这种标签分布的不平衡是不是FL中数据non-iid这么一回事儿，如果是的话可以尝试把一些解决方法拿来用：比如分成300个cluster然后分别训练，或者共享一部分数据训练)</font></p><p><a href="https://www.youtube.com/watch?v=5gUkNOEIy5k">视频</a> Github <a href="https://github.com/benedekrozemberczki/ClusterGCN">[1-pt]</a> <a href="https://github.com/NIRVANALAN/ClusterGCN_google-reseach">[2-tf]</a> <a href="https://github.com/yiyang-wang/Cluster-GCN">[3-3090]</a></p></li><li><p>[ICLR 20, ] <strong>GraphSAINT: Graph Sampling Based Inductive Learning Method</strong></p><p><a href="https://github.com/GraphSAINT/GraphSAINT">代码链接</a></p><p>[IPDPS 19, ] <strong>Accurate, Efficient and Scalable Graph Embedding</strong></p><p><a href="https://github.com/ZimpleX/gcn-ipdps19">代码链接</a></p><p>这篇工作既有理论又有系统，很棒。</p><p>本文核心为子图采样，在全图上采样出多个子图，然后在子图上训练一个完整的GCN。与前面采样方法的区别在于，采样是在图这一层次的，而非对边或点的采样，所以对于子图来说，局部连接是几乎（完整）保留的。</p><p>对于相较原图损失的边，作者设计了无偏的采样方法并且降低方差（variance reduction），也有人质疑子图采样的有效性以及无偏相关理论的推导。这一点也是本文中比较难的。</p><p>从实际实验复现的效果来说，超出预期的好。</p></li><li><p>采样算法的偏差 <a href="https://paperswithcode.com/paper/minimal-variance-sampling-with-provable/review/">paper</a></p></li></ol><hr /><h2 id="mixed-nn-training">Mixed NN Training</h2><ol type="1"><li>Sun J, Zhang J, Li Q, et al. Predicting citywide crowd flows in irregular regions using multi-view graph convolutional networks[J]. IEEE Transactions on Knowledge and Data Engineering, 2020.</li><li>Arindam Paul, Dipendra Jha, Reda Al-Bahrani, Wei-keng Liao, Alok Choudhary, and Ankit Agrawal. CheMixNet: Mixed DNN Architectures for Predicting Chemical Properties using Multiple Molecular Representations. In <em>NeurIPS Workshop on Machine Learning for Molecules and Materials</em>, December 2018.</li></ol><hr /><h2 id="federated-graph-learning">Federated Graph Learning</h2><h3 id="概述">概述</h3><p>目前收集了2019年以来和FGL（Fedrated Graph Learning）相关的论文。其中[1.]指出联邦环境下的图学习任务可分为四类：</p><ul><li><p>Graph Level，即对每一张完整的全图进行分类（这一类与联邦环境下的CV任务相似，目前见得最多的就是该类应用，例如，药物分子分类）</p></li><li><p>Sub-graph Level，由于数据间保密的需要，不同部门之间的KG被分为多个子图（有点牵强）</p></li><li><p>Node Level，比如分类任务接下游推荐任务，针对结点（例如，物品或用户）的嵌入，目前还看到了关于交通流的预测任务[25.]</p></li><li><p>Link Level，尚不明朗</p></li></ul><p>难点：不同场景的数据集怎么搞，选哪个场景；故事怎么讲。</p><h3 id="federated-learning-on-graphs">Federated Learning on Graphs</h3><ol type="1"><li><p>[ICLR'2021 - DPML &amp; MLSys'21 - GNNSys, ] <strong>FedGraphNN: A Federated Learning System and Benchmark for Graph Neural Networks</strong></p><p>从训练机制上来说，未见明显创新与亮点，只是讲GNN和FL结合，使用的还是FedAvg。</p><p>文中提到暂时只是实现了Graph Level的训练任务，其它三种在计划中。</p><p><a href="https://github.com/FedML-AI/FedGraphNN">代码</a></p></li><li><p>[NeurIPS20, <a href="https://chaoyanghe.com/publications/">Chaoyang He</a>] <strong>FedML: A Research Library and Benchmark for Federated Machine Learning</strong></p></li><li><p>[non-iid, 浙大 吴飞] <strong>Federated Graph Learning - A Position Paper</strong></p><p><a href="https://arxiv.org/pdf/2105.11099.pdf">arxiv</a></p><p>相当于给FGL的概念一个定位，且将FGL分为四个类型：</p><ul><li>Inter-graph，类似Graph Level，是FL向FGL过渡的最自然形态。</li><li>Intra-graph，每个终端拥有一张完整的图的一部分（子图，但严格来讲可以又重叠的部分，也就是不同终端间子图存在部分相同的点和边）。<ul><li>horuzontal intra-graph 图是水平分割的（在同一张图中，割开部分边）。</li><li>Vertical intra-graph 图是垂直分割的 （多张图，部分结点存在跨图的连接关系，即Vertical Connection，例如第一层为KG，第二层为Socail Graph，第三层位Financial Graph）</li></ul></li><li>Graph-structured，即clients之间的连接可以视作一种关系</li></ul><p>文中提及的挑战：</p><ul><li>non-iid, communicaiton efficiency, memory consumption and robustness</li></ul></li><li><p>[non-iid, arxiv, <a href="https://www.cse.msu.edu/~wangy206/publications.html">Yiqi Wang</a>] <strong>Non-IID Graph Neural Networks</strong></p><p><a href="https://arxiv.org/abs/2005.12386">arxiv</a> <b><font color=darkcyan>已经投出去了，关注一下</font></b></p><p>解决的问题：在non-iid的图数据集训练Graph-level分类模型。</p><p>主要有三个挑战：不同图的分布不知、单独训练每个分布的模型可能导致部分分布下的可训练数据稀少、测试阶段多模型选择问题</p><p>提出的方法：基于adaptor network，利用图结构信息来估计分布；为每一个图训练一个联合模型。</p></li><li><p>[ICML'21, <a href="https://www.cse.msu.edu/~wangy206/publications.html">Yiqi Wang</a> <a href="https://www.cse.msu.edu/~tangjili/">Jiliang Tan</a>] <strong>Elastic Graph Neural Networks</strong></p><p>汤继良等人的书《图深度学习》有中文版</p></li><li><p>[imbalance, IJCAI'20 ] <strong>Multi-Class Imbalanced Graph Convolutional Network Learning</strong></p><p>在真实（图）数据集中，类别分布存在多数与少数，这种多类别样本不均衡现象会导致训练出的模型向多数一方倾斜：点-点之间拓扑联系、不清晰的类别界限（多数一方在特征传播过程中会占据主导地位）</p></li><li><p>[NeurIPS Workshop 2019] <strong>Towards Federated Graph Learning for Collaborative Financial Crimes Detection.</strong></p><p><a href="https://arxiv.org/pdf/1909.12946">paper</a></p></li><li><p>[Arxiv 2021] <strong>A Graph Federated Architecture with Privacy Preserving Learning.</strong></p><p><a href="https://arxiv.org/pdf/2104.13215">paper</a></p></li><li><p>[Arxiv 2020] <strong>Federated Dynamic GNN with Secure Aggregation.</strong> <a href="https://arxiv.org/pdf/2009.07351">paper</a></p></li><li><p>[Arxiv 2020] <strong>Privacy-Preserving Graph Neural Network for Node Classification.</strong> <a href="https://arxiv.org/pdf/2005.11903">paper</a></p></li><li><p>[SIGKDD21, <a href="http://wangbinghui.net/">Binghui (Alan) Wang</a>] <strong>Privacy-Preserving Representation Learning on Graphs: A Mutual Information Perspective</strong></p></li><li><p>[Arxiv 2020] <strong>ASFGNN: Automated Separated-Federated Graph Neural Network.</strong></p><p><a href="https://arxiv.org/pdf/2011.03248">paper</a></p></li><li><p>[Arxiv 2020, <a href="http://wangbinghui.net/">Binghui (Alan) Wang</a>] <strong>GraphFL: A Federated Learning Framework for Semi-Supervised Node Classification on Graphs.</strong></p><p><a href="https://arxiv.org/pdf/2012.04187">paper</a></p><p>两个挑战：1）FL在non-iid数据上表现不佳，而Graph是non-iid的；2）FL过去侧重于训练同label-domain的数据，但是图数据是会增长的。3）现有FL解决的是有监督学习，不能利用无标签的数据。</p><p>解决方法：1）使用MAML+FL的方式，数据不要求为iid：先使用MAML训练一个global-model解决non-iid的Graph数据问题，然后利用现有FL方法优化global-model；2）重新制定MAML并设计新的objective function；3）self-training模型，即利用训练的本地模型来预测无标签的数据，选取the most confident predictions作为标签，把这些数据加入到训练集中去。</p><p>实验采用的两个模型GCN和SGC<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Simplifying graph convolutional networks. ICML. 2019.">[1]</span></a></sup>还是没有足够的说服力，我觉得可以<strong>试试采样方法或者GAT</strong>等模型。数据集cora、citeseer、Coauthor CS、Amazon2M。</p><p>可学习的部分：GCN的self-training，MAML处理non-iid</p><blockquote><p>all clients have the complete graph.”这一块简直不是联邦学习。</p><p>PS：在大数据集上也遇到问题，使用基于采样的GCN变体ClusterGCN。</p></blockquote><p>MAML非官方参考代码 <a href="https://github.com/dragen1860/MAML-Pytorch">[1]</a> <a href="https://github.com/cbfinn/maml">[2]</a></p></li></ol><p>​</p><ol start="15" type="1"><li><p>[Arxiv 2021, <a href="https://wuch15.github.io/">Chuhan Wu</a> , Xin Xie] <strong>FedGNN: Federated Graph Neural Network for Privacy-Preserving Recommendation.</strong></p><p><a href="https://arxiv.org/pdf/2102.04925">paper</a></p></li><li><p>[Arxiv 2021] <strong>FL-AGCNS: Federated Learning Framework for Automatic Graph Convolutional Network Search.</strong></p><p><a href="https://arxiv.org/pdf/2104.04141">paper</a></p></li><li><p>[Arxiv 2021] <strong>Cluster-driven Graph Federated Learning over Multiple Domains.</strong></p><p><a href="https://arxiv.org/pdf/2104.14628">paper</a></p></li><li><p>[Arxiv 2021] <strong>FedGL: Federated Graph Learning Framework with Global Self-Supervision.</strong></p><p><a href="https://arxiv.org/pdf/2105.03170">paper</a></p></li><li><p>[Arxiv 2021] <strong>Federated Graph Learning -- A Position Paper.</strong></p><p><a href="https://arxiv.org/pdf/2105.11099">paper</a></p></li><li><p>[Arxiv 2020] <strong>FedE: Embedding Knowledge Graphs in Federated Setting.</strong></p><p><a href="https://arxiv.org/pdf/2010.12882">paper</a> <a href="https://github.com/AnselCmy/FedE">GitHub</a></p></li><li><p>[Arxiv 2021] <strong>Federated Knowledge Graphs Embedding.</strong></p><p><a href="https://arxiv.org/pdf/2105.07615">paper</a></p></li><li><p>[IEEE Big Data 2019] <strong>A Graph Neural Network Based Federated Learning Approach by Hiding Structure.</strong></p><p><a href="https://www.researchgate.net/profile/Shijun_Liu3/publication/339482514_SGNN_A_Graph_Neural_Network_Based_Federated_Learning_Approach_by_Hiding_Structure/links/5f48365d458515a88b790595/SGNN-A-Graph-Neural-Network-Based-Federated-Learning-Approach-by-Hiding-Structure.pdf">paper</a></p></li><li><p>[Arxiv 2020] <strong>Locally Private Graph Neural Networks.</strong></p><p><a href="https://arxiv.org/pdf/2006.05535">paper</a></p></li><li><p>[Arxiv 2020, <a href="https://woaiwodib107.github.io/">Dongming Han</a>] <strong>GraphFederator: Federated Visual Analysis for Multi-party Graphs</strong></p><p><a href="https://arxiv.org/abs/2008.11989">paper</a></p></li><li><p>[ICLR21被拒, ] CNFGNN <strong>Cross-Node Federated Graph Neural Network for Spatio-Temporal Data Modeling</strong> <a href="https://openreview.net/forum?id=HWX5j6Bv_ih">paper</a> <a href="https://openreview.net/attachment?id=HWX5j6Bv_ih&amp;name=supplementary_material">Code</a></p></li><li><p>[Arxiv 2019] Peer-to-peer federated learning on graphs.</p><p><a href="https://arxiv.org/pdf/1901.11173">paper</a> 这篇不是很相关</p></li></ol><h3 id="long-tail-graph">Long-tail Graph</h3><p><a href="https://zhuanlan.zhihu.com/p/365686784">zhihu-papers</a></p><p><a href="https://zhuanlan.zhihu.com/p/361416969">小样本学习与图神经网络</a></p><hr /><h2 id="深度gnn">深度GNN</h2><ol type="1"><li><p>[KDD20, <a href="https://mengliu1998.github.io/index.html#publications">Liu Meng</a>] <strong>Towards Deeper Graph Neural Networks</strong></p><p><a href="https://github.com/mengliu1998/DeeperGNN">Github</a></p></li></ol><hr /><h2 id="非消息传递">非消息传递</h2><ol type="1"><li>[UESTC 电子科大 Yi Luo，<a href="https://cf020031308.github.io/papers/">有意思</a>]<strong>Distilling Self-Knowledge From Contrastive Links to Classify Graph Nodes Without Passing Messages</strong></li></ol><hr /><h2 id="transformer">Transformer</h2><ol type="1"><li><p>[ICML 21] <strong>PipeTransformer: Automated Elastic Pipelining for Distributed Training of Transformers</strong></p><p><a href="https://arxiv.org/pdf/2102.03161.pdf">paper</a></p></li><li><p>[NeurIPS19] <strong>Graph Transformer Networks</strong></p><p><a href="https://papers.nips.cc/paper/2019/file/9d63484abb477c97640154d40595a3bb-Paper.pdf">paper</a></p></li><li><p><a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">Transformers are GNNs</a></p></li></ol><hr /><h2 id="其他会议">其他会议</h2><p><a href="https://openreview.net/pdf?id=4zr9e5xwZ9Y">DISTRIBUTED TRAINING OF GRAPH CONVOLUTIONAL NETWORKS USING SUBGRAPH APPROXIMATION</a> submit to ICLR21 (reject)</p><p>[KDD 20] Policy-GNN: Aggregation Optimization for Graph Neural Networks</p><p>Scalable Graph Neural Network Training: The Case for Sampling</p><p><a href="https://arxiv.org/abs/2104.10569">GraphTheta: A Distributed Graph Neural Network Learning System With Flexible Training Strategy</a> <a href="https://yongchao-liu.github.io/index.html">Yongchao Liu</a> submitted to VLDB 2022</p><h3 id="mlsys21---gnnsys21-workshop">MLSys21 - GNNSys21 Workshop</h3><p>https://gnnsys.github.io/</p><h3 id="eurosys21上关于gnn的研究">EuroSys21上关于GNN的研究</h3><ol type="1"><li><p>[EuroSys 21, ] Accelerating Graph Sampling for Graph Machine Learning using GPUs</p><p>这篇有点意思，特别优化采样算法在GPU上的并行。</p><p>代码链接 <a href="https://github.com/plasma-umass/NextDoor">[1]</a> <a href="https://github.com/abhijangda/nextdoor-experiments/">[2]</a></p></li><li><p>[EuroSys 21, ] DGCL: An Efficient Communication Library for Distributed GNN Training</p><p>代码链接 <a href="https://github.com/czkkkkkk/gccl">[1]</a> <a href="https://github.com/czkkkkkk/ragdoll">[2]</a></p></li><li><p>[EuroSys 21, ] Seastar: Vertex-Centric Programming for Graph Neural Networks</p><p><a href="https://github.com/ydwu4/seastar-paper-version">代码链接</a></p></li><li><p>[EuroSys 21, ] FlexGraph: A flexible and efficient distributed framework for GNN training</p></li></ol><h3 id="iwqos21">IWQoS21</h3><ol type="1"><li>[] <strong>Drag-JDEC: A Deep Reinforcement Learning and Graph Neural Network-based Job Dispatching Model in Edge Computing</strong></li><li>[<a href="http://ci.hfut.edu.cn/2020/1208/c11504a245599/page.htm">Yu Gu</a>] <strong>Glint: Decentralized Federated Graph Learning with Traffic Throttling and Flow Scheduling</strong></li></ol><h4 id="kdd21">KDD21</h4><ol type="1"><li>[] <strong>Global Neighbor Sampling for Mixed CPU-GPU Training on Giant Graphs</strong></li><li>[] <strong>Performance-Adaptive Sampling Strategy Towards Fast and Accurate Graph Neural Networks</strong></li><li>[] <strong>Scaling Up Graph Neural Networks Via Graph Coarsening</strong></li><li>[] <strong>mGAGN:Imbalanced Network Embedding via Generative Adversarial Graph Networks</strong></li><li>[] <strong>Learning How to Propagate Messages in Graph Neural Networks</strong></li><li>[] <strong>Multi-graph Multi-label Learning with Dual-granularity Labeling</strong></li><li>[] <strong>NRGNN: Learning a Label Noise Resistant Graph Neural Network on Sparsely and Noisily Labeled Graphs</strong></li><li>[] <strong>Pre-training on Large-Scale Heterogeneous Graph</strong></li><li>[] <strong>Representation Learning on Knowledge Graphs for Node Importance Estimation</strong></li><li>[] <strong>Tail-GNN: Tail-Node Graph Neural Networks</strong></li></ol><hr /><h2 id="相关学者">相关学者</h2><p>清华大学 刘知远</p><p>中科大 唐建 李诚</p><p>USC</p><p>密歇根 汤继良</p><p>北邮 石川</p><p>IBM(东京大学毕业) 马腾飞</p><hr /><h2 id="参考资料">参考资料</h2><p><strong>End to End learning</strong> in the context of AI and ML is a technique where the model learns all the steps between the initial input phase and the final output result. This is a deep learning process where all of the different parts are simultaneously trained instead of sequentially.</p><h3 id="federated-learning-survey">Federated Learning: Survey</h3><ol type="1"><li>[IEEE Signal Processing Magazine 2019] <strong>Federated Learning：Challenges, Methods, and Future Directions.</strong> <a href="https://arxiv.org/pdf/1908.07873">paper</a></li><li>[ACM TIST 2019] <strong>Federated Machine Learning Concept and Applications.</strong> <a href="https://arxiv.org/pdf/1902.04885">paper</a></li><li>[IEEE Communications Surveys &amp; Tutorials 2020] <strong>Federated Learning in Mobile Edge Networks A Comprehensive Survey.</strong> <a href="https://arxiv.org/pdf/1909.11875">paper</a></li></ol><p><b><font color=darkcyan>这块需要补充几篇论文</font></b></p><h3 id="gnn-survey">GNN: Survey</h3><ol type="1"><li>[IEEE TNNLS 2020] <strong>A Comprehensive Survey on Graph Neural Networks.</strong> <a href="https://arxiv.org/pdf/1901.00596">paper</a></li><li>[Arxiv 2018] <strong>Graph Neural Networks-A Review of Methods and Applications.</strong> <a href="https://arxiv.org/abs/1812.08434">paper</a></li><li>[IEEE TKDE 2020] <strong>Deep Learning on Graphs-A Survey.</strong> <a href="https://arxiv.org/pdf/1812.04202.pdf%E3%80%82">paper</a></li><li>[Arxiv 2017] <strong>Representation learning on graphs - Methods and applications.</strong> <a href="https://arxiv.org/pdf/1709.05584">paper</a></li><li>[软件学报, 张岩峰] <strong>大规模图神经网络系统综述</strong></li></ol><p><b><font color=darkcyan>这块需要补充几篇论文</font></b></p><h3 id="mathematics">Mathematics</h3><p>矩阵<a href="https://zhuanlan.zhihu.com/p/30485749">范数</a></p><p>Pytorch多标签分类任务</p><p><a href="https://zh.wikipedia.org/wiki/F-score">F-measure</a> <a href="https://zjmmf.com/2019/08/13/F1-Score%E8%AE%A1%E7%AE%97/">解释</a></p><p><a href="https://towardsdatascience.com/over-smoothing-issue-in-graph-neural-network-bddc8fbc2472">over-smoothing in GNN</a></p><h3 id="miscellaneous-and-tools">Miscellaneous and Tools</h3><p>图的聚类或分割算法：<strong>Metis，LK，Graclus</strong></p><p><a href="http://adl.stanford.edu/cme342/Home.html">CME342</a> <strong>Parallel Methods in Numerical Analysis</strong></p><p><a href="http://yifanhu.net/PROJECT/pdcp_siam/">PDCP_SIAM</a> <strong>Load Balancing for Unstructured Mesh Applications</strong></p><p><a href="https://paperswithcode.com/paper/graph-attention-networks">性能排行榜网站 Paperswithcode</a></p><p><a href="https://becominghuman.ai/7-open-source-libraries-for-deep-learning-graphs-7ae294f249d4">框架汇总</a></p><p><a href="https://github.com/dglai/WWW20-Hands-on-Tutorial">DGL</a> <a href="https://docs.dgl.ai/">官方教程</a> <a href="https://www.youtube.com/watch?v=r5aLtP_Ger0">ACM-Hands-on-Part1</a> <a href="https://www.youtube.com/watch?v=Nd2BbbviOdk">ACM-Hands-on-Part2</a> （DMLC）</p><p><a href="https://antoniolonga.github.io/Pytorch_geometric_tutorials/index.html">Pytorch Geometric Tutorial</a> <a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/introduction.html#data-handling-of-graphs">Pytorch Geometric Doc</a> <a href="https://rusty1s.github.io/#/">PyG主要贡献者MATTHIAS FEY</a></p><p><a href="https://graphneural.network/">Spektral</a> （TF+Keras）</p><p><a href="https://pgl.readthedocs.io/en/latest/index.html">Paddle Graph Learning (PGL)</a></p><p><a href="https://www.cs.mcgill.ca/~ksinha4/practices_for_reproducibility/">ML Reproducibility Tools and Best Practices</a></p><ul><li><p>数据集集合</p><p><a href="https://dango.rocks/datasets/">Yishi Lin</a></p></li></ul><table><thead><tr class="header"><th style="text-align: center;">项目名称</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><a href="https://augf.github.io/">PASA</a></td></tr><tr class="even"><td style="text-align: center;"><a href="https://github.com/IsuruMaduranga/federated-gcn">Fedrated GCN</a></td></tr><tr class="odd"><td style="text-align: center;"><a href="https://blog.csdn.net/yyl424525/article/details/100058264">GCN的理解</a></td></tr><tr class="even"><td style="text-align: center;"><a href="https://blog.csdn.net/yyl424525/article/details/100920134">GAT</a></td></tr><tr class="odd"><td style="text-align: center;"><a href="http://people.cs.pitt.edu/~hasanzadeh/pages/research.html">一个有趣的人的工作</a></td></tr><tr class="even"><td style="text-align: center;"><a href="https://cloud-atlas.readthedocs.io/zh_CN/latest/index.html">云计算学习Cloud Atlas</a></td></tr><tr class="odd"><td style="text-align: center;"><a href="https://cf020031308.github.io/papers/">GNN论文笔记</a></td></tr></tbody></table><hr /><center><font color='#FF0000'>彩虹</font> <font color='#FF7D00'>彩虹</font> <font color='#FFFF00'>彩虹</font> <font color='#00FF00'>彩虹</font> <font color='#0000FF'>彩虹</font> <font color='#00FFFF'>彩虹</font> <font color='#FF00FF'>彩虹</font></center><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Simplifying graph convolutional networks. ICML. 2019. <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>金总的算法课</title>
    <link href="/2020/11/19/%E9%87%91%E6%80%BB%E7%9A%84%E7%AE%97%E6%B3%95%E8%AF%BE/"/>
    <url>/2020/11/19/%E9%87%91%E6%80%BB%E7%9A%84%E7%AE%97%E6%B3%95%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="算法课笔记">算法课笔记</h2><h3 id="月14日-lead-in">9月14日 Lead-in</h3><p>本课程主要内容：分支、动态规划、贪心、随机算法、近似算法、NP-完全性理论</p><blockquote><p><strong>课堂习题</strong></p><p>LeetCode 440题目描述：给定整数 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span>，找到 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 中字典序第 <span class="math inline">\(k\)</span> 小的数字。</p><p>注意：<span class="math inline">\(1 \leq k \leq n \leq 10^9\)</span> 。</p></blockquote><blockquote><p><strong>解题思路</strong></p><p>如图，字典序构成了一棵十叉树，该树的每一层代表具体某一位置的数字（如，个十百千万）。比如根节点代表最高位的数字，子树的根节点代表低一位的数字，直到叶子节点表示个位的数字。如此，构造出的树的高度（根节点高度为0）应为（ <span class="math inline">\(\lfloor lg(n+1) \rfloor + 1\)</span>）。<font color = "#FF0000">!这里高度还存在一点问题，准确说是9棵十叉树</font></p><p>但是由于 <span class="math inline">\(n\)</span> 大小的限制，构成的并不是一个满十叉树。比如示例中 <span class="math inline">\(1\)</span> 只有 <span class="math inline">\([10,11,12,13]\)</span> 四个孩子。</p><p>该问题转化为求解区间 <span class="math inline">\([1,n+1)\)</span> 计数的问题，无需构建真实的树。若当前根的数字为 <span class="math inline">\(l\)</span> ，则右侧相邻兄弟结点为 <span class="math inline">\(l+1\)</span> ，计算树结点区间 <span class="math inline">\([l,l+1)\)</span> 的结点个数（ 记作 <span class="math inline">\(cnt\)</span>） ，计数时一层一层向下，需要递归（迭代也行）地计算子树的结点个数。若当前树结点区间的结点个数 <span class="math inline">\(cnt \le k\)</span> ，则说明目标数字不在当前区间，而在右侧区间 <span class="math inline">\([l+1,l+2)、[l+2,l+3)...\)</span> 之一中，则 <span class="math inline">\(k = k-num\)</span> ，对右侧相邻区间计数；若当前区间的结点个数 <span class="math inline">\(cnt &gt; k\)</span> ，则说明目标数字在当前结点区间<span class="math inline">\([l,l+1)\)</span> 内，则应在当前区间的子树下寻找，也就是以 <span class="math inline">\(l\)</span> 为根的子树下寻找。重复上述过程，直至找到目标数字（即 <span class="math inline">\(k=0\)</span> 时的数字）。</p><p>使用游标“指针” <span class="math inline">\(cur\)</span> 存储当前指向的数字，刚开始为 <span class="math inline">\(1\)</span> ，根据下图树的结构，游标在兄弟结点间向右侧区间移动，<span class="math inline">\(cur = cur + 1\)</span> ；若向孩子自己的子树（第一个孩子结点移动，则 <span class="math inline">\(cur = cur \times 10\)</span> 。</p><p><img src="Snipaste_2020-09-14_19-48-31.png" /></p><p><img src="Snipaste_2020-09-14_19-04-50.png" /></p></blockquote><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">int</span> cur = <span class="hljs-number">1</span>;        k -= <span class="hljs-number">1</span>; <span class="hljs-comment">// 减去根节点 1 </span>        <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">// 计算cur(10叉树的一个根节点)到cur + 1之间的数字个数</span>            <span class="hljs-keyword">int</span> cnt = countNode(n,cur,cur+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(k &gt;= cnt)&#123; <span class="hljs-comment">//cur游标在树上同一层向右移动</span>                k -= cnt;                cur += <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                k -= <span class="hljs-number">1</span>; <span class="hljs-comment">// 去除当前根,向下探索子树</span>                cur *=<span class="hljs-number">10</span>; <span class="hljs-comment">// 游标向下移动,孩子节点代表的数值需要乘以10 </span>            &#125;        &#125;        <span class="hljs-keyword">return</span> cur;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> l, <span class="hljs-keyword">long</span> r)</span></span>&#123;        <span class="hljs-comment">//小细节,注意溢出,min函数强制转换一下long</span>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l&lt;=n)&#123;            cnt += min(<span class="hljs-keyword">long</span>(n+<span class="hljs-number">1</span>), r) - l; <span class="hljs-comment">// 计数区间为左闭右开[l,r)</span>            l*=<span class="hljs-number">10</span>;            r*=<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> cnt; <span class="hljs-comment">//返回该结点下的node数</span>    &#125;&#125;;</code></pre><blockquote><p>变式：<font color = "#FF0000">!下次问一下，给忘记了</font></p><p>给定<span class="math inline">\(n\)</span>个不相同的整数<span class="math inline">\(a_1,a_2,...,a_n\)</span>和<span class="math inline">\(k\)</span>，<span class="math inline">\(max\{a_i\} &lt; 10000\)</span>。找到<span class="math inline">\(a_1\)</span>到<span class="math inline">\(a_n\)</span>中字典序第<span class="math inline">\(k\)</span>小的数字。注意：<span class="math inline">\(1 \leq k \leq n\)</span></p><p>提示：桶排序、堆排序、快速搜索、线性时间选择</p></blockquote><hr /><h3 id="月21日-mathematical-basis">9月21日 Mathematical Basis</h3><ul><li><p>评估算法的执行效率：经验（Empirical）与理论（Theoretical）</p></li><li><p>渐进分析符号</p><ol type="1"><li><p>渐近上界记号 $ $</p><p>若存在两个正常数 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(n_0\)</span> ，使得对所有的 <span class="math inline">\(n \geq n_0\)</span> ，都有： <span class="math inline">\(f(n) \le c \times g(n)\)</span> ，则称 <span class="math inline">\(f(n) = \Omicron(g(n))\)</span> 。</p></li><li><p>渐近下界记号 <span class="math inline">\(\Omega\)</span></p><p>若存在两个正常数 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(n_0\)</span> ，使得对所有的 <span class="math inline">\(n \geq n_0\)</span> ，都有： <span class="math inline">\(f(n) \ge c \times g(n)\)</span> ，则称 <span class="math inline">\(f(n) = \Omega(g(n))\)</span> 。</p></li><li><p>紧渐近界记号 <span class="math inline">\(\Theta\)</span></p><p>若存在三个正常数 <span class="math inline">\(c_1\)</span>、<span class="math inline">\(c_2\)</span> 和 <span class="math inline">\(n_0\)</span> ，使得对所有的 <span class="math inline">\(n \geq n_0\)</span> ，都有： <span class="math inline">\(c_1 \times g(n) \ge f(n) \ge c_2 \times g(n)\)</span> ，则称 <span class="math inline">\(f(n) = \Theta(g(n))\)</span> 。</p></li><li><p>非紧上界记号 $ $</p><p><span class="math inline">\(\omicron(g(n))=\{f(n) |C1\}\)</span> ，其中 <span class="math inline">\(C1\)</span> : 对于任何正常数 <span class="math inline">\(c &gt; 0\)</span>，存在正数<span class="math inline">\(n_0 &gt; 0\)</span>使得对所有<span class="math inline">\(n \ge n_0\)</span> 有<span class="math inline">\(0 \le f(n) &lt; c \times g(n)\)</span> 。</p><p>等价于 <span class="math inline">\(\lim_{ n \to \infty}{f(n)/g(n) \to 0}\)</span></p></li><li><p>非紧下界记号 <span class="math inline">\(\omega\)</span></p><p><span class="math inline">\(\omega(g(n))=\{f(n) |C2\}\)</span> ，其中 <span class="math inline">\(C2\)</span> : 对于任何正常数 <span class="math inline">\(c &gt; 0\)</span>，存在正数<span class="math inline">\(n_0 &gt; 0\)</span>使得对所有<span class="math inline">\(n \ge n_0\)</span> 有<span class="math inline">\(0 \le c \times g(n) &lt; f(n)\)</span> 。</p><p>等价于 <span class="math inline">\(\lim_{ n \to \infty}{f(n)/g(n) \to \infty}\)</span></p></li></ol></li><li><p>Master Theorem ★</p><p><img src="Snipaste_2020-09-28_20-57-02.png" /></p><p>主要目的是比较等号右侧的两项函数那个作为“主导”，精简如下。</p><p><span class="math inline">\(\begin{aligned}  \text { If } T(n)=a T\left(\left\lceil\frac{n}{b}\right\rceil\right)+O\left(n^{d}\right) \text { (for constants} \; a&gt;0, b&gt;1, d \geq 0), \text { then: }  \end{aligned}\)</span></p><pre><code>$T(n)=\left\&#123;\begin&#123;array&#125;&#123;ll&#125;</code></pre><p>O(n^{d}) &amp;  d&gt;<em>{b} a \ O(n^{d} n) &amp;  d=</em>{b} a \ O(n^{<em>{b} a}) &amp;  d&lt;</em>{b} a \end{array}.$ . （证明参见：<a href="https://brilliant.org/wiki/master-theorem/">brilliant</a> <a href="https://www.coursera.org/lecture/algorithmic-toolbox/proof-of-the-master-theorem-7KR1r">Coursera</a> ）</p></li><li><p>等待写master定理求解的例子</p></li></ul><h3 id="月28日-devide-and-conquer-algorithm">9月28日 Devide And Conquer Algorithm</h3><p>==10.10课结束补==</p><ul><li><p>分治算法原理</p><p>三步走：Devide-Conquer-Combine</p><p>递归方程：<span class="math inline">\(T(n) = aT(n/b)+D(n)+C(n)\)</span> ，右侧为分治复杂度、问题划分划分复杂度和合并复杂度。</p></li><li><p>二分搜索</p><p>见《算法整理》lower_bound写法。</p></li><li><p>大整数乘法</p><p><span class="math inline">\(n\)</span> 位K进制整数X和Y相乘。</p><p>解决方法：</p><ol type="1"><li>模拟小学乘法：最简单的乘法竖式手算的累加型；</li><li>分治乘法：最简单的是Karatsuba乘法，一般化以后有Toom-Cook乘法；</li><li>快速傅里叶变换FFT：（为了避免精度问题，可以改用快速数论变换FNTT），时间复杂度 <span class="math inline">\(O(N lgN lglgN)\)</span> 。具体可参照<a href="https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm">Schönhage–Strassen algorithm</a>；</li><li>中国剩余定理：把每个数分解到一些互素的模上，然后每个同余方程对应乘起来就行；</li><li>Furer's algorithm：在渐进意义上FNTT还快的算法。不过好像不太实用，本文就不作介绍了。大家可以参考维基百科<a href="https://en.wikipedia.org/wiki/F%C3%BCrer%27s_algorithm">Fürer's algorithm</a>。</li></ol><p>参考<a href="https://blog.csdn.net/u010983881/article/details/77503519">博客</a></p></li><li><p>矩阵乘法</p></li><li><p>求第k小元素问题</p></li><li><p>寻找最近点对</p></li><li><p>FFT - 快速傅里叶变换</p></li><li><p>寻找凸包</p></li></ul><blockquote><p>思考题 1</p><p>LeetCode 240 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">搜索二维矩阵 II</a></p><p>使用二分的方式削减搜索空间，分别对<span class="math inline">\(row\)</span>维度和<span class="math inline">\(colume\)</span>维度进行二分，使用lower_bound的二分写法来求<span class="math inline">\(row\)</span>和<span class="math inline">\(col\)</span>方向上的<span class="math inline">\(target\)</span>下界（第一个大于等于<span class="math inline">\(target\)</span>的数的位置是<span class="math inline">\(l\)</span>）。需要特别判断的是</p></blockquote><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//196 ms  10.6s MB</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix.size()==<span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].size()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> binarySearch(matrix, matrix.size(), <span class="hljs-number">0</span>, target);      &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> target)</span></span>&#123;        <span class="hljs-keyword">int</span> next_row, next_col;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = row;        <span class="hljs-keyword">while</span>(l &lt; r)&#123; <span class="hljs-comment">//[0,r)</span>            <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(matrix[mid][col] &gt;= target)&#123;                r = mid;            &#125;<span class="hljs-keyword">else</span> &#123;                 l = mid + <span class="hljs-number">1</span>;            &#125;        &#125;                <span class="hljs-keyword">if</span>(l &lt; row &amp;&amp; matrix[l][col]==target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//判断row方向的下界数字是否是target</span>        next_row = l; <span class="hljs-comment">// 求lower_bound</span>        <span class="hljs-keyword">if</span>(next_row == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 判断row是否越界，即row方向数组为空</span>        l = col, r = matrix[<span class="hljs-number">0</span>].size();        <span class="hljs-keyword">while</span>(l &lt; r)&#123;            <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(matrix[next_row<span class="hljs-number">-1</span>][mid]&gt;=target)&#123;                r = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                l = mid+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(l == matrix[<span class="hljs-number">0</span>].size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//判断col是否越界,即col方向数组为空</span>        next_col = l;                <span class="hljs-keyword">return</span> binarySearch(matrix, next_row, next_col,target);<span class="hljs-comment">//左下角顶点坐标至右上角顶点</span>    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//从左下角开始，每次删除一行或一列</span></code></pre><blockquote><p>思考题 2</p><p>LeetCode - 4 - <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a> - 官方<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">题解</a></p><p>思路：要实现 <span class="math inline">\(\Omicron(log(m+n))\)</span> 的复杂度，首先考虑二分。中位数的作用是将一组有序样本划分为两个相等长度的部分，所以该问题可以转化为求一个 <span class="math inline">\(m+n\)</span> 长度的数组的第 <span class="math inline">\(k\)</span> 小数（如果下标是0始，则对应下标为 <span class="math inline">\(k-1\)</span> 的数），其中 <span class="math inline">\(k = (m+n+1)/2\)</span> （总数为奇数，下标0始）或者 <span class="math inline">\(k=(m+n)/2,k=(m+n)/2+1\)</span>（总数为偶数，下标0始，取平均）。</p><p>那么神奇的操作来了，此处，我们二分的对象是区间长度 <span class="math inline">\(k\)</span> ，每次从数组 <span class="math inline">\(A\)</span> 和数组 <span class="math inline">\(B\)</span> 中取 <span class="math inline">\(k/2\)</span> 区间长度的数（下标0始，所以取到<span class="math inline">\(k/2-1\)</span>），然后比较 <span class="math inline">\(A[k/2-1]、B[k/2-1]\)</span> 的大小，分以下三种情况讨论区间的取舍问题。</p><ol type="1"><li><span class="math inline">\(A[k/2-1] &lt; B[k/2-1]\)</span> ，舍弃区间 <span class="math inline">\(A[0:k/2-1]\)</span></li><li><span class="math inline">\(A[k/2-1] &gt; B[k/2-1]\)</span> ，舍弃区间 <span class="math inline">\(B[0:k/2-1]\)</span><br /></li><li><span class="math inline">\(A[k/2-1] = B[k/2-1]\)</span> ，可归入（1）或（2）</li></ol><p>Q：为什么比较两个有序区间的最大值就可以直接舍去其中一个区间呢？</p><p>A：已知<span class="math inline">\(A[0:k/2-1]、B[0:k/2-1]\)</span> 两段区间共计 <span class="math inline">\(k\)</span> 个数字，以（1）为例，<span class="math inline">\(A[k/2-1]\)</span>较小，所以在它之前的数字都不可能是第 <span class="math inline">\(k\)</span> 小的，可舍去，由于<span class="math inline">\(A[k/2-1] &lt; B[k/2-1]\)</span>，区间 <span class="math inline">\(B[0:k/2-1]\)</span> 中至少存在一个数字大于 <span class="math inline">\(A[k/2-1]\)</span> ，即 <span class="math inline">\(A[k/2-1]\)</span> 最多是第 <span class="math inline">\(k-1\)</span> 大的，舍去 <span class="math inline">\(A[0:k/2-1]\)</span> 不会影响寻找第 <span class="math inline">\(k\)</span> 小的数字。那么，当<span class="math inline">\(A[k/2-1] &lt; B[k/2-1]\)</span> ，说明第 <span class="math inline">\(k\)</span> 个数位于 <span class="math inline">\(A\)</span> 数组的第 <span class="math inline">\(k / 2\)</span> 个数后半段，或者 <span class="math inline">\(b\)</span> 数组的 第 <span class="math inline">\(k / 2\)</span> 个数前半段，问题规模缩小了一半，然后递归处理子问题就行。</p></blockquote><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//这不是我写的，我晚点按照这个思路试着重写</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getKthElement</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span><span class="hljs-comment">         * 这里的 &quot;/&quot; 表示整除</span><span class="hljs-comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span><span class="hljs-comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span><span class="hljs-comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span><span class="hljs-comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span><span class="hljs-comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span><span class="hljs-comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span><span class="hljs-comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span> m = nums1.size();        <span class="hljs-keyword">int</span> n = nums2.size();        <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// 边界情况</span>            <span class="hljs-keyword">if</span> (index1 == m) &#123;                <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];            &#125;            <span class="hljs-keyword">if</span> (index2 == n) &#123;                <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];            &#125;            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> min(nums1[index1], nums2[index2]);            &#125;            <span class="hljs-comment">// 正常情况</span>            <span class="hljs-keyword">int</span> newIndex1 = min(index1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);            <span class="hljs-keyword">int</span> newIndex2 = min(index2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);            <span class="hljs-keyword">int</span> pivot1 = nums1[newIndex1];            <span class="hljs-keyword">int</span> pivot2 = nums2[newIndex2];            <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2) &#123;                k -= newIndex1 - index1 + <span class="hljs-number">1</span>;                index1 = newIndex1 + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                k -= newIndex2 - index2 + <span class="hljs-number">1</span>;                index2 = newIndex2 + <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;        <span class="hljs-keyword">int</span> totalLength = nums1.size() + nums2.size();        <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> getKthElement(nums1, nums2, (totalLength + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> (getKthElement(nums1, nums2, totalLength / <span class="hljs-number">2</span>) + getKthElement(nums1, nums2, totalLength / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;        &#125;    &#125;&#125;;</code></pre><h3 id="np完全性">NP完全性</h3><ol type="1"><li><p>P与NP</p><ul><li><p>P类问题可以用多项式时间的确定性算法进行判定或求解。（多项式时间可解）</p><p>Polynomial</p></li><li><p>NP类问题可用多项式时间的非确定性算法进行判定或求解。（多项式时间可验证）</p><p>Non-deterministic Polynomial</p></li><li><p>判定问题：仅要求回答"yes"与"no"(证比求易) <span class="math inline">\(P \subseteq NP\)</span></p></li></ul><p><font color='#FF0000'>所有NP 问题都是判定问题，回答 yes 或 no</font></p></li><li><p>经典问题 (NP-completeness )</p><p><a href="https://en.wikipedia.org/wiki/List_of_NP-complete_problems">List of NP-complete problems</a></p><p>SAT 问题 (Boolean Satisfiability) - 第一个NP-C</p><p>最大团问题 (Maximum Clique)</p><p>图着色问题 (Graph Coloring)</p><p>哈密顿回路问题 (Hamiltonian Cycle)</p><p>TSP 问题 (Traveling Salesman)</p><p>顶点覆盖问题 (Vertex Cover)</p><p>最长路径问题 (Longest Path)</p><p>子集和问题 (Sum of Subset)</p><p><img src="Snipaste_2020-12-24_14-25-21.png" /></p><p>若某个NP完全问题多项式时间可解，则所有NP问题均可多项式时间求解，从而有P=NP。</p><p><img src="Snipaste_2020-12-24_14-31-07.png" /></p></li><li><p>规约 Reduction</p><p>一个问题A可以归约为问题B的含义是，可用问题B的解法解决问题A，或者说，问题A可以“变成”问题B；举个例子，一元一次方程求解可以归约化为一元二次方程求解。（B的复杂度大于等于A的复杂度）</p></li></ol><h3 id="近似算法">近似算法</h3><p>经典问题：顶点覆盖，集合覆盖，旅行商问题，子集和问题，随机和线性规划。</p><p>定义：能够给出一个优化问题的近似优化解的算法，主要解决优化问题（最大化和最小化）</p><p>评价指标（近似度）：Ratio Bound，相对误差。</p><p><img src="Snipaste_2020-12-24_15-55-46.png" /></p><p><img src="Snipaste_2020-12-24_15-56-16.png" /></p><p>满足 <span class="math inline">\(\epsilon(n) \le B(n)-1\)</span> (最小化问题时<span class="math inline">\(\epsilon(n) = B(n)-1\)</span>)，只要求出了RB就可以得出相对误差。</p><p>参考资料 <a href="https://zhpmatrix.github.io/2016/10/28/np-problem/">[1]</a></p><ol type="1"><li><p>顶点覆盖</p><p>选取若干个点组成集合A，其所连接的边可以把改图的所有点都囊括，希望|A|尽可能地小。</p><p>近似的方法是随机选取一条边<span class="math inline">\((u,v)\)</span>，删除与u或v相连的边，将每一条边的两个端点加入A，重复直到无边可删，由于每次都会加入两个点加入A，所以近似比为2。</p><p>可以用线性规划来做，原问题可以转化为0-1整数规划问题，但是可以适当放宽条件，是的<span class="math inline">\(x(v)\)</span>取值为浮点数。（整数规划是NP完全的，线性规划是多项式可解的）</p></li><li><p>集合覆盖问题</p><p>有限集合<span class="math inline">\(U=\{1,2,...,n\}\)</span>，子集和的集合<span class="math inline">\(S=\{ s_1, s_2, ...,s_m\}\)</span> , <span class="math inline">\(s_i \subseteq U\)</span> ，求集合<span class="math inline">\(A\subseteq S\)</span> ,满足元素完全覆盖U.</p><p>近似的方法是每次迭代选择能覆盖最多未被覆盖元素的子集。</p><p><img src="Snipaste_2020-12-24_16-58-50.png" /></p></li><li><p>旅行商问题</p><p>给定一个完全无向图G=(V,E)，其每一边(u,v)∈E有一非负整数费用c(u,v)，要找出G的最小费用哈密顿回路。</p><p>近似算法需利用一个性质（三角不等式）：费用函数<span class="math inline">\(c\)</span>通常意义下具有三角不等式性质，即对任意的3个顶点<span class="math inline">\(u,v,w∈V\)</span>，有：<span class="math inline">\(c(u,w)≤c(u,v)+c(v,w)\)</span>。</p><p><img src="Snipaste_2020-12-24_17-32-36.png" /></p></li><li><p>子集和问题</p><p><span class="math inline">\(S=\{x_1,x_2,...,x_n\}\)</span>是一个正整数的集合，t是一个正整数。子集和问题判定是否存在S的一个子集<span class="math inline">\(S_1\)</span>，使得<span class="math inline">\(S_1\)</span>中的元素和等于t。</p></li><li><p>Max-3CNF</p><p><img src="Snipaste_2020-12-24_17-39-42.png" /></p></li></ol><h3 id="随机算法">随机算法</h3><p>随机算法是一种使用概率和统计方法在其执行过程中对于下一步计算做出随机选择的算法。</p><ol type="1"><li><p>随机算法分类</p><p>随机数值算法、Monte Carlo算法、Las Vegas算法、Sherwood算法</p><ul><li><p>随机数值算法</p><p>主要用于数值问题求解，往往输出近似解，且精确度与执行时间成正比。</p><p>e.g. 计算<span class="math inline">\(\pi\)</span>（正方形与四分之一圆、投针实验计算）、计算积分（强大数定律）</p></li><li><p>Mente Carlo算法</p><p>主要用于需要准确解的问题，<font color='#FF0000'>算法可能给出错误的解</font>，且获得精确解的概率与算法执行时间成正比。</p><p>e.g. 求主元素（一半以上的元素都是<span class="math inline">\(x\)</span>）MC算法执行<span class="math inline">\(k\)</span>次，算法发生错误的概率为<span class="math inline">\(2^{(-k)}\)</span> 参考资料 <a href="https://blog.csdn.net/chensanwa/article/details/78657163">非随机算法</a> （传统算法就是对每一个数字都去从头到尾遍历一遍，很傻，所以复杂度是<span class="math inline">\(\Omicron(n^2)\)</span>）、判断字符串是否相等（去指纹，错判率）、字符串匹配、素数测试（Fermat小定理）</p><p><img src="Snipaste_2020-12-24_20-39-30.png" /></p><p><img src="Snipaste_2020-12-24_20-56-54.png" /></p></li><li><p>Sherwood算法</p><p>一定可求一个正确解，确定算法的最坏与平均复杂性差别很大，加入随机性即得到Sherwood算法。作用是消除最坏行为和特定实例的联系。</p><p>e.g. 快速排序，每次随机选取一个基准数字。</p></li><li><p>Las Vegas算法</p><p>一旦找到一个解，该解一定是正确的，且找到解的概率与执行时间成正比，增加对问题反复求解次数，可使求解无效的概率任意小。</p><p>e.g. 求第<span class="math inline">\(k\)</span>小元素2（若以等概率方法从<span class="math inline">\(n\)</span>个数中随机取数，则该算法比较次数的期望不超过<span class="math inline">\(4n\)</span>）</p><p><img src="Snipaste_2020-12-24_20-23-32.png" /></p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式训练技术总结</title>
    <link href="/2020/09/19/2020-09-19-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/19/2020-09-19-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式训练总结">分布式训练总结</h1><hr /><h2 id="分布式训练方法概述">分布式训练方法概述</h2><h3 id="集合通信">集合通信</h3><p>在多GPU训练的深度学习任务中常用到 <a href="https://github.com/NVIDIA/nccl">NCCL</a>（ NVIDIA Collective Communications Library ），NCCL中囊括的几种数据通信原语：Scatter、Broadcast、Reduce、AllReduce、AlltoAll、Gather</p><p><img src="Snipaste_2020-09-17_21-28-58.png" /></p><h3 id="同步协议">同步协议</h3><p><span class="citation" data-cites="todo">@todo</span> BSP、ASP(ASync)、SSP</p><h3 id="数据并行">数据并行</h3><p><span class="citation" data-cites="todo">@todo</span> 暂略</p><h3 id="模型并行">模型并行</h3><p><span class="citation" data-cites="todo">@todo</span> 暂略</p><h3 id="混合并行">混合并行</h3><h4 id="流水线优化-pipeline">流水线优化 Pipeline</h4><p>Pipelining 优化，思路与CPU的指令流水线相似，早在。分布式训练中的流水线“指令”为各种张量的正反向计算任务，backward耗时一般为forward任务的两倍。一般流水线的深度大于1，宽度为1，但在PipeDream-2BW中流水线宽度可为2、4、8等更大的值。本节主要涉及4种流水线优化方法共计5篇论文 <strong>[ 3 ] - [ 7 ]</strong> ：Gpipe，Pipe Dream及其内存优化版本PipeDream-2BW，基于PS的流水线优化。</p><ul><li>GPipe</li></ul><p>论文 <strong>[ 3 ]</strong> 提出了名为GPipe的Pipeline并行化库，支持任何可以表达为层序列的网络。主要有如下三点贡献：</p><ol type="1"><li>Network partition(网络分片)。将一个N层的网络划分成K个partition, 每个partition在单独的TPU上执行，partition之间需要插入一些网络通信操作。</li><li>Pipeline parallelism(流水线并行). Splits a mini-batch to smaller macro-batches. 把CPU里的流水线并发技术用在了深度学习上，主要是把计算和网络通信两种操作，更好地重排列。</li><li>Recomputation(重计算) . Recomputes the forward activations during the backpropagation, in another word, it's gradient checkpointing. 跟OpenAI开源的 <a href="https://qywu.github.io/2019/05/22/explore-gradient-checkpointing.html">梯度检查点Gradient-Checkpointing</a> 一样，只不过GPipe是在TPU上实现的，OpenAI的只能运行在GPU上。</li></ol><p><img src="Snipaste_2020-09-16_19-58-19.png" /></p><p>GPipe的工作原理很清晰，每次有若干个micro-batch进入流水线，执行Forward与Backward任务,是所有的Forward任务使用的都是上一轮的weights，但是这个流水线是不连续的，在一个mini-batch的Forward与Backward结束之后，需要flash流水线，更新权重。在Gpipe中，还提及了Recomputation，该思想最早出现在陈天奇发表的论文 <strong>[ 15 ]</strong> 中，以时间换取空间（Memory），有效地避免Cuda OOM。</p><ul><li>PipeDream &amp; PipeDream-2BW</li></ul><p>GPipe在一段时间区间内仅使用同一版本的weight，定期更新。而论文 <strong>[ 4 ] [ 5 ]</strong> 提出了PipeDream，PipeDream不会定期刷新流水线，而是存储多个weight版本，保证每个micro-batch在执行Forward与Backward任务时使用同一版本的weight，这既增加吞吐量也提高了内存占用。</p><p><img src="Snipaste_2020-09-17_20-20-47.png" /></p><p>论文 <strong>[ 6 ]</strong> 对PipeDream的内存占用做了针对性的优化，提出改进版本PipeDream-2WB（double-buffered weight updates ，下简称2BW）。减少内存占用的同时，还可以避免GPipe中weight更新导致的流水线flush。在2BW中，若流水线为 <span class="math inline">\(d\;(d &gt; 1)\)</span> 个stage，编号为 <span class="math inline">\(m\;(m &gt; 1)\)</span> 的micro-batch对应的weight版本为 <span class="math inline">\(max(\lfloor m/d \rfloor - 1, 0)\)</span> 。</p><p><img src="Snipaste_2020-09-17_20-21-57.png" /></p><p>若2BW使用SGD，则更新方式为 <span class="math inline">\(\begin{equation}W^{(t+1)}=W^{(t)}-v \cdot \nabla f\left(W_{1}^{(t-1)}, \ldots, W_{d}^{(t-1)}\right)\end{equation}\)</span> ，允许使用上一个版本的weight。可见，流水线式的训练方式使用了 <span class="math inline">\(d\)</span> 个 micro-batch的梯度作平均，这相当于梯度累加，变相提高了mini-batch的size。</p><p>此外，对于每一个stage，都做width方向的复制（batch-size的切分），每条流水线都复制成了两份 ，据说对 <a href="https://arxiv.org/pdf/1706.03762.pdf">transformer-style</a> 的模型有利。(With data- parallel updates across replicas of the same stage.）<font color=red>此举为了实现流水线的数据并行？</font></p><p>关于梯度的Recomputation：实现方式参照论文 <strong>[ 15 ]</strong> ，网络分为 <span class="math inline">\(d\)</span> 个segment（同stage数量），使用Recomputation的内存占用是 <span class="math inline">\(\frac {2|W|}{d} + \frac {|A^{total}(b)|}{d}\)</span> （stores output activations at the partition boundaries）。</p><p><img src="Snipaste_2020-09-17_20-21-02.png" /></p><p>Q：在partition Algorithm中有一个SEARCH( )函数，用于得出（b，r）两个参数，这个如何实现？</p><p>Q：AccPar有无改成流水线的可能呢？比如，这里每个stage宽度w=2，不做数据的复制，而是对layer层次进行划分，交给两个卡计算。这样做有几个潜在的好处，第一，我们划分层次的时候可以更好地规定哪几层放一起组成一个segment（同一个stage），因为AccPar对DP-MP的混合并行组合做了定量分析，每一种type的cost都可以模拟出来，容易刻画每一个stage的cost。第二，可以尝试用AccPar的这种方式实现stage内的细粒度并行，也就是说stage内是细粒度并行的，即类似AccPar的方法，而stage之间还是流水线的方式，Recomputation也可引入。第三，可以引入对Heterogeneity的支持，AccPar中<span class="math inline">\(\begin{array}{r} \alpha \cdot E_{\mathrm{cp}}\left(p_{i, l}\right)+\alpha \cdot E_{\mathrm{cm}}\left(p_{i, l}\right) =\beta \cdot E_{\mathrm{cp}}\left(p_{j, l}\right)+\beta \cdot E_{\mathrm{cm}}\left(p_{j, l}\right) \end{array}\)</span> ，异构情况下通过 <span class="math inline">\(\alpha\)</span> 比例的intra-layer任务划分，使得同一层不同卡通信+计算的时间相等（针对异构情况，HetPipe中是另外一种形式的流水线）。</p><ul><li>HetPipe</li></ul><p>HetPipe中的3大创新点：</p><ol type="1"><li>通过Virtual Worker（VW）的方式实现数据并行（通过跨节点重组GPU的方式实现数据并行）</li><li>VW使用Pipelined-MP的方式实现提高GPU资源利用率（GPipe和PipeDream已经提出过，但是据作者说，他们是首个在异构GPU平台上实现的）</li><li>WSP：参数同步模型 Wave Synchronous Parallel（核心是两级SSP）</li></ol><figure><img src="sp20200919_164144_255.png" alt="9" /><figcaption aria-hidden="true">9</figcaption></figure><p><img src="Snipaste_2020-09-19_16-50-58.png" /></p><p>上图是整个系统的训练模式，G1-G4是同一个VW中的4张GPU，每一个VW都保有一份完整的模型副本，以PS的方式进行训练，weight的同步方式使用SSP（Stale Synchronous Parallel）。在一般SSP协议基础上，设置两个层次的阈值：Global Staleness Bound 和 Local Staleness Threshold。</p><p>① Global Staleness Bound （记作 <span class="math inline">\(D\)</span> ）在VW-PS的层次，最快的VW与最慢的VW之间允许存在 <span class="math inline">\(D\)</span> 个clock的差距（此处1个clock代表一个wave，全局时钟为 <span class="math inline">\(c_{global}\)</span>，它代表所有VW中最慢的本地时钟 <span class="math inline">\(c_{local}\)</span> ，所以 <span class="math inline">\(D\)</span> 代表的是最快最慢两个本地之中的最大差值，该值人为设定）。当本地时钟 <span class="math inline">\(c_{local} \ge D+1\)</span> 时，必须使用来自wave <span class="math inline">\([0,c-D-1]\)</span> 或更加新的weight。</p><p>② Local Staleness Threshold（记作<span class="math inline">\(s_{local}\)</span>），指示的是VW中可超前执行的batch。当训练过程触及Global Staleness Bound时，需要从PS上pull最新的weight，然后继续训练。即，若最慢的VW还未将wave <span class="math inline">\(c-D\)</span> 的更新push给PS，那么最快的VW可以超前执行 <span class="math inline">\(s_{local}\)</span> 个batch（假设一个中包含 <span class="math inline">\(N_m\)</span> 个batch，那么<span class="math inline">\(s_{local} = N_m - 1\)</span>）。</p><p>综合①②，全局的Staleness记作 <span class="math inline">\(s_{global}\)</span> ，mini_batch_id记作 <span class="math inline">\(p\)</span> ，当 <span class="math inline">\(p &gt; (D + 1) \times (s_local + 1) + s_{local}\)</span> 时，mini_batch p 必须使用来自其他VW，在区间 <span class="math inline">\([0,p-s_{global}-1]\)</span> 的weight。其中 <span class="math inline">\(s_{global} = (D + 1) \times (s_local + 1) + s_{local} - 1\)</span> 。</p><p>PS：都是已有的东西，连证明过程也是在SSP的基础上推导。</p><p><img src="Snipaste_2020-09-19_20-25-45.png" /></p><h4 id="张量划分-tensor-partitioning-slicing">张量划分 Tensor Partitioning / Slicing</h4><p><span class="citation" data-cites="todo">@todo</span> AccPar、FlexFlow、TensorOpt</p><h3 id="内存优化">内存优化</h3><p>论文 <strong>[ 15 ]</strong> 。</p><ul><li>Capuchin</li></ul><p>论文 <strong>[ 16 ]</strong> 提出 <strong>Capuchin</strong>（a tensor-based GPU memory management module ），使用“tensor eviction/prefetching and recomputation”来减少内存占用。依据来源于一个Observation，即在训练过程中对tensor的访问是有规律的，由此可以基于第一轮迭代的访问记录来实施内存的优化时间与方法。（ when and how to perform memory optimization）</p><p><strong>节省内存小妙招：内存交换、重计算、低精度浮点...</strong></p><hr /><h2 id="框架">框架</h2><h3 id="mindscope">MindScope</h3><p><a href="https://www.mindspore.cn/">项目官网</a>与<a href="https://gitee.com/mindspore/mindspore">开源地址</a></p><h3 id="pipedream">PipeDream</h3><p><a href="https://github.com/msr-fiddle/pipedream">开源地址</a></p><hr /><h2 id="领域学者">领域学者</h2><ol type="1"><li><p>李沐</p><p>亚马逊首席科学家 、MXNet</p></li><li><p>陈天齐</p><p>TVM、MXNet、XGBoost</p></li><li><p>贾杨清</p><p>Caffe、Google大脑科学家</p></li><li><p>Eric Xing（邢波）</p><p>Petuum</p></li><li><p>褚晓文(Xiaowen Chu) HKBU</p></li><li><p>李丹、王帅、耿金坤（清华-stanford）</p></li><li><p>Alex Aiken、<a href="https://github.com/jiazhihao">jiazhihao</a> 、 <a href="https://github.com/deepakn94">Deepak Narayanan</a> 、<a href="https://cs.stanford.edu/~matei/">Matei Zaharia</a> (pipedream、flexflow)</p></li></ol><hr /><h2 id="参考文献">参考文献</h2><ol type="1"><li>Jia Z, Lin S, Qi C R, et al. <strong>Exploring hidden dimensions in parallelizing convolutional neural networks[J]</strong>. arXiv preprint arXiv:1802.04924, 2018.</li><li>Jia Z, Zaharia M, Aiken A. <strong>Beyond data and model parallelism for deep neural networks[J]</strong>. arXiv preprint arXiv:1807.05358, 2018.</li><li>Huang Y, Cheng Y, Bapna A, et al. <strong>Gpipe: Efficient training of giant neural networks using pipeline parallelism[C]</strong>//Advances in neural information processing systems. 2019: 103-112.</li><li>Harlap A, Narayanan D, Phanishayee A, et al. <strong>Pipedream: Fast and efficient pipeline parallel dnn training[J]</strong>. arXiv preprint arXiv:1806.03377, 2018.</li><li>Narayanan D, Harlap A, Phanishayee A, et al. <strong>PipeDream: generalized pipeline parallelism for DNN training[C]</strong>//Proceedings of the 27th ACM Symposium on Operating Systems Principles. 2019: 1-15.</li><li>Narayanan D, Phanishayee A, Shi K, et al. <strong>Memory-Efficient Pipeline-Parallel DNN Training[J]</strong>. arXiv preprint arXiv:2006.09503, 2020.</li><li>Park J H, Yun G, Yi C M, et al. <strong>HetPipe: Enabling Large DNN Training on (Whimpy) Heterogeneous GPU Clusters through Integration of Pipelined Model Parallelism and Data Parallelism[J]</strong>. arXiv preprint arXiv:2005.14038, 2020.</li><li>Cai Z, Ma K, Yan X, et al. <strong>TensorOpt: Exploring the Tradeoffs in Distributed DNN Training with Auto-Parallelism[J]</strong>. arXiv preprint arXiv:2004.10856, 2020.</li><li>Geng J, Li D, Wang S. <strong>Fela: Incorporating Flexible Parallelism and Elastic Tuning to Accelerate Large-Scale DML[C]</strong>//2020 IEEE 36th International Conference on Data Engineering (ICDE). IEEE, 2020: 1393-1404.</li><li>Song L, Chen F, Zhuo Y, et al. <strong>AccPar: Tensor Partitioning for Heterogeneous Deep Learning Accelerators[C]</strong>//2020 IEEE International Symposium on High Performance Computer Architecture (HPCA). IEEE, 2020: 342-355.</li><li>Wang M, Huang C, Li J. <strong>Supporting very large models using automatic dataflow graph partitioning[C]</strong>//Proceedings of the Fourteenth EuroSys Conference 2019. 2019: 1-17.</li><li>Band N. <strong>MemFlow: Memory-Aware Distributed Deep Learning[C]</strong>//Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data. 2020: 2883-2885.</li><li>Luo Q, He J, Zhuo Y, et al. <strong>Prague: High-Performance Heterogeneity-Aware Asynchronous Decentralized Training[C]</strong>//Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems. 2020: 401-416.</li><li>Addanki R, Venkatakrishnan S B, Gupta S, et al. <strong>Placeto: Learning generalizable device placement algorithms for distributed machine learning[J]</strong>. arXiv preprint arXiv:1906.08879, 2019.</li><li>Chen T, Xu B, Zhang C, et al. <strong>Training deep nets with sublinear memory cost[J]</strong>. arXiv preprint arXiv:1604.06174, 2016.</li><li>Peng X, Shi X, Dai H, et al. <strong>Capuchin: Tensor-based GPU Memory Management for Deep Learning[C]</strong>//Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems. 2020: 891-905.</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode专题 BFS DFS</title>
    <link href="/2020/07/26/2020-07-01-%E5%8A%9B%E6%89%A3-DFS+BFS/"/>
    <url>/2020/07/26/2020-07-01-%E5%8A%9B%E6%89%A3-DFS+BFS/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-bfs-dfs">LeetCode BFS + DFS</h1><p><strong>代码规范</strong></p><p><strong>TIPS：没有看Java的输入输出如何写，晚点补上。不写main函数。</strong></p><hr /><h2 id="stl专题">STL专题</h2><ul><li><p>map用法总结（<a href="https://blog.csdn.net/sevenjoin/article/details/81943864">整理1</a>）（<a href="https://www.cnblogs.com/tangyikejun/p/4220316.html">整理2</a>）</p></li><li><p>vector用法总结（<a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html">整理1</a>）</p></li><li><p>string用法大全（length() substring() substr()）</p></li></ul><hr /><p>1.<a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p><p>HashMap</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)            map.put(nums[i],i);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;            Integer v = map.get(target - nums[i]);            <span class="hljs-keyword">if</span>(v!=(Integer)i &amp;&amp; v!=<span class="hljs-keyword">null</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,v&#125;;<span class="hljs-comment">//也可以采用遍历一次Map的方法</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>)</span></span>;        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; num_map;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;            <span class="hljs-keyword">if</span>(num_map.count(target - nums[i]) == <span class="hljs-number">1</span>)&#123;                ans[<span class="hljs-number">0</span>] = num_map[target-nums[i]];                ans[<span class="hljs-number">1</span>] = i;                <span class="hljs-keyword">break</span>;            &#125;            num_map.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(nums[i],i));        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>7.<a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></p><p>注意数据的范围，反转之后会超过int_32，使用long不溢出，Java中使用的是 truncate 除法：</p><p>a=b*q +r，其中 |r|&lt;|a|。因此 r 有两个选择，一个为正，一个为负;相应的，q 也有两个选择。如果a、b 都是正数的话，那么一般的编程语言中，r 为正数；或者如果 a、b 都是负数的话，一般 r 为负数。但是如果 a、b 一正一负的话，不同的语言则会根据除法的不同结果而使得 r 的结果也不同，但是一般 r 的计算方法都会满足：r=a-(a/b)*b</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;            ans = ans*<span class="hljs-number">10</span> + x%<span class="hljs-number">10</span>;             x /=<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">int</span> A = (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>);        <span class="hljs-keyword">if</span>(ans &gt;= -A &amp;&amp; ans &lt;= A-<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)ans;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">//cout&lt;&lt; (-11%3)endl;-2147483648</span>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_INT = <span class="hljs-number">2147483647</span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MIN_INT = <span class="hljs-number">-2147483648</span>;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> p = x%<span class="hljs-number">10</span>; <span class="hljs-comment">//求x最低位数字</span>            <span class="hljs-comment">//每次对ans乘以10，当ans位数小于MAX_INT/MIN_INT时，一定不溢出；</span>            <span class="hljs-comment">//当ans位数与MAX_INT/MIN_INT相同时，需要考虑最后一位是否大于7或小于-8.</span>            <span class="hljs-keyword">if</span>(ans &gt; MAX_INT/<span class="hljs-number">10</span> || (ans == MAX_INT/<span class="hljs-number">10</span> &amp;&amp; p &gt; <span class="hljs-number">7</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">if</span>(ans &lt; MIN_INT/<span class="hljs-number">10</span> || (ans == MIN_INT/<span class="hljs-number">10</span> &amp; p &lt; <span class="hljs-number">-8</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            ans = ans*<span class="hljs-number">10</span> + p;            x /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>9.<a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></p><pre><code class="hljs Java"><span class="hljs-comment">//其实在T7中给出了计算回文串的一种方式，回文串一定不会溢出</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">long</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">long</span> xx = x;        <span class="hljs-keyword">while</span>(xx!=<span class="hljs-number">0</span>)&#123;            num = num*<span class="hljs-number">10</span> + xx%<span class="hljs-number">10</span>;            xx /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">if</span>(x == num)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-built_in">string</span> s = to_string(x);        <span class="hljs-built_in">string</span> r = to_string(x);        reverse(s.begin(),s.end());        <span class="hljs-keyword">if</span>(s==r)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//反转一半的情况</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">/* 判断特殊情况</span><span class="hljs-comment">         * 情况1:负数  情况2:末尾有0的整数,反转后前缀0没了,满足条件的只有0</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || (x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> &amp;&amp; x!=<span class="hljs-number">0</span>))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//为了防止溢出,反转一半的数字</span>        <span class="hljs-comment">//int len = 0;这里不需要求出长度,数字对半分之后可以比较出大小</span>        <span class="hljs-keyword">int</span> half = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x &gt; half)&#123;            <span class="hljs-keyword">int</span> tmp = x%<span class="hljs-number">10</span>;            half = half*<span class="hljs-number">10</span> + tmp;            x /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-comment">//此处考虑了数字长度为奇数或偶数的情况</span>        <span class="hljs-keyword">return</span> x==half || x==(half/<span class="hljs-number">10</span>);    &#125;&#125;;</code></pre><p>13.<a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></p><p>这道题目学习到了Map的优雅的初始化方式和罗马数字的计数规则。</p><p>罗马数字是阿拉伯数字传入之前使用的一种数码。罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）。记数的方法：</p><pre><code class="hljs angelscript">https:<span class="hljs-comment">//www.douban.com/note/335254352/</span>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=<span class="hljs-number">3</span>；小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=<span class="hljs-number">8</span>、Ⅻ=<span class="hljs-number">12</span>；小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=<span class="hljs-number">4</span>、Ⅸ=<span class="hljs-number">9</span>；在一个数的上面画一条横线，表示这个数增值 <span class="hljs-number">1</span>,<span class="hljs-number">000</span> 倍，如V(上面一横) = <span class="hljs-number">5000</span>。</code></pre><pre><code class="hljs java">Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;() &#123;<span class="hljs-comment">//第二个&quot;&lt;&gt;&quot;内的内容不可以缺少</span>    　　&#123;        　　put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;June&quot;</span>);         　　 put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">12</span>);      　　&#125;　　&#125;; 　　　<span class="hljs-comment">/*外层的一组“&#123;&#125;”表示的是一个匿名类，内层的一对“&#123;&#125;”表示的是实例初始化块，然后这边还有一点需要明白，实例初始化块的代码在编译器编译过后，是放在类的构造函数里面的，并且是在原构造函数代码的前面。&quot;*/</span></code></pre><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(String s)</span> </span>&#123;        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;()&#123;            &#123;                put(<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>);                 put(<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>);                put(<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>);                put(<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>);                put(<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>);                put(<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>);                put(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>);            &#125;        &#125;;<span class="hljs-comment">//一开始这里出错了，没有用Character类而用的String类，指针异常</span>        <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;             curr = map.get(s.charAt(i));            <span class="hljs-keyword">if</span>(curr &gt; last)                ans = ans - <span class="hljs-number">2</span>*last;            ans += curr;            last = curr;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//C++ version</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp&#123;            &#123;<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>&#125;,            &#123;<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>&#125;,            &#123;<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>&#125;,            &#123;<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>&#125;,            &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>&#125;,            &#123;<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>&#125;,            &#123;<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>&#125;        &#125;;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储上一位罗马数字</span>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储当前的罗马数字，与上一位比较大小，若小于直接相加，大于则减去2*pre</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            cur = mp[s[i]];            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; cur &gt; pre)&#123;                ans -= <span class="hljs-number">2</span>*pre;            &#125;            ans += cur;            pre = cur;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//低效</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; num;        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-number">1</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-number">4</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-number">5</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;IX&quot;</span>, <span class="hljs-number">9</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-number">10</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-number">40</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-number">50</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;XC&quot;</span>, <span class="hljs-number">90</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">100</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-number">400</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">500</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;CM&quot;</span>, <span class="hljs-number">900</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-number">1000</span>));        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;            <span class="hljs-keyword">if</span>(i&lt;len<span class="hljs-number">-1</span> &amp;&amp; num.count(s.substr(i,<span class="hljs-number">2</span>)) &gt; <span class="hljs-number">0</span>) &#123;                ans += num[s.substr(i,<span class="hljs-number">2</span>)];                i++;            &#125;            <span class="hljs-keyword">else</span> &#123;                ans += num[s.substr(i,<span class="hljs-number">1</span>)];            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>14.<a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></p><p>大概有这五种思路, 一般都会采用第四种, 但是耗时太多</p><p>1、所求的最长公共前缀子串一定是每个字符串的前缀子串。所以随便选择一个字符串作为标准，把它的前缀串，与其他所有字符串进行判断，看是否是它们所有人的前缀子串。这里的时间性能是O(m<em>n</em>m)。</p><p>2、列出所有的字符串的前缀子串，将它们合并后排序，找出其中个数为n且最长的子串。时间性能为O(n<em>m+m</em>n<em>log(m</em>n))</p><p>3、纵向扫描：从下标0开始，判断每一个字符串的下标0，判断是否全部相同。直到遇到不全部相同的下标。时间性能为O(n*m)。</p><p>4、横向扫描：前两个字符串找公共子串，将其结果和第三个字符串找公共子串……直到最后一个串。时间性能为O(n*m)。</p><p>5、借助trie字典树。将这些字符串存储到trie树中。那么trie树的第一个分叉口之前的单分支树的就是所求。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//居然有空的string数组</span>        <span class="hljs-keyword">int</span> maxlen = strs[<span class="hljs-number">0</span>].length();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=maxlen;l++)&#123;            String prefix = strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>,l);            cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;strs.length;i++)&#123;                <span class="hljs-keyword">if</span>(strs[i].startsWith(prefix))&#123;                    cnt++;                &#125;                       &#125;            <span class="hljs-keyword">if</span>(cnt!=strs.length-<span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">if</span>(l==<span class="hljs-number">1</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;                <span class="hljs-keyword">else</span>                     <span class="hljs-keyword">return</span> prefix.substring(<span class="hljs-number">0</span>,l-<span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(l==strs[<span class="hljs-number">0</span>].length())&#123;                    <span class="hljs-keyword">return</span> prefix.substring(<span class="hljs-number">0</span>,l);                &#125;                 &#125;                   &#125;          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs)</span> </span>&#123;        <span class="hljs-built_in">string</span> ans = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">if</span>(strs.size()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> ans;        sort(strs.begin(),strs.end());        <span class="hljs-keyword">int</span> LEN = <span class="hljs-number">0x3f3f3f3f</span>;        <span class="hljs-keyword">int</span> CNT = strs.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;CNT;i++)&#123;            <span class="hljs-keyword">if</span>(strs[i].length() &lt; LEN)&#123;                LEN = strs[i].length();            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;LEN;i++)&#123;            <span class="hljs-keyword">if</span>(strs[<span class="hljs-number">0</span>][i]==strs[CNT<span class="hljs-number">-1</span>][i])&#123;                ans += strs[<span class="hljs-number">0</span>][i];            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>20.<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<span class="hljs-comment">//简单的堆栈应用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-comment">//Stack&lt;Character&gt; stk = new Stack&lt;&gt;();</span>        Stack stk = <span class="hljs-keyword">new</span> Stack();        <span class="hljs-keyword">if</span>(s.length()%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-comment">//stk.push(s.charAt(0));</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            <span class="hljs-keyword">if</span>(stk.empty())&#123;                stk.push(s.charAt(i));                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">char</span> c = (<span class="hljs-keyword">char</span>)stk.peek();            <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; c==<span class="hljs-string">&#x27;(&#x27;</span> || s.charAt(i)==<span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; c==<span class="hljs-string">&#x27;[&#x27;</span> ||s.charAt(i)==<span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; c==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;                stk.pop();            &#125;            <span class="hljs-keyword">else</span>                 stk.push(s.charAt(i));        &#125;        <span class="hljs-keyword">if</span>(stk.empty())            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><pre><code class="hljs Java"><span class="hljs-comment">//巨慢无比124ms 但是短啊</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s.length()%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">while</span>(s.indexOf(<span class="hljs-string">&quot;()&quot;</span>)!=-<span class="hljs-number">1</span> || s.indexOf(<span class="hljs-string">&quot;[]&quot;</span>)!=-<span class="hljs-number">1</span> || s.indexOf(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>)!=-<span class="hljs-number">1</span>)&#123;            s=s.replaceAll(<span class="hljs-string">&quot;\\(\\)&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);            s=s.replaceAll(<span class="hljs-string">&quot;\\[\\]&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);            s=s.replaceAll(<span class="hljs-string">&quot;\\&#123;\\&#125;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> s.length()==<span class="hljs-number">0</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//优秀的题解,使用数字来表示括号,判断条件好写</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; m&#123;&#123;<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-number">3</span>&#125;,                                &#123;<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-number">6</span>&#125;&#125;;        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; st;        <span class="hljs-keyword">bool</span> istrue=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:s)&#123;            <span class="hljs-keyword">int</span> flag=m[c];            <span class="hljs-keyword">if</span>(flag&gt;=<span class="hljs-number">1</span>&amp;&amp;flag&lt;=<span class="hljs-number">3</span>) st.push(c);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!st.empty()&amp;&amp;m[st.top()]==flag<span class="hljs-number">-3</span>) st.pop();            <span class="hljs-keyword">else</span> &#123;istrue=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;        &#125;        <span class="hljs-keyword">if</span>(!st.empty()) istrue=<span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> istrue;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//C++版,默认flag为true,去判断括号不匹配的情况</span><span class="hljs-comment">//情况1:当前括号是右括号但是与栈顶的括号不匹配</span><span class="hljs-comment">//情况2:当前括号是右括号但是栈空</span><span class="hljs-comment">//情况3:括号串扫描结束，但栈中有多余的括号(奇数情况)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; st;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span> || s[i]==<span class="hljs-string">&#x27;[&#x27;</span> ||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;                st.push(s[i]);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(!st.empty())&#123;                    <span class="hljs-keyword">char</span> c = st.top();                    st.pop();                    <span class="hljs-keyword">if</span>((s[i]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;c==<span class="hljs-string">&#x27;(&#x27;</span>) || (s[i]==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;c==<span class="hljs-string">&#x27;[&#x27;</span>) || (s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;c==<span class="hljs-string">&#x27;&#123;&#x27;</span>))&#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        flag = <span class="hljs-literal">false</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;                <span class="hljs-keyword">else</span> &#123;                    flag = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;                <span class="hljs-keyword">if</span>(!st.empty())&#123;            flag = <span class="hljs-literal">false</span>;        &#125;                  <span class="hljs-keyword">return</span> flag;    &#125;&#125;;</code></pre><p>21.<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序表</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode *next;</span><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;        <span class="hljs-comment">//合并不需要再申请空间，直接指针连接，返回结果为L-next.</span>        ListNode* L = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);        ListNode* p = L;        ListNode* p1 = l1;        ListNode* p2 = l2;                <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">NULL</span> &amp;&amp; p2!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">if</span>( p1-&gt;val &lt; p2-&gt;val)&#123;                p-&gt;next = p1;                p = p-&gt;next;                p1 = p1-&gt;next;            &#125;            <span class="hljs-keyword">else</span> &#123;                p-&gt;next = p2;                p = p-&gt;next;                p2 = p2-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">if</span>(p1!=<span class="hljs-literal">NULL</span>)p-&gt;next = p1;        <span class="hljs-keyword">if</span>(p2!=<span class="hljs-literal">NULL</span>)p-&gt;next = p2;        <span class="hljs-keyword">return</span> L-&gt;next;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode *next;</span><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;        ListNode *p1 = l1; <span class="hljs-comment">//链表l1的指针,指向第一个结点</span>        ListNode *p2 = l2; <span class="hljs-comment">//链表l2的指针,指向第一个结点</span>        ListNode *L = <span class="hljs-keyword">new</span> ListNode(); <span class="hljs-comment">//合并后的链表头结点，分配空间</span>        ListNode *p = L; <span class="hljs-comment">//新链表的尾指针</span>        <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">nullptr</span> &amp;&amp; p2!=<span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)&#123;                p-&gt;next = p1;                p = p-&gt;next;                p1 = p1-&gt;next;            &#125;            <span class="hljs-keyword">else</span> &#123;                p-&gt;next = p2;                p = p-&gt;next;                p2 = p2-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">if</span>(p1!=<span class="hljs-literal">nullptr</span>)&#123;            p-&gt;next = p1;            <span class="hljs-comment">// p1 = p1-&gt;next;</span>        &#125;        <span class="hljs-keyword">if</span>(p2!=<span class="hljs-literal">nullptr</span>)&#123;            p-&gt;next = p2;            <span class="hljs-comment">// p2 = p2-&gt;next;</span>        &#125;        <span class="hljs-keyword">return</span> L-&gt;next;    &#125;&#125;;</code></pre><p>26.<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除数组中的重复项</a></p><p>双指针法。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//双指针(游标)法</span>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储新数组的尾部</span>        <span class="hljs-comment">// int cur = 0; //当前遍历到的数字</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;cur&lt;nums.size();cur++)&#123;            <span class="hljs-keyword">if</span>(nums[cur]!=nums[end])&#123;                end ++;                nums[end] = nums[cur];            &#125;        &#125;        <span class="hljs-keyword">return</span> end+<span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><p>27.<a href="https://leetcode-cn.com/problems/remove-element/">移除元素</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;nums.size();j++)&#123;            <span class="hljs-keyword">if</span>(nums[j]!=val)&#123;                swap(nums[i],nums[j]);                i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-comment">// if(nums.size()==0)&#123;</span>        <span class="hljs-comment">//     return 0;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储新数组的最后一个元素的下标,插入到下一个位置</span>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前遍历到的元素下标</span>        <span class="hljs-keyword">for</span>(cur=<span class="hljs-number">0</span>;cur&lt;nums.size();cur++)&#123;            <span class="hljs-keyword">if</span>(nums[cur]!=val)&#123;                nums[end] = nums[cur];                end ++;            &#125;        &#125;                <span class="hljs-keyword">return</span> end;    &#125;&#125;;</code></pre><p>35.<a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//本质上是一个二分查找的题目</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> r = nums.size();        <span class="hljs-comment">//使用[l,r)的二分写法，最后返回首个大于等于target的值的位置</span>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<span class="hljs-comment">//区间[l,r)非空</span>            <span class="hljs-keyword">int</span> mid = l + (r - l)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target)&#123;                r = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                l = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> l;    &#125;&#125;;</code></pre><p>38.<a href="https://leetcode-cn.com/problems/count-and-say/submissions/">报数</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vec2str</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;ans, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;            ans += (<span class="hljs-keyword">char</span>)(nums[i] + <span class="hljs-string">&#x27;0&#x27;</span>);        &#125;    &#125;     <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums[<span class="hljs-number">30</span>];        nums[<span class="hljs-number">0</span>].push_back(<span class="hljs-number">1</span>);                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> val = nums[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;nums[i].size();j++)&#123;                <span class="hljs-keyword">if</span>(nums[i][j]==val)&#123;                    cnt++;                &#125;<span class="hljs-keyword">else</span>&#123;                    nums[i+<span class="hljs-number">1</span>].push_back(cnt);                    nums[i+<span class="hljs-number">1</span>].push_back(val);                    val = nums[i][j];                    cnt = <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">if</span>(j==nums[i].size()<span class="hljs-number">-1</span>)&#123;                    nums[i+<span class="hljs-number">1</span>].push_back(cnt);                    nums[i+<span class="hljs-number">1</span>].push_back(val);                &#125;            &#125;        &#125;        <span class="hljs-built_in">string</span> ans;        vec2str(ans,nums[n<span class="hljs-number">-1</span>]);        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//这个写法还不错</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;1&quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;            <span class="hljs-built_in">string</span> tmp = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">int</span> len = s.length();            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;            <span class="hljs-comment">/*首个数字已经计数,下面的循环需要比较后一个数字与当前数字是否相同:</span><span class="hljs-comment">              若相同,则计数+1,否则,按照规则将已统计的字符写入字符串,设置cnt为1,</span><span class="hljs-comment">              此处的1表示的就是后一个字符重新开始计数,不设置为0。</span><span class="hljs-comment">            */</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;                <span class="hljs-keyword">if</span>(j&lt;len<span class="hljs-number">-1</span> &amp;&amp; s[j]==s[j+<span class="hljs-number">1</span>]) &#123;                    cnt ++;                &#125;                 <span class="hljs-keyword">else</span> &#123;                    tmp += to_string(cnt) + s[j];                    cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">//这里计算的是后一个数字的数量</span>                &#125;            &#125;            s = tmp;        &#125;        <span class="hljs-keyword">return</span> s;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;1&quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;            <span class="hljs-built_in">string</span> tmp = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">int</span> len = s.length();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;                <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<span class="hljs-comment">//这里注意是1</span>                <span class="hljs-keyword">while</span>(j&lt;len<span class="hljs-number">-1</span> &amp;&amp; s[j] == s[j+<span class="hljs-number">1</span>])&#123;                    cnt++;                    j++;                &#125;                tmp += to_string(cnt)+s[j];            &#125;            s = tmp;        &#125;        <span class="hljs-keyword">return</span> s;    &#125;&#125;;</code></pre><p>53.<a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序列和</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//O(n)的算法</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        ll cur_sum = <span class="hljs-number">0</span>;        ll max_sum = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;            cur_sum += nums[i];            <span class="hljs-keyword">if</span>(cur_sum &gt; max_sum)&#123;                max_sum = cur_sum;            &#125;            <span class="hljs-keyword">if</span>(cur_sum &lt; <span class="hljs-number">0</span>)&#123;                cur_sum = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> max_sum;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//O(n)的算法,可返回最大和的区间下标,（未验证）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        ll cur_sum = <span class="hljs-number">0</span>;        ll max_sum = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max_l = <span class="hljs-number">0</span>, max_r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cur_l = <span class="hljs-number">0</span>, cur_r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;            cur_sum += nums[i];            cur_r = i;            <span class="hljs-keyword">if</span>(cur_sum &gt; max_sum)&#123;                max_sum = cur_sum;                max_l = cur_l;                max_r = cur_r;            &#125;            <span class="hljs-keyword">if</span>(cur_sum &lt; <span class="hljs-number">0</span>)&#123;                cur_sum = <span class="hljs-number">0</span>;                cur_l = i+<span class="hljs-number">1</span>;                cur_r = i+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt; max_l &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; max_r &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> max_sum;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//1896 ms7 MB</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//下面使用分治法来求解,精妙的方法</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPartitionSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;        <span class="hljs-keyword">if</span>(low==high)&#123;            <span class="hljs-keyword">return</span> nums[low];        &#125;        <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> left_sum = maxPartitionSum(nums, low, mid);        <span class="hljs-keyword">int</span> right_sum = maxPartitionSum(nums, mid+<span class="hljs-number">1</span>, high);        <span class="hljs-comment">//处理跨越中间的区间    </span>        <span class="hljs-keyword">int</span> mid_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> tmp_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> max_tmp_sum = nums[mid];        <span class="hljs-comment">//处理左半区[0,mid]</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            tmp_sum += nums[i];            max_tmp_sum = max(max_tmp_sum, tmp_sum);        &#125;        mid_sum += max_tmp_sum;        <span class="hljs-comment">//处理右半区[mid+1，high]</span>        tmp_sum = <span class="hljs-number">0</span>;        max_tmp_sum = nums[mid+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=high;i++)&#123;            tmp_sum += nums[i];            max_tmp_sum = max(max_tmp_sum, tmp_sum);        &#125;        mid_sum += max_tmp_sum;        <span class="hljs-keyword">return</span> max(mid_sum, max(left_sum,right_sum));    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//递归 分治 分别求左右子区间的最大和, 跨越中间连接的部分特殊处理.</span>        <span class="hljs-keyword">return</span> maxPartitionSum(nums, <span class="hljs-number">0</span>, nums.size()<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><p>58.<a href="https://leetcode-cn.com/problems/length-of-last-word/">最后一个单词的长度</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len = s.length()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(len&gt;=<span class="hljs-number">0</span> &amp;&amp; s[len]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;                len --;        &#125;        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span> || len == <span class="hljs-number">-1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">while</span>(len&gt;=<span class="hljs-number">0</span> &amp;&amp; s[len]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;            ans ++;            len --;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>66.<a href="https://leetcode-cn.com/problems/plus-one/">加一</a></p><pre><code class="hljs C++"><span class="hljs-comment">//可以考虑拓展为加减乘除</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; digits)</span> </span>&#123;        digits[digits.size()<span class="hljs-number">-1</span>] += <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=digits.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;             <span class="hljs-keyword">int</span> num = digits[i];            <span class="hljs-keyword">if</span>(num/<span class="hljs-number">10</span>!=<span class="hljs-number">0</span>)&#123;                digits[i] = num % <span class="hljs-number">10</span>;                <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span>)&#123;                    digits[i<span class="hljs-number">-1</span>] += num/<span class="hljs-number">10</span>;                 &#125;                <span class="hljs-keyword">else</span> &#123;                    digits.insert(digits.begin(), num/<span class="hljs-number">10</span>);                &#125;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> digits;    &#125;&#125;;</code></pre><p>67.<a href="https://leetcode-cn.com/problems/add-binary/">二进制求和</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span> </span>&#123;        <span class="hljs-built_in">string</span> ans = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//感觉可以直接在a b上操作</span>        <span class="hljs-keyword">int</span> len_a = a.length()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">int</span> len_b = b.length()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">bool</span> carry = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">while</span>(len_a &gt;=<span class="hljs-number">0</span> &amp;&amp; len_b&gt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(a[len_a]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; b[len_b]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<span class="hljs-comment">//1+1</span>                ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : (<span class="hljs-string">&quot;0&quot;</span> + ans);                carry = <span class="hljs-literal">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[len_a]==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; b[len_b]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<span class="hljs-comment">//0+0</span>                ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : (<span class="hljs-string">&quot;0&quot;</span> + ans);                carry = <span class="hljs-literal">false</span>;            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//1+0的11情况</span>                ans = carry ? (<span class="hljs-string">&quot;0&quot;</span> + ans) : (<span class="hljs-string">&quot;1&quot;</span> + ans);                <span class="hljs-comment">//carry do not change.</span>            &#125;            len_a --;            len_b --;        &#125;        <span class="hljs-keyword">while</span>(len_a &gt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(a[len_a]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;                ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : (<span class="hljs-string">&quot;0&quot;</span> + ans);                carry = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                ans = carry ? (<span class="hljs-string">&quot;0&quot;</span> + ans) : (<span class="hljs-string">&quot;1&quot;</span> + ans);                <span class="hljs-comment">//carry do not change.</span>            &#125;            len_a --;        &#125;        <span class="hljs-keyword">while</span>(len_b &gt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(b[len_b]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;                ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : (<span class="hljs-string">&quot;0&quot;</span> + ans);                carry = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                ans = carry ? (<span class="hljs-string">&quot;0&quot;</span> + ans) : (<span class="hljs-string">&quot;1&quot;</span> + ans);                <span class="hljs-comment">//carry do not change.</span>            &#125;            len_b --;        &#125;        ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : ans ;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><pre><code class="hljs python">//转化成数字看看就好hhh<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addBinary</span>(<span class="hljs-params">self, a, b</span>) -&gt; str:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;0:b&#125;&#x27;</span>.format(int(a, <span class="hljs-number">2</span>) + int(b, <span class="hljs-number">2</span>))</code></pre><pre><code class="hljs Python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">精妙的位运算方法</span><span class="hljs-string">A  B  ^  &amp;  +</span><span class="hljs-string">0  0  0  0  0+0=00</span><span class="hljs-string">0  1  1  0  0+1=01</span><span class="hljs-string">1  0  1  0  1+0=01</span><span class="hljs-string">1  1  0  1  1+1=10</span><span class="hljs-string">统一先计算^这样没有进位，然后统一把进位求出来，加进去。 这样可能还会有进位，所以就继续循环，直到没有进位。</span><span class="hljs-string">&#x27;&#x27;&#x27;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addBinary</span>(<span class="hljs-params">self, a, b</span>) -&gt; str:</span>        x, y = int(a, <span class="hljs-number">2</span>), int(b, <span class="hljs-number">2</span>)        <span class="hljs-keyword">while</span> y:            answer = x ^ y            carry = (x &amp; y) &lt;&lt; <span class="hljs-number">1</span>            x, y = answer, carry        <span class="hljs-keyword">return</span> bin(x)[<span class="hljs-number">2</span>:]</code></pre><p>69.<a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//lower bound,二分给出的解是首个大于等于根号x的整数</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = x;        <span class="hljs-keyword">while</span>(l &lt; r)&#123;             <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>( (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) mid*mid &gt;= x)&#123; <span class="hljs-comment">//这里防止溢出</span>                r = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                l = mid + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-built_in">cout</span>&lt;&lt; l  &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-comment">//此处的二分法在[a,b)求得的结果为首个不小于sqrt(x)的整数</span>        <span class="hljs-comment">//可能解刚好是a,也可能是大于sqrt(x),所以最后需要判断一下。</span>        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) l*l &gt; x) ? l<span class="hljs-number">-1</span> : l;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//upper bound 二分给出的解是首个大于根号x的整数</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = x;        <span class="hljs-keyword">while</span>(l &lt; r)&#123;             <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>( (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) mid*mid &gt; x)&#123; <span class="hljs-comment">//这里防止溢出</span>                r = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                l = mid + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-built_in">cout</span>&lt;&lt; l  &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-comment">//此处的二分法在[a,b)求得的结果为首个大于sqrt(x)的整数</span>        <span class="hljs-comment">//可能解a一定大于正确解(0,1除外)sqrt(x),所以最后需要减去1,判特例</span>        <span class="hljs-keyword">return</span> (x == <span class="hljs-number">0</span> || x == <span class="hljs-number">1</span>) ? x : l<span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//试一下牛顿迭代法！！！ x_&#123;n+1&#125; = x_n - f(x_n)/f^&#x27;(x_n) </span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">double</span> xi = x, C = x; <span class="hljs-comment">//为什么float不行</span>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">double</span> xj = <span class="hljs-number">0.5</span>*(xi + C/xi);            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(xj - xi) &lt; <span class="hljs-number">1e-6</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;            xi = xj;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(xi);    &#125;&#125;;</code></pre><p>70.爬楼梯</p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/shu-xue-zuo-fa-jie-bu-ding-fang-cheng-pai-lie-zu-h/">我的傻瓜题解</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//一开始想到的方法</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">//这个方法不是本题最优解，但是学习到了如何求组合数字</span>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>&#123;         <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;            tmp = tmp*(n-m+i)/i;        &#125;        <span class="hljs-keyword">return</span> tmp;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;=n;x++)&#123;            <span class="hljs-keyword">int</span> y = (n - x) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(n == x + <span class="hljs-number">2</span>*y)&#123;                cnt += C(y,x+y);            &#125;        &#125;        <span class="hljs-keyword">return</span> cnt;    &#125;&#125;;</code></pre><p>动态规划常常适用于有<strong>重叠子问题和最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p><p>动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//动态规划</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;            dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//矩阵快速幂</span>以后再说</code></pre><p>83.删除排序链表中的重复元素</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode *next;</span><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        ListNode* p = head; <span class="hljs-comment">//慢指针</span>        ListNode* q = head-&gt;next; <span class="hljs-comment">//快指针</span>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">nullptr</span> &amp;&amp; q!=<span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">if</span>(p-&gt;val == q-&gt;val)&#123;                p-&gt;next = q-&gt;next;                ListNode* del = q;                q = q-&gt;next;                <span class="hljs-keyword">delete</span> del;            &#125;<span class="hljs-keyword">else</span>&#123;                p = p-&gt;next;                q = q-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode *next;</span><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//尝试使用直接删除法</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        ListNode* p = head;        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">if</span>(p-&gt;val==p-&gt;next-&gt;val)&#123;                ListNode* del = p-&gt;next;                p-&gt;next = p-&gt;next-&gt;next;                <span class="hljs-keyword">delete</span> del;            &#125;<span class="hljs-keyword">else</span>&#123;                p = p-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;&#125;;</code></pre><p>88.<a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a> ★</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//这题的特殊之处在于可反向考虑减少数组元素的移动</span><span class="hljs-comment">//总数m+n从后往前一定不会覆盖未排序的nums1元素</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> tal = m + n - <span class="hljs-number">1</span>;        m --;        n --;        <span class="hljs-keyword">while</span>(m&gt;=<span class="hljs-number">0</span> &amp;&amp; n&gt;=<span class="hljs-number">0</span>)&#123;            nums1[tal--] = (nums1[m] &gt;= nums2[n]) ? nums1[m--] : nums2[n--];        &#125;        <span class="hljs-keyword">while</span>(n&gt;=<span class="hljs-number">0</span>)&#123;            nums1[tal--] = nums2[n--];        &#125;    &#125;&#125;;</code></pre><p>100.<a href="https://leetcode-cn.com/problems/same-tree/">相同的树</a> ★</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> &amp;&amp; q==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span>((p!=<span class="hljs-literal">NULL</span>&amp;&amp;q==<span class="hljs-literal">NULL</span>) || (p==<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>) || (p-&gt;val!=q-&gt;val))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//递归地判断左右子树</span>        <span class="hljs-keyword">return</span> isSameTree(p-&gt;left, q-&gt;left)&amp;&amp;isSameTree(p-&gt;right, q-&gt;right);            &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">checkNode</span><span class="hljs-params">(TreeNode *p, TreeNode* q)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> &amp;&amp; q==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>((p!=<span class="hljs-literal">NULL</span>&amp;&amp;q==<span class="hljs-literal">NULL</span>) || (p==<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>) || (p-&gt;val!=q-&gt;val))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;        que.push(p);        que.push(q);<span class="hljs-comment">//可以只用一个队列来存储两个结点</span>        <span class="hljs-comment">//BFS</span>        <span class="hljs-keyword">while</span>(!que.empty())&#123;            TreeNode* r = que.front();<span class="hljs-comment">//由于只使用了一个队列，需要注意存取顺序对应</span>            que.pop();            TreeNode* s = que.front();            que.pop();            <span class="hljs-keyword">switch</span>(checkNode(r,s))&#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                    que.push(r-&gt;left);                    que.push(s-&gt;left);                    que.push(r-&gt;right);                    que.push(s-&gt;right);                <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre><p>101.<a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//本质上与上一题相同</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> &amp;&amp; q==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> || q==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(p-&gt;val!=q-&gt;val)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> check(p-&gt;left,q-&gt;right)&amp;&amp;check(p-&gt;right,q-&gt;left);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> check(root-&gt;left, root-&gt;right);    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">return</span> check(root, root);    &#125;&#125;;</code></pre><p>104.<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p><p>递归形式的DFS</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//首先想到的方法是DFS的递归写法</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calDepth</span><span class="hljs-params">(TreeNode* p, <span class="hljs-keyword">int</span> depth)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> depth;        &#125;        <span class="hljs-keyword">return</span> max(calDepth(p-&gt;left,depth+<span class="hljs-number">1</span>),calDepth(p-&gt;right,depth+<span class="hljs-number">1</span>));            &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">return</span> calDepth(root,<span class="hljs-number">0</span>);     &#125;&#125;;</code></pre><p>非递归DFS</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">stack</span>&lt; <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; &gt; st;        st.push(<span class="hljs-built_in">make_pair</span>(root,<span class="hljs-number">0</span>));        <span class="hljs-keyword">int</span> max_depth = <span class="hljs-number">0</span>;<span class="hljs-comment">//默认设置为0,根节点空</span>        <span class="hljs-keyword">while</span>(!st.empty())&#123;            <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; t = st.top();            st.pop();            TreeNode* p = t.first;            <span class="hljs-keyword">int</span> depth = t.second;            <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;                max_depth = max(max_depth, depth+<span class="hljs-number">1</span>);                st.push(<span class="hljs-built_in">make_pair</span>(p-&gt;right, depth+<span class="hljs-number">1</span>));                st.push(<span class="hljs-built_in">make_pair</span>(p-&gt;left, depth+<span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-keyword">return</span> max_depth;     &#125;&#125;;</code></pre><p>BFS</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;        que.push(root);        <span class="hljs-keyword">while</span>(!que.empty())&#123;            depth ++; <span class="hljs-comment">//能进入循环说明当前队列中保存了新的一层</span>            <span class="hljs-keyword">int</span> size = que.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;                TreeNode* p = que.front();                que.pop();                <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;left);                &#125;                <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;right);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> depth;     &#125;&#125;;</code></pre><p>107.<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">二叉树的层次遍历 II</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;            que.push(root);            <span class="hljs-keyword">while</span>(!que.empty())&#123;                <span class="hljs-keyword">int</span> size = que.size();                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;                    TreeNode* p = que.front();                    que.pop();                    tmp.push_back(p-&gt;val);                    <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                        que.push(p-&gt;left);                    &#125;                    <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                        que.push(p-&gt;right);                    &#125;                &#125;                ans.push_back(tmp);            &#125;            reverse(ans.begin(),ans.end());        &#125;             <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>108.<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a> ★</p><p>有意思的题目，首先想到的分治法求解</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//分治 递归</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">buildBST</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(l==r)&#123;            TreeNode* p = <span class="hljs-keyword">new</span> TreeNode(nums[l]);            <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-keyword">if</span>(l&gt;r)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;         TreeNode* parent = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);        parent-&gt;left = buildBST(nums,l,mid<span class="hljs-number">-1</span>);        parent-&gt;right = buildBST(nums,mid+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">return</span> parent;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> buildBST(nums,<span class="hljs-number">0</span>,nums.size()<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//有没有其他写法明天再看</span></code></pre><p>110.<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a> ★</p><p>这个版本写得非常之垃圾，最初的思路留在这里，纪念一下愚蠢的思路。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHeightandCheck</span><span class="hljs-params">(TreeNode* p, <span class="hljs-keyword">bool</span> &amp;flag)</span></span>&#123;        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left_height = getHeightandCheck(p-&gt;left,flag);        <span class="hljs-keyword">int</span> right_height = getHeightandCheck(p-&gt;right,flag);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left_height-right_height)&gt;<span class="hljs-number">1</span>)&#123;            flag = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> max(left_height, right_height) + <span class="hljs-number">1</span>;    &#125;     <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-comment">//if(root == NULL)&#123;</span>        <span class="hljs-comment">//    return true;</span>        <span class="hljs-comment">//&#125; </span>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;        getHeightandCheck(root,flag);        <span class="hljs-keyword">return</span> flag;    &#125;&#125;;</code></pre><p>自顶向下分别判断每个结点的左右子树高度，但是这一方法时间复杂度为<span class="math inline">\(o(nlogn)\)</span></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* p)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> max(height(p-&gt;left),height(p-&gt;right)) + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right)                &amp;&amp; (<span class="hljs-built_in">abs</span>(height(root-&gt;left) - height(root-&gt;right)) &lt;=<span class="hljs-number">1</span> );    &#125;&#125;;</code></pre><p>111.<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></p><p>最先想到的方法是BFS，遇到的首个叶子节点（左右孩子空）的深度。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;        que.push(root);         <span class="hljs-keyword">int</span> min_depth = <span class="hljs-number">0</span>;        <span class="hljs-keyword">bool</span> flag_leaf = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">while</span>(!que.empty())&#123;            min_depth ++;            <span class="hljs-keyword">int</span> size = que.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;                TreeNode* p = que.front();                que.pop();                <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right==<span class="hljs-literal">NULL</span>)&#123;                    flag_leaf = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;<span class="hljs-comment">//这个if特殊判断当前结点是否是根结点，[1,2]的最小深度为2</span>                <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;left);                &#125;                <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;right);                &#125;            &#125;            <span class="hljs-keyword">if</span>(flag_leaf)&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> min_depth;    &#125;&#125;;</code></pre><p>这个题目还可以使用DFS（递归）的方式。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//特例，根为空</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">NULL</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//特例，仅根</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> min_depth = <span class="hljs-number">0x3f3f3f3f</span>;        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;            min_depth = min(min_depth, minDepth(root-&gt;left));        &#125;        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;            min_depth = min(min_depth, minDepth(root-&gt;right));        &#125;        <span class="hljs-keyword">return</span> min_depth + <span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><p>比较闲，再写一遍DFS的非递归方式。</p><pre><code class="hljs C++"><span class="hljs-comment">//25号再写</span></code></pre><p>112.<a href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></p><p>递归的DFS。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> sum - root-&gt;val == <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val)                 || hasPathSum(root-&gt;right, sum - root-&gt;val);    &#125;&#125;;</code></pre><p>BFS，有正负应该怎么剪枝呢？</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-built_in">queue</span>&lt; <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; &gt; que;        que.push(<span class="hljs-built_in">make_pair</span>(root,<span class="hljs-number">0</span>));        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-keyword">int</span> size = que.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;                <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; hp = que.front();                que.pop();                TreeNode* p = hp.first;                <span class="hljs-keyword">int</span> tmp_sum = hp.second + p-&gt;val;                <span class="hljs-keyword">if</span>(tmp_sum==sum &amp;&amp; p-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right==<span class="hljs-literal">NULL</span>)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;                <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;left, tmp_sum));                &#125;                <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;right, tmp_sum));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><p>257.<a href="https://leetcode-cn.com/problems/binary-tree-paths/">二叉树的所有路径</a></p><p>顺其自然DFS递归实现。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; ans;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* p, <span class="hljs-built_in">string</span> path)</span></span>&#123;        <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right==<span class="hljs-literal">NULL</span>)&#123;            ans.push_back(path + to_string(p-&gt;val));          &#125;        <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;            DFS(p-&gt;left,path + to_string(p-&gt;val) + <span class="hljs-string">&quot;-&gt;&quot;</span>);        &#125;        <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;            DFS(p-&gt;right,path + to_string(p-&gt;val) + <span class="hljs-string">&quot;-&gt;&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> ans;        &#125;        DFS(root, <span class="hljs-string">&quot;&quot;</span>);        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>559.<a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">N叉树的最大深度</a></p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        children = _children;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> size = root-&gt;children.size();        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//没有孩子结点，说明当前root是叶子结点，返回深度1</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> max_depth = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;            max_depth = max(max_depth, maxDepth(root-&gt;children[i]));        &#125;        <span class="hljs-keyword">return</span> max_depth + <span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><p>690.<a href="https://leetcode-cn.com/problems/employee-importance/">员工的重要性</a></p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for Employee.</span><span class="hljs-comment">class Employee &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int id;</span><span class="hljs-comment">    int importance;</span><span class="hljs-comment">    vector&lt;int&gt; subordinates;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, Employee*&gt; mp;    <span class="hljs-comment">// bool cmp(const Employee* a, const ) //不需要排序？</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;        Employee* ee = mp[id];        <span class="hljs-keyword">int</span> ans = ee-&gt;importance;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ee-&gt;subordinates.size();i++)&#123;            ans += DFS(ee-&gt;subordinates[i]);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Employee*&gt; employees, <span class="hljs-keyword">int</span> id)</span> </span>&#123;          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;employees.size();i++)&#123;<span class="hljs-comment">//快速查询员工，原始输入并非有序</span>            mp.emplace(employees[i]-&gt;id, employees[i]);        &#125;        <span class="hljs-keyword">return</span> DFS(id);    &#125;&#125;;</code></pre><p>BFS写一遍。</p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for Employee.</span><span class="hljs-comment">class Employee &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int id;</span><span class="hljs-comment">    int importance;</span><span class="hljs-comment">    vector&lt;int&gt; subordinates;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Employee*&gt; employees, <span class="hljs-keyword">int</span> id)</span> </span>&#123;         <span class="hljs-keyword">if</span>(employees.empty())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> size = employees.size();        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, Employee*&gt; mp;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;            mp.emplace(employees[i]-&gt;id, employees[i]);        &#125;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que;        que.push(id);        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-keyword">int</span> que_size = que.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;que_size;i++)&#123;                <span class="hljs-keyword">int</span> e = que.front();                que.pop();                ans += mp[e]-&gt;importance;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ee : mp[e]-&gt;subordinates)&#123;                    <span class="hljs-comment">//一个员工最多有一个直系领导，不需要visitedz数组标记</span>                    que.push(ee);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>733.<a href="https://leetcode-cn.com/problems/flood-fill/">图像渲染</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">bool</span> visited[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>] = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; image, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> old_color, <span class="hljs-keyword">int</span> new_color)</span></span>&#123;        <span class="hljs-keyword">if</span>((<span class="hljs-number">0</span>&lt;=r &amp;&amp; r&lt;image.size()) &amp;&amp; (<span class="hljs-number">0</span>&lt;=c &amp;&amp; c&lt;image[<span class="hljs-number">0</span>].size()) &amp;&amp; !visited[r][c])&#123;            visited[r][c] = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(image[r][c]==old_color)&#123;                image[r][c] = new_color;                DFS(image, r+<span class="hljs-number">1</span>,c, old_color, new_color);                DFS(image, r<span class="hljs-number">-1</span>,c, old_color, new_color);                DFS(image, r,c+<span class="hljs-number">1</span>, old_color, new_color);                DFS(image, r,c<span class="hljs-number">-1</span>, old_color, new_color);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">floodFill</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; image, <span class="hljs-keyword">int</span> sr, <span class="hljs-keyword">int</span> sc, <span class="hljs-keyword">int</span> newColor)</span> </span>&#123;        <span class="hljs-comment">// DFS(image, sr, sc, image[sr][sc], newColor);</span>        <span class="hljs-comment">// BFS</span>        <span class="hljs-built_in">queue</span>&lt; <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; que;        que.push(<span class="hljs-built_in">make_pair</span>(sr,sc));        <span class="hljs-keyword">int</span> scolor = image[sr][sc];        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pos = que.front();            <span class="hljs-keyword">int</span> r = pos.first;            <span class="hljs-keyword">int</span> c = pos.second;            que.pop();            <span class="hljs-keyword">if</span>((<span class="hljs-number">0</span>&lt;=r &amp;&amp; r&lt;image.size()) &amp;&amp; (<span class="hljs-number">0</span>&lt;=c &amp;&amp; c&lt;image[<span class="hljs-number">0</span>].size()) &amp;&amp; !visited[r][c])&#123;                visited[r][c] = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span>(image[r][c]==scolor)&#123;                    image[r][c] = newColor;                    que.push(<span class="hljs-built_in">make_pair</span>(r+<span class="hljs-number">1</span>,c));                    que.push(<span class="hljs-built_in">make_pair</span>(r<span class="hljs-number">-1</span>,c));                    que.push(<span class="hljs-built_in">make_pair</span>(r,c+<span class="hljs-number">1</span>));                    que.push(<span class="hljs-built_in">make_pair</span>(r,c<span class="hljs-number">-1</span>));                &#125;            &#125;                    &#125;        <span class="hljs-keyword">return</span> image;    &#125;&#125;;</code></pre><p>872.<a href="https://leetcode-cn.com/problems/leaf-similar-trees/">叶子相似的树</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; leafs)</span></span>&#123;        <span class="hljs-keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)&#123;             leafs.push_back(p-&gt;val);        &#125;        <span class="hljs-keyword">if</span>(p-&gt;left)&#123;            DFS(p-&gt;left, leafs);        &#125;        <span class="hljs-keyword">if</span>(p-&gt;right)&#123;            DFS(p-&gt;right, leafs);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!root1 &amp;&amp; !root2)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>(!root1 || !root2)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; leafs1;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; leafs2;        DFS(root1,leafs1);        DFS(root2,leafs2);        <span class="hljs-comment">// if(leafs1.size()!=leafs2.size())&#123;</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// for(int i=0;i&lt;leafs1.size();i++)&#123;</span>        <span class="hljs-comment">//     if(leafs1[i]!=leafs2[i])&#123;</span>        <span class="hljs-comment">//         return false;</span>        <span class="hljs-comment">//     &#125;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">/*如果vector是内置类型的数据,如int, char等,直接用v1 == v2来判断,</span><span class="hljs-comment">          但是如果用了自定义类型的话,那么首先要实现该类型的operator==函数,</span><span class="hljs-comment">          也就是重载等于判断.</span><span class="hljs-comment">        */</span>        <span class="hljs-keyword">return</span> leafs1==leafs2;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//官方题解速度更快欸</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; leaves)</span></span>&#123;        <span class="hljs-keyword">if</span>(!p)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归的结束条件可以学习一下</span>        <span class="hljs-keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)&#123;             leaves.push_back(p-&gt;val);        &#125;        DFS(p-&gt;left, leaves);        DFS(p-&gt;right, leaves);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; leaves1;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; leaves2;        DFS(root1,leaves1);        DFS(root2,leaves2);        <span class="hljs-keyword">return</span> leaves1==leaves2;    &#125;&#125;;</code></pre><p>897.<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">递增顺序查找树</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nodes)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        DFS(p-&gt;left,nodes);        nodes.push_back(p-&gt;val);        DFS(p-&gt;right,nodes);    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nodes)</span></span>&#123;        <span class="hljs-keyword">if</span>(nodes.empty())<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">int</span> size = nodes.size();        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(nodes[<span class="hljs-number">0</span>]);        TreeNode* pre = root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;            TreeNode* p = <span class="hljs-keyword">new</span> TreeNode(nodes[i]);            pre-&gt;right = p;            pre = p;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nodes;        DFS(root,nodes);        <span class="hljs-keyword">return</span> buildTree(nodes);    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode专题 树</title>
    <link href="/2020/07/15/2020-08-01-%E5%8A%9B%E6%89%A3-%E6%A0%91/"/>
    <url>/2020/07/15/2020-08-01-%E5%8A%9B%E6%89%A3-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode专题-树">LeetCode专题 树</h2><p>226.<a href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></p><p>只需要遍历到每一个结点即可，然后交换左右两个孩子结点。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        &#125;        TreeNode* tmp = invertTree(root-&gt;left);        root-&gt;left = invertTree(root-&gt;right);        root-&gt;right = tmp;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p>235.<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a> ★★★</p><p>LCA最近公共祖先，有点意思，第一次写的超级垃圾的代码108ms，103.5MB。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;TreeNode*&gt;&gt; helper;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root,<span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; path,TreeNode* target)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        path.push_back(root);        <span class="hljs-keyword">if</span>(root==target)&#123;            helper.push_back(path);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;            DFS(root-&gt;left,path,target);        &#125;        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;            DFS(root-&gt;right,path,target);        &#125;       &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; path_p;        DFS(root,path_p,p);        DFS(root,path_p,q);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;helper[<span class="hljs-number">0</span>].size()&amp;&amp;j&lt;helper[<span class="hljs-number">1</span>].size())&#123;            <span class="hljs-built_in">cout</span>&lt;&lt;helper[<span class="hljs-number">0</span>][i]-&gt;val&lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt;helper[<span class="hljs-number">1</span>][j]-&gt;val&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">if</span>(helper[<span class="hljs-number">0</span>][i]==helper[<span class="hljs-number">1</span>][j])&#123;                i++,j++;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> helper[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre><ul><li><p><strong>二叉搜索树BST的性质</strong></p><ol type="a"><li>节点 N 左子树上的所有节点的值都小于等于节点 N 的值</li><li>节点 N 右子树上的所有节点的值都大于等于节点 N 的值</li><li>子树和右子树也都是 BST</li></ol></li><li><p><strong>算法</strong></p><ol type="a"><li>从根节点开始遍历树</li><li>如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 (a) 的操作</li><li>如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 (a) 的操作</li><li>如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 LCA 了</li></ol></li><li><p>在左右子树上，则root.val - p.val和root.val - q.val异号</p><p>同在左/右子树，则同号，分别递归地遍历左/右子树</p><p>该算法得到的性能是36ms，23.5MB</p></li></ul><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    TreeNode* lca = <span class="hljs-literal">NULL</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCA</span><span class="hljs-params">(TreeNode* root, TreeNode*p, TreeNode* q)</span></span>&#123;        <span class="hljs-keyword">if</span>((root-&gt;val - p-&gt;val)*(root-&gt;val - q-&gt;val) &lt;= <span class="hljs-number">0</span>)&#123;            lca = root;<span class="hljs-comment">//如果p,q分别再左右子树上，则root就是lca</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)&#123;            LCA(root-&gt;right, p, q);        &#125;<span class="hljs-keyword">else</span>&#123;            LCA(root-&gt;left, p, q);        &#125;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-comment">// 题目的意思是树不空</span>        <span class="hljs-comment">// if (!root) return nullptr;</span>        LCA(root, p, q);        <span class="hljs-keyword">return</span> lca;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">if</span>(q -&gt; val &gt; root -&gt; val &amp;&amp; p -&gt; val &gt; root -&gt; val)                <span class="hljs-keyword">return</span> lowestCommonAncestor(root -&gt; right, p, q);<span class="hljs-comment">// 都在root的右边</span>        <span class="hljs-keyword">if</span>(q -&gt; val &lt; root -&gt; val &amp;&amp; p -&gt; val &lt; root -&gt; val)                <span class="hljs-keyword">return</span> lowestCommonAncestor(root -&gt; left, p, q); <span class="hljs-comment">// 都在root的左边</span>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 若分布在root的两侧，说明root为最近公共祖先</span>    &#125;&#125;;</code></pre><ul><li><p><strong>进阶： 二叉树 - 无左小右大的性质，需要全盘搜索</strong></p><ol type="a"><li>遇到指定节点，直接返回root，无需往下搜寻。</li><li>向左右子树遍历，返回包含指定节点的子树。</li><li>若左右子树都包含指定节点，则当前root为最近公共祖先。</li></ol><p>自底向上遍历结点，一旦遇到结点等于p或者q，则将其向上传递给它的父结点。父结点会判断它的左右子树是否都包含其中一个结点，如果是，则父结点一定是这两个节点p和q的LCA，传递父结点到root。如果不是，我们向上传递其中的包含结点p或者q的子结点，或者NULL(如果子结点不包含任何一个)。该方法时间复杂度为O(N)。</p></li></ul><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!root || root == p || root == q ) <span class="hljs-keyword">return</span> root;        <span class="hljs-comment">// ↓ l(r)=NULL,左(右)子树不包含p或q;l(r)=p或q,左(右)子树包含有p或q</span>        TreeNode* l = lowestCommonAncestor(root -&gt; left, p , q);        TreeNode* r = lowestCommonAncestor(root -&gt; right, p, q);        <span class="hljs-keyword">if</span>(l &amp;&amp; r) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 如果p和q位于不同的子树,根即为LCA</span>        <span class="hljs-keyword">return</span> l ? l : r;         <span class="hljs-comment">// ↑ p和q在当前以root为根的相同的子树中(即左右子树)</span>    &#125;&#125;;</code></pre><p>404.<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和</a></p><ul><li>算法思路 对任意一个节点，它只需要做两件事； 1、判断它的左孩子是不是左叶子； 2、让它的左孩子和右孩子分别向它汇报，以该孩子为根的sumOfLeftLeaves； 最后简单相加即可，很典型的递归算法。</li></ul><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment">* Definition for a binary tree node.</span><span class="hljs-comment">* struct TreeNode &#123;</span><span class="hljs-comment">*     int val;</span><span class="hljs-comment">*     TreeNode *left;</span><span class="hljs-comment">*     TreeNode *right;</span><span class="hljs-comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">* &#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">if</span>(root-&gt;left-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right==<span class="hljs-literal">NULL</span>)&#123;                left_sum += root-&gt;left-&gt;val;<span class="hljs-comment">//root-&gt;left是左叶子结点</span>            &#125; <span class="hljs-keyword">else</span> &#123;                left_sum += sumOfLeftLeaves(root-&gt;left);            &#125;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;            left_sum += sumOfLeftLeaves(root-&gt;right);        &#125;        <span class="hljs-keyword">return</span> left_sum;    &#125;&#125;;</code></pre><p>我的想法是BFS标记左叶子，但是很慢，开销也大</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">queue</span>&lt; <span class="hljs-built_in">pair</span>&lt;TreeNode* , <span class="hljs-keyword">int</span>&gt; &gt; que;        que.push(<span class="hljs-built_in">make_pair</span>(root,<span class="hljs-number">-1</span>));<span class="hljs-comment">//0左1右，root默认为-1</span>        <span class="hljs-keyword">int</span> left_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; hp = que.front();            que.pop();            TreeNode* p = hp.first;            <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right==<span class="hljs-literal">NULL</span> &amp;&amp; hp.second==<span class="hljs-number">0</span>)&#123;                left_sum += p-&gt;val;            &#125;            <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;left,<span class="hljs-number">0</span>));            &#125;            <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;right,<span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-keyword">return</span> left_sum;    &#125;&#125;;</code></pre><p>501.<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数</a></p><p>不使用额外空间的方法（递归的隐式栈开销忽略不计），和一开始想的方式很类似，但是用递归的方式实现。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span> <span class="hljs-comment">//前序遍历(Preorder transversal),中序遍历(Inorder transversal)以及后序遍历(Postorder transversal)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        Inorder(root);        <span class="hljs-keyword">return</span> ans;    &#125;<span class="hljs-comment">// void Inorder(TreeNode* root,TreeNode*&amp; pre)引用传递</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-comment">// 这里我犯了一个错误，pre必须是全局的pre，</span>        <span class="hljs-comment">// 要按照引用传递或者设置全局变量，否则回溯的时候pre不会更新</span>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        Inorder(root-&gt;left);        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;val==pre-&gt;val)&#123;            cur_cnt ++;        &#125;<span class="hljs-keyword">else</span>&#123;            cur_cnt = <span class="hljs-number">1</span>;        &#125;                <span class="hljs-keyword">if</span>(max_cnt &lt; cur_cnt)&#123;               max_cnt = cur_cnt;            ans.clear();            ans.push_back(root-&gt;val);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max_cnt==cur_cnt)&#123;            ans.push_back(root-&gt;val);        &#125;        pre = root;        Inorder(root-&gt;right);    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;    <span class="hljs-keyword">int</span> max_cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> cur_cnt = <span class="hljs-number">1</span>;    TreeNode* pre = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//记录中序遍历过程中当前结点的前驱结点</span>&#125;;</code></pre><p>这个开销太大了，是最直接的做法，即原问题等价于求一个单调不减数列的众数。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span> <span class="hljs-comment">//前序遍历(Preorder transversal),中序遍历(Inorder transversal)以及后序遍历(Postorder transversal)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        DFS(root-&gt;left);        inorder.push_back(root-&gt;val);        DFS(root-&gt;right);    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        DFS(root);        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-keyword">int</span> max_cnt = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> size = inorder.size();        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ans;        <span class="hljs-keyword">int</span> pre_val=inorder[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;            <span class="hljs-keyword">if</span>(i&lt;size &amp;&amp; inorder[i]==inorder[i<span class="hljs-number">-1</span>])&#123;                cnt ++;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(max_cnt &lt; cnt)&#123;                    max_cnt = cnt;                    ans.clear();                    ans.push_back(inorder[i<span class="hljs-number">-1</span>]);                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max_cnt==cnt)&#123;                    ans.push_back(inorder[i<span class="hljs-number">-1</span>]);                &#125;                cnt = <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>530.<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">二叉搜索树的最小绝对差</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        getMin(root);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMin</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;        getMin(root-&gt;left);        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;val - pre-&gt;val &lt; ans)&#123;            ans = root-&gt;val - pre-&gt;val;        &#125;        pre = root;        getMin(root-&gt;right);    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-keyword">int</span> ans = INF;    TreeNode* pre = <span class="hljs-literal">NULL</span>;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; prev, <span class="hljs-keyword">int</span>&amp; res)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        dfs(root-&gt;left, prev, res);        <span class="hljs-keyword">if</span> (prev &gt;= <span class="hljs-number">0</span>) res = min(res, root-&gt;val - prev);        prev = root-&gt;val;        dfs(root-&gt;right, prev, res);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">int</span> prev = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">int</span> res = INT_MAX;        dfs(root, prev, res);        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><ul><li><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/solution/zhong-xu-bian-li-tuan-mie-xi-lie-er-cha-sou-suo-sh/">二叉搜索树的绝杀方式</a></li></ul><p>538.<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a></p><p>aha，一次AC，核心还是"中序遍历"，只不过该问需要从最右结点开始反向中序遍历，利用BST的特性（见235.LCA）当前结点的值加上大于当前结点"右侧"结点的值（右边的一定大）。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        buildGT(root);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildGT</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        buildGT(root-&gt;right);        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span>)&#123;            root-&gt;val += pre-&gt;val;        &#125;        pre = root;        buildGT(root-&gt;left);    &#125;<span class="hljs-keyword">private</span>:    TreeNode* pre = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//记录反向中序遍历的&quot;前驱&quot;结点</span>&#125;;</code></pre><p>543.<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">二叉树的直径</a></p><p>数的直径即求两节点间最大距离，即转化可递归解决的问题：</p><p>1、不经过root，最长路径子在左子树上</p><p>2、不经过root，最长路径子在右子树上</p><p>3、经过root，最长路径为左右子树的最大高度之和。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        maxDepth(root);        <span class="hljs-keyword">return</span> max_diameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> dL = maxDepth(root-&gt;left);        <span class="hljs-keyword">int</span> dR = maxDepth(root-&gt;right);        max_diameter = max(max_diameter, dL+dR);        <span class="hljs-keyword">return</span> max(dL,dR) + <span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> max_diameter = <span class="hljs-number">0</span>;&#125;;</code></pre><p>563.<a href="https://leetcode-cn.com/problems/binary-tree-tilt/">二叉树的坡度</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTilt</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        getSum(root);        <span class="hljs-keyword">return</span> tilt;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> L = getSum(root-&gt;left);        <span class="hljs-keyword">int</span> R = getSum(root-&gt;right);        tilt += <span class="hljs-built_in">abs</span>(L - R);        <span class="hljs-keyword">return</span> L + R + root-&gt;val;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> tilt = <span class="hljs-number">0</span>;&#125;;</code></pre><p>572.<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">另一个树的子树</a> ★★★★</p><p>Donald Trump： Nobody knows SIMPLICITY better than me, noboday.</p><p>官方题解，从暴力搜索匹配到字符串匹配KMP，再到树的hash，着实厉害。</p><p>最简单的匹配方法</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* s, TreeNode* t)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//主树为空时，返回false，避免使用空指针</span>        <span class="hljs-keyword">return</span> isSame(s,t) || isSubtree(s-&gt;left,t) || isSubtree(s-&gt;right,t);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(TreeNode* s, TreeNode* t)</span></span>&#123;        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span> &amp;&amp; t==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span> || t==<span class="hljs-literal">NULL</span> || s-&gt;val!=t-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> isSame(s-&gt;left,t-&gt;left) &amp;&amp; isSame(s-&gt;right,t-&gt;right);    &#125;&#125;;</code></pre><p>589.<a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">N叉树的前序遍历</a></p><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/solution/yi-tao-quan-fa-shua-diao-nge-bian-li-shu-de-wen--3/">树的遍历合集</a></p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        children = _children;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;        traverse(root);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(Node* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        ans.push_back(root-&gt;val);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e : root-&gt;children)&#123;            traverse(e);        &#125;    &#125;&#125;;</code></pre><p>迭代法</p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        children = _children;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-built_in">stack</span>&lt;Node*&gt; st;        <span class="hljs-comment">// if(root==NULL)return ans;</span>        st.push(root);        <span class="hljs-keyword">while</span>(!st.empty())&#123;            Node* p = st.top();            st.pop();            <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;                ans.push_back(p-&gt;val);                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=p-&gt;children.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;                    st.push(p-&gt;children[i]);                &#125;            &#125;          &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>590.<a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">N叉树的后序遍历</a></p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        children = _children;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;        traverse(root);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(Node* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:root-&gt;children)&#123;            traverse(e);        &#125;        ans.push_back(root-&gt;val);    &#125;&#125;;</code></pre><p>606.<a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">根据二叉树创建字符串</a></p><p>题目的意思是子节点需要用<code>()</code>来包裹。举例来说，二叉树<code>[root,left,right]</code>，则转换为<code>root(left)(right)</code>。如果只有<code>left</code>为空节点，则输出<code>root()(right)</code>；如果只有<code>right</code>为空节点则可以忽略右节点的<code>()</code>，输出为<code>root(left)</code>。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">tree2str</span><span class="hljs-params">(TreeNode* t)</span> </span>&#123;        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-built_in">string</span> ans = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-built_in">string</span> L = tree2str(t-&gt;left);        <span class="hljs-built_in">string</span> R = tree2str(t-&gt;right);        <span class="hljs-keyword">if</span>(t-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; t-&gt;right==<span class="hljs-literal">NULL</span>) &#123;            ans = to_string(t-&gt;val);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left!=<span class="hljs-literal">NULL</span> &amp;&amp; t-&gt;right==<span class="hljs-literal">NULL</span>) &#123;            ans = to_string(t-&gt;val) + <span class="hljs-string">&quot;(&quot;</span> + L + <span class="hljs-string">&quot;)&quot;</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            ans = to_string(t-&gt;val) + <span class="hljs-string">&quot;(&quot;</span> + L + <span class="hljs-string">&quot;)&quot;</span> + <span class="hljs-string">&quot;(&quot;</span> + R + <span class="hljs-string">&quot;)&quot;</span>;        &#125;         <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>617.<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a> ★★</p><p><strong>一开始没想到的是孩子为空的时候啥也不用做，直接连接即可。</strong></p><p>我们可以对这两棵树同时进行前序遍历，并将对应的节点进行合并。在遍历时，如果两棵树的当前节点均不为空，我们就将它们的值进行相加，并对它们的左孩子和右孩子进行递归合并；如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;        TreeNode* root = t1 ? t1 : t2;        <span class="hljs-keyword">if</span>(t1&amp;&amp;t2)&#123;            t1-&gt;val += t2-&gt;val;            t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);            t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p>非递归的实现：如果t1和t2非空，则将其val求和并赋值给t1，然后考虑左右孩子，（以左孩为例）如果t1左孩子为空，则将t2的左孩子作为t1的左孩子，如果t1左孩子非空，则将结点入栈/队，两者皆空则无操作（上述，右孩子同理）；如果t1为空，则返回t2（无论t2是否为空，不影响结果），否则返回t1。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;        <span class="hljs-comment">//判断t1空的情况，while循环仅执行一次</span>        TreeNode* root = t1 ? t1 : t2;                <span class="hljs-built_in">queue</span>&lt; <span class="hljs-built_in">pair</span>&lt;TreeNode*,TreeNode*&gt; &gt; que;        que.push(<span class="hljs-built_in">make_pair</span>(t1,t2));        <span class="hljs-keyword">while</span>(!que.empty()) &#123;            <span class="hljs-built_in">pair</span>&lt;TreeNode*,TreeNode*&gt; hp = que.front();            que.pop();            TreeNode* p = hp.first;            TreeNode* q = hp.second;            <span class="hljs-comment">//若t1为空，循环结束；或者p非空而q空，</span>            <span class="hljs-comment">//该情况出现在树t1的左或右孩子非空而树t2与之对应的孩子为空</span>            <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> || q==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;            p-&gt;val += q-&gt;val;            <span class="hljs-comment">//分别判断左右孩子</span>            <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span>) &#123;                p-&gt;left = q-&gt;left;            &#125; <span class="hljs-keyword">else</span> &#123;                que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;left,q-&gt;left));            &#125;            <span class="hljs-keyword">if</span>(p-&gt;right==<span class="hljs-literal">NULL</span>) &#123;                p-&gt;right = q-&gt;right;            &#125; <span class="hljs-keyword">else</span> &#123;                que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;right,q-&gt;right));            &#125;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p>637.<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">二叉树的层平均值</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; ans;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;        que.push(root);        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-keyword">int</span> SIZE = que.size();            <span class="hljs-keyword">double</span> avg = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE;i++)&#123;                TreeNode* p = que.front();                que.pop();                <span class="hljs-comment">// if(p==NULL) continue; //非空二叉树</span>                avg += p-&gt;val;                <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;left);                &#125;                <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;right);                &#125;            &#125;            ans.push_back(avg/SIZE);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>653.<a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">两数之和 IV - 输入 BST</a></p><p>最初的想法是直接返回中序遍历结果，然后问题就转化为1.两数之和。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; in)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;        traverse(root-&gt;left,in);        in.push_back(root-&gt;val);        traverse(root-&gt;right,in);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder;        traverse(root,inorder);        <span class="hljs-keyword">int</span> SIZE = inorder.size();        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE;i++)&#123;            <span class="hljs-keyword">if</span>(mp.count(k - inorder[i])==<span class="hljs-number">1</span>)&#123;                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;            mp.emplace(inorder[i],i);        &#125;        <span class="hljs-keyword">return</span> flag;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        inorder(root);        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> hi = vec.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;            <span class="hljs-keyword">if</span>(vec[lo] + vec[hi] == k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vec[lo] + vec[hi] &lt; k) lo++;            <span class="hljs-keyword">else</span> hi--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> root) <span class="hljs-keyword">return</span>;        inorder(root-&gt;left);        vec.emplace_back(root-&gt;val);        inorder(root-&gt;right);    &#125;&#125;;</code></pre><p>递归，效率不高欸？？？</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(mp.count(k - root-&gt;val)==<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        mp.emplace(root-&gt;val, <span class="hljs-number">1</span>);          <span class="hljs-keyword">return</span> findTarget(root-&gt;right, k) || findTarget(root-&gt;left, k);    &#125;&#125;;</code></pre><p>669.<a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树</a></p><p>递归做法，设当前结点为root：</p><p>如果root-&gt;val小于L，则剪掉左子树和自身，递归处理右子树；如果root-&gt;val大于R，则剪掉右子树和自身，递归处理左子树；若root-&gt;val处在区间之间，则分别递归地处理左右子树。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(root-&gt;val &lt; L) &#123;                root = trimBST(root-&gt;right, L, R);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; R) &#123;                root = trimBST(root-&gt;left, L, R);            &#125; <span class="hljs-keyword">else</span> &#123;                root-&gt;left = trimBST(root-&gt;left, L, R);                root-&gt;right = trimBST(root-&gt;right, L, R);            &#125;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p>671.<a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">二叉树中第二小的节点</a></p><p>最最直接的做法就是遍历一遍，使用map存储遍历结果，然后遍历一遍map寻找最小值。</p><p>上述过程也可以使用额外的一个变量记录，遍历树寻找比root（由题意，root的值一定是最小的）值大的数中最小的一个。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span> || (root-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">NULL</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        mins = root-&gt;val;        getMin2(root);        <span class="hljs-keyword">return</span> ans ;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMin2</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;              <span class="hljs-keyword">if</span>(root-&gt;val &gt; mins)&#123;                <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">-1</span>)                    ans = root-&gt;val;                <span class="hljs-keyword">else</span>                     ans = min(ans,root-&gt;val);            &#125;            getMin2(root-&gt;left);            getMin2(root-&gt;right);        &#125;        &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> mins;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;&#125;;</code></pre><p>也可以这样做：分别求左右子树的最小值， 如果左右子树最小值都大于根节点的值取较小的值。其他情况取左右子树较大的值。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right!=<span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-comment">// 如果当前结点的孩子的值大于当前结点的值，则无需递归遍历，</span>            <span class="hljs-comment">// 因为以该孩子为根的子树最小值即为这个根</span>            <span class="hljs-keyword">int</span> l = root-&gt;left-&gt;val, r = root-&gt;right-&gt;val;            <span class="hljs-keyword">if</span>(root-&gt;val==root-&gt;left-&gt;val)&#123;<span class="hljs-comment">// 只有当孩子值与根相等时，才递归遍历</span>                l = findSecondMinimumValue(root-&gt;left);            &#125;            <span class="hljs-keyword">if</span>(root-&gt;val==root-&gt;right-&gt;val)&#123;                r = findSecondMinimumValue(root-&gt;right);            &#125;            <span class="hljs-comment">// 问题可以转化为求左右子树的最小值</span>            <span class="hljs-keyword">if</span>(l&gt;root-&gt;val &amp;&amp; r&gt;root-&gt;val) &#123;                ans = min(l,r); <span class="hljs-comment">// 如果左右子树最小值都大于根节点的值,取较小的值</span>            &#125;<span class="hljs-keyword">else</span>&#123;                ans = max(l,r); <span class="hljs-comment">// 其他情况取左右子树较大的值</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>687.<a href="https://leetcode-cn.com/problems/longest-univalue-path/">最长同值路径</a> ★★★</p><p>思路：递归的思想，对于某个根节点root，在左子树中，与左子树根节点（root-&gt;left-&gt;val）同值的最大路径长度为L（如果root-&gt;left值与其的左右孩子值都不同，则L=0），同理，右子树记作R。</p><p>类似地，如果root的值与左孩子相同，则路径长度应当为L+1，否则左孩子到root的的路径不符合要求，记作0；右子树同理，记作R+1或0。返回左右子树中的较长路径。</p><p>函数getPath返回的是单侧的最长路径，若该路径穿越根结点，则需要加上左右两条分支路径的长度，所以在递归的过程中使用单独的变量ans记录最大路径的长度（这个长度可能是不经过根结点的单侧路径，也有可能是经过根节点的双分支路径）。</p><p><strong>对于任意一个节点, 如果最长同值路径包含该节点, 那么只可能是两种情况：</strong></p><ol type="i"><li><p>其左右子树中加上该节点后所构成的同值路径中较长的那个继续向父节点回溯构成最长同值路径</p></li><li><p>左右子树加上该节点都在最长同值路径中, 构成了最终的最长同值路径 需要注意因为要求同值, 所以在判断左右子树能构成的同值路径时要加入当前节点的值作为判断依据</p></li></ol><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        getPath(root);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPath</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">int</span> path_len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">int</span> L = getPath(root-&gt;left); <span class="hljs-comment">// 以左孩为根节点的最大路径长度</span>            <span class="hljs-keyword">int</span> R = getPath(root-&gt;right);            <span class="hljs-keyword">int</span> tmp_L = <span class="hljs-number">0</span>, tmp_R = <span class="hljs-number">0</span>; <span class="hljs-comment">// 过当前节点的路径长度，假设与孩子值不等，初始设为0</span>            <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;val == root-&gt;val)&#123;                tmp_L = L + <span class="hljs-number">1</span>;            &#125; <span class="hljs-comment">// 如果与左孩子值相同，path值为L+1</span>            <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right-&gt;val == root-&gt;val)&#123;                tmp_R += R + <span class="hljs-number">1</span>;            &#125; <span class="hljs-comment">// 如果与右孩子值相同，path值为R+1</span>            ans = max(ans, tmp_L + tmp_R); <span class="hljs-comment">// 递归过程中记录最大路径长度</span>            path_len = max(tmp_L,tmp_R);            <span class="hljs-comment">// 若同时和左右孩子值相同，返回较长的路径，继续向上遍历</span>            <span class="hljs-comment">// 如果和左（右）孩子值不等，则路径长度设置为0</span>        &#125;        <span class="hljs-keyword">return</span> path_len;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;&#125;;</code></pre><p>700.<a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        TreeNode* ans = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) &#123;                ans = searchBST(root-&gt;left, val);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) &#123;                ans = searchBST(root-&gt;right, val);            &#125; <span class="hljs-keyword">else</span> &#123;                ans = root;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>783.<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">二叉搜索树节点最小距离</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDiffInBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        traverse(root);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size()<span class="hljs-number">-1</span>;i++)&#123;            ans = min(ans, nums[i+<span class="hljs-number">1</span>] - nums[i]);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            traverse(root-&gt;left);            nums.push_back(root-&gt;val);            traverse(root-&gt;right);        &#125;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;    <span class="hljs-keyword">int</span> ans = INT_MAX;&#125;;</code></pre><p>938.<a href="https://leetcode-cn.com/problems/range-sum-of-bst/">二叉搜索树的范围和</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rangeSumBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(root-&gt;val &lt; L) &#123;                sum = rangeSumBST(root-&gt;right, L, R);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; R) &#123;                sum = rangeSumBST(root-&gt;left, L, R);            &#125; <span class="hljs-keyword">else</span> &#123;                sum = root-&gt;val + rangeSumBST(root-&gt;left, L, R)                         + rangeSumBST(root-&gt;right, L, R);            &#125;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;;</code></pre><p>965.<a href="https://leetcode-cn.com/problems/univalued-binary-tree/">单值二叉树</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUnivalTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        val = root-&gt;val; <span class="hljs-comment">//无需验空</span>        <span class="hljs-keyword">return</span> dfs(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> (root-&gt;val==val) &amp;&amp; dfs(root-&gt;left) &amp;&amp; dfs(root-&gt;right);            &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> val;&#125;;</code></pre><p>993.<a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">二叉树的堂兄弟节点</a></p><p>遍历二叉树，分别记录 x、y 结点的深度和父亲结点。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCousins</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        dfs(root, x, y, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);        <span class="hljs-keyword">return</span> (parx!=pary &amp;&amp; dx==dy);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> d,TreeNode* par)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(root-&gt;val == x)&#123;            parx = par;            dx = d;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;val == y) &#123;            pary = par;            dy = d;        &#125;        dfs(root-&gt;left, x, y, d+<span class="hljs-number">1</span>, root);        dfs(root-&gt;right, x, y, d+<span class="hljs-number">1</span>, root);    &#125;<span class="hljs-keyword">private</span>:    TreeNode* parx = <span class="hljs-literal">nullptr</span>;    TreeNode* pary = <span class="hljs-literal">nullptr</span>;    <span class="hljs-keyword">int</span> dx=<span class="hljs-number">0</span>, dy = <span class="hljs-number">0</span>;&#125;;</code></pre><p>1022.<a href="https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/">从根到叶的二进制数之和</a> ★★☆</p><p>自上而下地遍历二叉树，遇到叶子结点则表示一个"二进制"序列的值已被计算完整，加到ans上；由于自上而下不知道序列的最高位位数，所以上层的结果递归到下一级时需要×2。类似秦九韶算法。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRootToLeaf</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        calculateSum(root, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> ans % M;    &#125;    <span class="hljs-comment">//由于不知道一个序列的高位位数，所以自顶向下计算数值，上一层结果×2后加上当前结点数字</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculateSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            num = (num &lt;&lt; <span class="hljs-number">1</span>) + root-&gt;val;            <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">NULL</span>)&#123;                ans += num; <span class="hljs-comment">//叶子节点，当前路径计算结束，加上这个数字</span>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//非叶子结点继续递归，对上一层的结果×2再加上当前的数字</span>                calculateSum(root-&gt;left, num % M);                calculateSum(root-&gt;right, num % M);            &#125;            &#125;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NumPy入门笔记</title>
    <link href="/2019/10/26/2019-10-26-NumPy%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/10/26/2019-10-26-NumPy%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="numpy学习笔记">Numpy学习笔记</h1><p>序：真的是想到哪里学到哪里，学东西不要管那么多，就当是“量子波动”学习知识，总有一天会成体系。</p><p>2019年10月25日 至 2019年10月28日</p><p># define " <strong>import numpy as np</strong> "</p><hr /><h2 id="简介">简介</h2><p>​ NumPy是Python语言的一个扩充程序库。支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。Numpy内部解除了Python的PIL(全局解释器锁),运算效率极好,是大量机器学习框架的基础库!</p><p>​ NumPy 的前身 Numeric 最早是由 Jim Hugunin 与其它协作者共同开发，2005 年，Travis Oliphant 在 Numeric 中结合了另一个同性质的程序库 Numarray 的特色，并加入了其它扩展而开发了 NumPy。NumPy 为开放源代码并且由许多协作者共同维护开发。</p><hr /><hr /><h2 id="numpy-ndarray对象及常用操作">NumPy Ndarray对象及常用操作</h2><h3 id="基本属性">基本属性</h3><p>​ 这是一个N维数组对象，下标从0开始，且所有元素同类型、同内存大小，主要包含如下属性：</p><ul><li><p>ndarray.ndim</p><p>表示axes(axis复数)/dimensions 描述维度数字</p></li><li><p>ndarray.shape</p><p>返回元组，输出各个维度的大小</p><p>可以使用<code>reshape</code>函数来调整数组的形状</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])b = a.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<span class="hljs-keyword">print</span> (b)</code></pre></li><li><p>ndarray.size</p><p>返回所有元素的个数（各个维度大小的乘积）</p></li><li><p>ndarray.dtype</p><p>返回数据的类型</p><p>​ "&gt;" 若首先取高字节的数据存放在低地址，则是大端法；</p><p>​ "&lt;" 若首先取低字节的数据存放在低地址，则是小端法；</p><ul><li><strong>自定义数据类型</strong></li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npstudent = np.dtype([(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;S20&#x27;</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;i1&#x27;</span>), (<span class="hljs-string">&#x27;marks&#x27;</span>, <span class="hljs-string">&#x27;f4&#x27;</span>)]) a = np.array([(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">50</span>),(<span class="hljs-string">&#x27;xyz&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">75</span>)], dtype = student) print(a)</code></pre></li><li><p>ndarray.itemsize</p><p>返回单个元素的大小（单位字节），等价于ndarray.dtype.itemsize</p></li><li><p>ndarray.data</p><p>一般不使用，这是存放数据的区域</p></li><li><p>其他参见numpy-ref文档</p><p>NumPy数组的维数称为<strong>秩（rank）</strong>，一维数组的秩为 1，二维数组的秩为2，以此类推。</p></li></ul><p>​ 在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量(秩)，就是数组的维数。W</p><p>​ <strong>很多时候可以声明 axis，axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。</strong></p><hr /><h3 id="创建数组">创建数组</h3><ol type="1"><li>使用函数创建新数组</li></ol><p><code>np.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p><p>对应参数解释：<code>object</code>数组或者嵌套数列；<code>dtype</code>元素类型可选；<code>copy</code>对象是否复制可选；<code>order</code>创建数组的样式（C行方向、F列方向、默认A任意方向）；<code>subok</code>默认返回一个与基类同类型的数组；<code>ndim</code>指定生成数组的最小维度。</p><p>还可以使用其他函数：</p><p><a href="https://numpy.org/devdocs/reference/generated/numpy.array.html#numpy.array"><code>array</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros.html#numpy.zeros"><code>zeros</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros_like.html#numpy.zeros_like"><code>zeros_like</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ones.html#numpy.ones"><code>ones</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ones_like.html#numpy.ones_like"><code>ones_like</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.empty.html#numpy.empty"><code>empty</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.empty_like.html#numpy.empty_like"><code>empty_like</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.arange.html#numpy.arange"><code>arange</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.linspace.html#numpy.linspace"><code>linspace</code></a>, <a href="https://numpy.org/devdocs/reference/random/generated/numpy.random.RandomState.rand.html#numpy.random.RandomState.rand"><code>numpy.random.RandomState.rand</code></a>, <a href="https://numpy.org/devdocs/reference/random/generated/numpy.random.RandomState.randn.html#numpy.random.RandomState.randn"><code>numpy.random.RandomState.randn</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfunction.html#numpy.fromfunction"><code>fromfunction</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfile.html#numpy.fromfile"><code>fromfile</code></a></p><ol start="2" type="1"><li>从已有对象创建新数组</li></ol><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><p>a可以接受的参数为列表、列表的元组、元组、元组的元组、元组的列表、多为数组；数据类型可选；存放方式C/F。</p><p><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></p><p>numpy.frombuffer 用于实现动态数组。numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p><p><code>buffer</code>可以是任意对象，会以流的形式读入；<code>dtype</code>返回数组的数据类型可选；<code>count</code>读取的数据数量，默认为-1，读取所有数据；<code>offset</code>读取的起始位置，默认为0。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nps =  <span class="hljs-string">&#x27;Hello World&#x27;</span>a = np.frombuffer(s, dtype =  <span class="hljs-string">&#x27;S1&#x27;</span>)<span class="hljs-keyword">print</span> (a)<span class="hljs-comment"># 输出</span><span class="hljs-comment"># [&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27; &#x27; &#x27;W&#x27; &#x27;o&#x27; &#x27;r&#x27; &#x27;l&#x27; &#x27;d&#x27;]</span></code></pre><p><code>numpy.fromiter(iterable, dtype, count=-1)</code></p><p>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</p><p><code>iterable</code>可迭代对象；<code>dtype</code>返回数组的数据类型；<code>count</code>读取的数据数量，默认为-1，读取所有数据。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment"># 使用 range 函数创建列表对象  </span>list=range(<span class="hljs-number">5</span>)it=iter(list)<span class="hljs-comment"># 使用迭代器创建 ndarray </span>x=np.fromiter(it, dtype=float)print(x)<span class="hljs-comment">#输出</span><span class="hljs-comment"># [0. 1. 2. 3. 4.]</span></code></pre><ol start="3" type="1"><li>使用数值范围创建数组</li></ol><p><code>numpy.arange(start, stop, step, dtype)</code></p><p>numpy.arange 根据 [start,stop)指定的范围，以及 step 设定的步长，生成一个 ndarray对象。</p><p><code>start</code>起始值，默认为0；<code>stop</code>终止值（不包含）；<code>step</code>步长，默认为1；<code>dtype</code>返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</p><p><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p><p>numpy.linspace 函数用于创建一个一维数组，该数组是一个<strong>等差数列</strong>构成的。</p><p><code>start</code>序列的起始值；<code>stop</code>序列的终止值，如果<code>endpoint</code>为true，该值包含于数列中；<code>num</code>要生成的等步长的样本数量，默认为50；<code>endpoint</code>该值为 ture 时，数列中中包含stop值，反之不包含，默认是True；<code>retstep</code>如果为 True 时，生成的数组中会显示间距，反之不显示；<code>dtype</code>ndarray 的数据类型。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa =np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,retstep=<span class="hljs-literal">True</span>)print(a)<span class="hljs-comment"># 拓展例子</span>b =np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>).reshape([<span class="hljs-number">10</span>,<span class="hljs-number">1</span>])print(b)<span class="hljs-comment">#输出</span><span class="hljs-comment"># (array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.]), 1.0)</span></code></pre><p><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><p>numpy.logspace 函数用于创建一个于等比数列，值得注意的是：start和stop是数列的<strong>下标值</strong>，他们的底数是base。</p><p><code>start</code>序列的起始值为：base ** start；<code>stop</code>序列的终止值为：base ** stop，如果endpoint为true，该值包含于数列中；<code>num</code> 要生成的等步长的样本数量，默认为50；<code>endpoint</code>该值为 ture 时，数列中包含stop值，反之不包含，默认是True；<code>base</code>对数 log 的底数；<code>dtype</code>ndarray 的数据类型。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa = np.logspace(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,base=<span class="hljs-number">2</span>)<span class="hljs-keyword">print</span> (a)<span class="hljs-comment"># [  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]</span></code></pre><hr /><h3 id="数据类型">数据类型</h3><table><thead><tr class="header"><th style="text-align: left;">名称</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">bool_</td><td style="text-align: center;">布尔型数据类型（True 或者 False）</td></tr><tr class="even"><td style="text-align: left;">int_</td><td style="text-align: center;">默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td></tr><tr class="odd"><td style="text-align: left;">intc</td><td style="text-align: center;">与 C 的 int 类型一样，一般是 int32 或 int 64</td></tr><tr class="even"><td style="text-align: left;">intp</td><td style="text-align: center;">用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td></tr><tr class="odd"><td style="text-align: left;">int8</td><td style="text-align: center;">字节（-128 to 127）</td></tr><tr class="even"><td style="text-align: left;">int16</td><td style="text-align: center;">整数（-32768 to 32767）</td></tr><tr class="odd"><td style="text-align: left;">int32</td><td style="text-align: center;">整数（-2147483648 to 2147483647）</td></tr><tr class="even"><td style="text-align: left;">int64</td><td style="text-align: center;">整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr class="odd"><td style="text-align: left;">uint8</td><td style="text-align: center;">无符号整数（0 to 255）</td></tr><tr class="even"><td style="text-align: left;">uint16</td><td style="text-align: center;">无符号整数（0 to 65535）</td></tr><tr class="odd"><td style="text-align: left;">uint32</td><td style="text-align: center;">无符号整数（0 to 4294967295）</td></tr><tr class="even"><td style="text-align: left;">uint64</td><td style="text-align: center;">无符号整数（0 to 18446744073709551615）</td></tr><tr class="odd"><td style="text-align: left;">float_</td><td style="text-align: center;">float64 类型的简写</td></tr><tr class="even"><td style="text-align: left;">float16</td><td style="text-align: center;">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr class="odd"><td style="text-align: left;">float32</td><td style="text-align: center;">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr class="even"><td style="text-align: left;">float64</td><td style="text-align: center;">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr class="odd"><td style="text-align: left;">complex_</td><td style="text-align: center;">complex128 类型的简写，即 128 位复数</td></tr><tr class="even"><td style="text-align: left;">complex64</td><td style="text-align: center;">复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr class="odd"><td style="text-align: left;">complex128</td><td style="text-align: center;">复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><hr /><h3 id="类型转换">类型转换</h3><ul><li><p>浮点数据转换</p><p>float64(默认)的数组转化为float32和float16的数组时，数组的长度会发生变化，分别变为原来的两倍和四倍。</p></li><li><p>整型数据转换</p><p>同上</p></li><li><p>浮点数转整数</p><p><code>numpy</code>中的数据类型转换，不能直接改原数据的dtype，只能用函数<code>astype()</code></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npb=np.array([<span class="hljs-number">1.</span>,<span class="hljs-number">2.</span>,<span class="hljs-number">3.</span>,<span class="hljs-number">4.</span>]) <span class="hljs-comment"># 默认为float64,直接改变则数组长度会变化</span>c=b.astype(int)print(c)print(c.shape)print(c.dtype)</code></pre></li></ul><hr /><h3 id="数组切片和索引">数组切片和索引</h3><p><strong>NumPy切片和普通索引</strong>，ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。ndarray 数组可以基于 0 – n 的下标进行索引，切片对象可以通过内置的 <code>slice()</code> 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。</p><pre><code class="hljs python">a = np.arange(<span class="hljs-number">10</span>) <span class="hljs-comment"># [0 1 2 3 4 5 6 7 8 9]</span>s = slice(<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>)   <span class="hljs-comment"># 从索引 2 开始到索引 7 停止，间隔为2</span><span class="hljs-keyword">print</span> (a[s])<span class="hljs-comment"># 或者</span>a = np.arange(<span class="hljs-number">10</span>)b = a[<span class="hljs-number">2</span>:<span class="hljs-number">7</span>:<span class="hljs-number">2</span>]   <span class="hljs-comment"># 从索引 2 开始到索引 7 停止（不包括7），间隔为 2</span>print(b)<span class="hljs-comment"># 输出 [2  4  6]</span></code></pre><p><strong>冒号 " : "的解释：</strong>如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引<strong>(不包括停止索引)</strong>之间的项，list[start​ : end: ​step]start:起始位置、end:结束位置、step:步长，list[::-1]用于reverse。</p><p><strong>list[-1:]和list[:-1]的区别和联系：</strong> 这里面list[-1]是最后一个元素，所以等价于 <code>list[len-1:len]</code> 和 <code>list[0:len-1]</code> <a href="https://blog.csdn.net/weixin_40576010/article/details/88426129">参考链接</a></p><p>切片还可以包括省略号 " … "，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])  <span class="hljs-keyword">print</span> (a[...,<span class="hljs-number">1</span>])   <span class="hljs-comment"># 第2列元素</span><span class="hljs-keyword">print</span> (a[<span class="hljs-number">1</span>,...])   <span class="hljs-comment"># 第2行元素</span><span class="hljs-keyword">print</span> (a[...,<span class="hljs-number">1</span>:])  <span class="hljs-comment"># 第2列及剩下的所有元素</span><span class="hljs-comment"># 输出</span><span class="hljs-comment"># [2 4 5]</span><span class="hljs-comment"># [3 4 5]</span><span class="hljs-comment"># [[2 3]</span><span class="hljs-comment">#  [4 5]</span><span class="hljs-comment">#  [5 6]]</span><span class="hljs-comment"># reversed a</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(a[ : :<span class="hljs-number">-1</span>])     array([[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],        [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])  <span class="hljs-meta">&gt;&gt;&gt; </span>print(a[...,::<span class="hljs-number">-1</span>])[[<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>] [<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>] [<span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>print(a[::<span class="hljs-number">-1</span>,::<span class="hljs-number">-1</span>])[[<span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>] [<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>] [<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>]]</code></pre><p><strong>NumPy 高级索引</strong>，NumPy 比一般的 Python 序列提供更多的索引方式。除了之前看到的用整数和切片的索引外，数组可以由<strong>整数数组索引（花式索引）、布尔索引</strong>（对应下面三段代码）。（花式索引？）</p><p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],  [<span class="hljs-number">5</span>,  <span class="hljs-number">6</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>x[x&gt;<span class="hljs-number">3</span>]array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<span class="hljs-comment"># 以下实例使用了 ~（取补运算符）来过滤 NaN</span><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([np.nan, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, np.nan, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (a[~np.isnan(a)])[<span class="hljs-number">1.</span> <span class="hljs-number">2.</span> <span class="hljs-number">3.</span> <span class="hljs-number">4.</span> <span class="hljs-number">5.</span>]<span class="hljs-comment"># 还有a[np.iscomplex(a)]等</span></code></pre><p>花式索引指的是<strong>利用整数数组进行索引</strong>。花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。<strong>花式索引跟切片不一样，它总是将数据复制到新数组中。</strong></p><pre><code class="hljs python"><span class="hljs-comment"># 获取数组中(0,0)，(1,1)和(2,0)位置处的元素</span><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],  [<span class="hljs-number">5</span>,  <span class="hljs-number">6</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>y = x[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]] <span class="hljs-comment"># 二维数组的索引</span><span class="hljs-meta">&gt;&gt;&gt; </span>yarray([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<span class="hljs-comment">#</span><span class="hljs-meta">&gt;&gt;&gt; </span>x=np.arange(<span class="hljs-number">32</span>).reshape((<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>xarray([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],       [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>],       [<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>],       [<span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>x[[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>]]array([[<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [<span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>]])<span class="hljs-comment"># 传入多个索引数组（要使用np.ix_）</span><span class="hljs-meta">&gt;&gt;&gt; </span>x[np.ix_([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])]array([[ <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],       [<span class="hljs-number">20</span>, <span class="hljs-number">23</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>],       [<span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">11</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]])</code></pre><p>寻找数组中的最大值和最小值索引可使用np.argmax(arr.axis = 0/1) , np.argmin(arr, axis = 0/1)不写axis则返回整个数组的最大值的索引（1个），0轴为列方向，1轴为行方向。</p><ul><li>生成随机数（ <a href="https://segmentfault.com/a/1190000016097466">链接</a> ）</li></ul><hr /><h3 id="数组广播">数组广播</h3><p>NumPy广播(Broadcast)，广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在shape前面加 1 补齐维度。（3,4）+（3,）补齐（1,3）</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。（x*y，y的维度与x中的子维度相同则可以运算）</li></ul><hr /><h3 id="迭代数组">迭代数组</h3><p>参考链接：<a href="https://numpy.org/devdocs/reference/generated/numpy.nditer.html?highlight=nditer#numpy.nditer" class="uri">https://numpy.org/devdocs/reference/generated/numpy.nditer.html?highlight=nditer#numpy.nditer</a></p><p>NumPy 迭代数组，NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式，迭代器最基本的任务的可以完成对数组元素的访问。</p><p><code>np.nditer(op, flags=['multi_index'], op_flags=['readwrite'])</code></p><p><code>op</code> ndarray 或者是序列；<code>flags</code> 可选项，字符串序列,用于控制迭代器行为；<code>op_flags</code> 可选项，字符串列表,可选值有 <strong>readonly, readwrite, or writeonly</strong>。</p><ul><li>数组x和x.T的存储方式是一样的，使用迭代当时输出也是一样的。</li><li>使用C（按照行输出）和F（按照列输出）迭代显式出的结果不一致。</li></ul><pre><code class="hljs python">x = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.nditer(x):<span class="hljs-meta">... </span>    print(i,end = <span class="hljs-string">&quot; &quot;</span>)...<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span></code></pre><p>nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。</p><pre><code class="hljs python">a = np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">60</span>,<span class="hljs-number">5</span>) a = a.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)  <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;原始数组是：&#x27;</span>)<span class="hljs-keyword">print</span> (a)<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> np.nditer(a, op_flags=[<span class="hljs-string">&#x27;readwrite&#x27;</span>]):     x[...]=<span class="hljs-number">2</span>*x <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;修改后的数组是：&#x27;</span>)<span class="hljs-keyword">print</span> (a)</code></pre><p>nditer类的构造器拥有flags参数，它可以接受下列值：<code>c_index</code> 跟踪C顺序索引；<code>f_index</code> 跟踪Fortran顺序索引；<code>external_loop</code>输出值时具有多个值的一维数组。</p><p>如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 （3，4），数组 b 的维度为 （4，） ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">60</span>,<span class="hljs-number">5</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>b = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>aarray([[ <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>],       [<span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>],       [<span class="hljs-number">40</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">55</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>barray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> np.nditer([a,b]):<span class="hljs-meta">... </span>    <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;%d:%d&quot;</span>  %  (x,y), end=<span class="hljs-string">&quot;, &quot;</span> )...<span class="hljs-number">0</span>:<span class="hljs-number">1</span>, <span class="hljs-number">5</span>:<span class="hljs-number">2</span>, <span class="hljs-number">10</span>:<span class="hljs-number">3</span>, <span class="hljs-number">15</span>:<span class="hljs-number">4</span>, <span class="hljs-number">20</span>:<span class="hljs-number">1</span>, <span class="hljs-number">25</span>:<span class="hljs-number">2</span>, <span class="hljs-number">30</span>:<span class="hljs-number">3</span>, <span class="hljs-number">35</span>:<span class="hljs-number">4</span>, <span class="hljs-number">40</span>:<span class="hljs-number">1</span>, <span class="hljs-number">45</span>:<span class="hljs-number">2</span>, <span class="hljs-number">50</span>:<span class="hljs-number">3</span>, <span class="hljs-number">55</span>:<span class="hljs-number">4</span>,</code></pre><hr /><h3 id="数组相关操作">数组相关操作</h3><ul><li><p>修改数组形状 <code>numpy.reshape</code> <code>numpy.ndarray.flat</code></p><p>函数返回一个数组元素迭代器</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>xarray([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>x.flat&lt;numpy.flatiter object at <span class="hljs-number">0x000001E7D0570910</span>&gt;</code></pre><p><code>numpy.ndarray.flatten</code></p><p>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.flatten()array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])</code></pre><p><code>numpy.ravel</code></p><p>返回一个连续的被展开的数组。等同于x.reshape(-1, order=order)，修改会引起原来数组的变化。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = np.ravel(x,order= <span class="hljs-string">&quot;A&quot;</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>yarray([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>y[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><span class="hljs-meta">&gt;&gt;&gt; </span>yarray([<span class="hljs-number">100</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">4</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">6</span>,   <span class="hljs-number">7</span>,   <span class="hljs-number">8</span>,   <span class="hljs-number">9</span>,  <span class="hljs-number">10</span>,  <span class="hljs-number">11</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>xarray([[<span class="hljs-number">100</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">3</span>],       [  <span class="hljs-number">4</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">6</span>,   <span class="hljs-number">7</span>],       [  <span class="hljs-number">8</span>,   <span class="hljs-number">9</span>,  <span class="hljs-number">10</span>,  <span class="hljs-number">11</span>]])</code></pre></li><li><p>翻转数组 <code>numpy.transpose</code></p><p>用于对换数组的维度，<code>numpy.transpose(arr, axes)</code>，<code>arr</code>：要操作的数组；<code>axes</code>：整数列表，对应维度，通常所有维度都会对换。功能同arr.T，转置。</p><p><code>numpy.rollaxis</code></p><p>函数向后滚动特定的轴到一个特定位置，<code>numpy.rollaxis(arr, axis, start)</code>，<code>arr</code>：数组；<code>axis</code>：要向后滚动的轴，其它轴的相对位置不会改变；<code>start</code>：<strong>默认为零，表示完整的滚动</strong>。会滚动到特定位置。</p><p><code>numpy.swapaxes</code></p><p><code>numpy.swapaxes(arr, axis1, axis2)</code>， 函数用于交换数组的两个轴 axis1和axis2。</p></li><li><p>修改数组维度 <code>numpy.broadcast</code></p><p>用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。该函数使用两个数组作为输入参数 。</p></li></ul><p><code>numpy.broadcast_to</code></p><p>函数<code>numpy.broadcast_to(array, shape, subok)</code> 将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError 。</p><p><code>numpy.expand_dims</code></p><p>函数通过在指定位置插入新的轴来扩展数组形状 <code>numpy.expand_dims(arr, axis)</code> 。</p><p><code>numpy.squeeze</code></p><p>函数<code>numpy.squeeze(arr, axis)</code> 从给定数组的形状中删除一维（该维度数值必须为1）的条目 。</p><ul><li><p>连接数组 <code>numpy.concatenate</code></p><p>函数 <code>numpy.concatenate((a1, a2, ...), axis)</code> 用于沿指定轴连接相同形状的两个或多个数组。</p></li></ul><pre><code class="hljs shell">第一个数组：[[1 2] [3 4]]  第二个数组：  [[5 6]   [7 8]]  沿轴 0 连接两个数组：  [[1 2]   [3 4]   [5 6]   [7 8]]  沿轴 1 连接两个数组：  [[1 2 5 6]   [3 4 7 8]]</code></pre><p><code>numpy.stack</code></p><p>函数<code>numpy.stack((a1,a2,...), axis)</code> 用于沿新轴连接数组序列 。（维度会加1）</p><p><pre><code class="hljs shell">第一个数组：[[1 2]  [3 4]]  第二个数组：[[5 6] [7 8]]  沿轴 0 堆叠两个数组：  [[[1 2]    [3 4]]     [[5 6]    [7 8]]]    沿轴 1 堆叠两个数组：  [[[1 2]    [5 6]]     [[3 4]    [7 8]]]</code></pre></p><p><code>numpy.hstack</code></p><p>numpy.stack 函数的变体，它通过水平堆叠来生成数组 <code>np.hstack((a,b))</code> 。</p><p><pre><code class="hljs shell">第一个数组：[[1 2] [3 4]]  第二个数组：[[5 6] [7 8]]  水平堆叠：[[1 2 5 6] [3 4 7 8]]</code></pre></p><p><code>numpy.vstack</code></p><p><pre><code class="hljs shell">第一个数组：  [[1 2]   [3 4]] 第二个数组：  [[5 6]   [7 8]]竖直堆叠：  [[1 2]   [3 4]   [5 6]   [7 8]]</code></pre></p><ul><li><p>分割数组 <code>numpy.split</code></p><p>函数<code>numpy.split(ary, indices_or_sections, axis)</code> 沿特定的轴将数组分割为子数组 。<code>ary</code>：被分割的数组<code>indices_or_sections</code>：如果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）<code>axis</code>：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分。</p><p>For example, <code>[2, 3]</code> would, for <code>axis=0</code>, result in ary[:2]、ary[2:3]、ary[3:]。</p><p><code>numpy.hsplit</code></p><pre><code class="hljs shell">原array：[[4. 7. 6. 3. 2. 6.] [6. 3. 6. 7. 9. 7.]]np.hsplit(harr, 3)拆分后：[array([[4., 7.],       [6., 3.]]), array([[6., 3.],       [6., 7.]]), array([[2., 6.],       [9., 7.]])]</code></pre><p><code>numpy.vsplit</code></p><pre><code class="hljs shell">第一个数组：[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11] [12 13 14 15]]np.vsplit(a,2)竖直分割：[array([[0, 1, 2, 3],       [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],       [12, 13, 14, 15]])]</code></pre></li><li><p>数组元素的添加与删除 <code>numpy.resize</code></p><p>函数 <code>numpy.resize(arr, shape)</code> 返回指定大小的新数组。<strong>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</strong></p><p><code>numpy.append</code></p><p>函数<code>numpy.append(arr, values, axis=None)</code> 在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 输入数组的维度必须匹配否则将生成ValueError。</p><p><code>arr</code>：输入数组；<code>values</code>：要向<code>arr</code>添加的值，需要和<code>arr</code>形状相同（除了要添加的轴）；<code>axis</code>：默认为 None。<strong>当axis无定义时，是横向加成，返回总是为一维数组！</strong>当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</p><p><strong>append 函数返回的始终是一个一维数组。</strong></p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<span class="hljs-keyword">print</span> (np.append(a, [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]))<span class="hljs-keyword">print</span> (np.append(a, [[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]],axis = <span class="hljs-number">0</span>))<span class="hljs-keyword">print</span> (np.append(a, [[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]],axis = <span class="hljs-number">1</span>))第一个数组：[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]]向数组添加元素：[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]沿轴 <span class="hljs-number">0</span> 添加元素：[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>] [<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]]沿轴 <span class="hljs-number">1</span> 添加元素：[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span>] [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]]</code></pre><p><code>numpy.insert</code></p><p>函数<code>numpy.insert(arr, obj, values, axis)</code> 在给定索引之前，沿给定轴在输入数组中插入值。 如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p><p><code>arr</code>：输入数组；<code>obj</code>：在其之前插入值的索引；<code>values</code>：要插入的值；<code>axis</code>：沿着它插入的轴，如果未提供，则输入数组会被展开。该操作会广播值数组来配输入数组。</p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<span class="hljs-keyword">print</span> (a)<span class="hljs-keyword">print</span> (np.insert(a,<span class="hljs-number">3</span>,[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]))<span class="hljs-keyword">print</span> (np.insert(a,<span class="hljs-number">1</span>,[<span class="hljs-number">11</span>],axis = <span class="hljs-number">0</span>))<span class="hljs-keyword">print</span> (np.insert(a,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,axis = <span class="hljs-number">1</span>))第一个数组：[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span>] [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]]未传递 Axis 参数。 在插入之前输入数组会被展开。[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>]传递了 Axis 参数。 会广播值数组来配输入数组。沿轴 <span class="hljs-number">0</span> 广播：[[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>] [<span class="hljs-number">11</span> <span class="hljs-number">11</span>] [ <span class="hljs-number">3</span>  <span class="hljs-number">4</span>] [ <span class="hljs-number">5</span>  <span class="hljs-number">6</span>]]沿轴 <span class="hljs-number">1</span> 广播：[[ <span class="hljs-number">1</span> <span class="hljs-number">11</span>  <span class="hljs-number">2</span>] [ <span class="hljs-number">3</span> <span class="hljs-number">11</span>  <span class="hljs-number">4</span>] [ <span class="hljs-number">5</span> <span class="hljs-number">11</span>  <span class="hljs-number">6</span>]]</code></pre><p><code>numpy.delete</code></p><p>函数<code>Numpy.delete(arr, obj, axis)</code> 返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p><p><code>arr</code>：输入数组；<code>obj</code>：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组；<code>axis</code>：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开。</p><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-keyword">print</span> (a)<span class="hljs-keyword">print</span> (np.delete(a,<span class="hljs-number">5</span>))<span class="hljs-keyword">print</span> (np.delete(a,<span class="hljs-number">1</span>,axis = <span class="hljs-number">0</span>))<span class="hljs-keyword">print</span> (np.delete(a,<span class="hljs-number">1</span>,axis = <span class="hljs-number">1</span>))a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>])<span class="hljs-keyword">print</span> (np.delete(a, np.s_[::<span class="hljs-number">2</span>])) <span class="hljs-comment"># np.s_[::2] = slice(none,none,2)</span>第一个数组：[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]  <span class="hljs-comment"># 第一行</span> [ <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]  <span class="hljs-comment"># 第二行</span> [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]未传递 Axis 参数。 在删除之前输入数组会被展开。[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]删除第二行：[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>], [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]]删除第二列：[[ <span class="hljs-number">0</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>] [ <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>] [ <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]包含从数组中删除的替代值的切片：[ <span class="hljs-number">2</span>  <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">8</span> <span class="hljs-number">10</span>]</code></pre><p><code>numpy.unique</code></p><p>函数<code>numpy.unique(arr, return_index, return_inverse, return_counts)</code> 用于去除数组中的重复元素。</p><p><code>arr</code>：输入数组，如果不是一维数组则会展开；<code>return_index</code>：如果为<code>true</code>，返回新列表元素在旧列表中的位置（下标），并以列表形式存储；<code>return_inverse</code>：如果为<code>true</code>，返回旧列表元素在新列表中的位置（下标），并以列表形式存储；<code>return_counts</code>：如果为<code>true</code>，返回去重数组中的元素在原数组中的出现次数。</p><pre><code class="hljs python">a = np.array([<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>])<span class="hljs-keyword">print</span> (a)第一个数组：[<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span>]u,indices = np.unique(a, return_index = <span class="hljs-literal">True</span>)print(u)<span class="hljs-keyword">print</span> (indices)第一个数组的去重值：[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]去重数组的索引数组：[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]u,indices = np.unique(a,return_inverse = <span class="hljs-literal">True</span>)<span class="hljs-keyword">print</span> (u)<span class="hljs-keyword">print</span> (indices)<span class="hljs-keyword">print</span> (u[indices])去重数组的下标：[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]下标为：[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span>]使用下标重构原数组：[<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span>]u,indices = np.unique(a,return_counts = <span class="hljs-literal">True</span>)<span class="hljs-keyword">print</span> (u)<span class="hljs-keyword">print</span> (indices)返回去重元素的重复数量：[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>][<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]</code></pre></li></ul><hr /><h3 id="位运算">位运算</h3><p><code>bitwise_and</code> 对数组元素执行位与操作 <code>bitwise_or</code> 对数组元素执行位或操作 <code>invert</code> 按位取反 <code>left_shift</code> 向左移动二进制表示的位 <code>right_shift</code> 向右移动二进制表示的位</p><p><strong>注：也可以使用 “&amp;”、 “~”、 “|” 和 “^” 等操作符进行计算。</strong></p><hr /><h3 id="字符串数组">字符串数组</h3><p>NumPy 字符串函数，字符数组类（numpy.char）中定义了一些函数，这些函数用于对 dtype 为 numpy.string_ 或 numpy.unicode_ 的数组执行向量化字符串操作，它们基于 Python 内置库中的标准字符串函数。</p><p><code>numpy.char.add()</code> 依次对两个数组的元素进行字符串连接 。</p><p><code>numpy.char.multiply()</code> 对字符串执行多重连接。</p><pre><code class="hljs python">np.char.multiply(<span class="hljs-string">&#x27;geek-docs &#x27;</span>,<span class="hljs-number">3</span>) <span class="hljs-comment"># geek-docs geek-docs geek-docs</span></code></pre><p><code>numpy.char.center()</code> 用于将字符串居中，并使用指定字符在左侧和右侧进行填充。</p><p><code>numpy.char.capitalize()</code> 将字符串的第一个字母转换为大写 。</p><p><code>numpy.char.title()</code> 将字符串的每个单词的第一个字母转换为大写 。</p><p><code>numpy.char.lower()</code> 对数组的每个元素转换为小写。它对每个元素调用 str.lower 。</p><p><code>numpy.char.upper()</code> 对数组的每个元素转换为大写。它对每个元素调用 str.upper 。</p><p><code>numpy.char.split()</code> 指定分隔符对字符串进行分割，并返回数组。默认情况下，分隔符为空格。</p><p><code>numpy.char.splitlines()</code> 以换行符作为分隔符来分割字符串，并返回数组。</p><p><code>numpy.char.strip()</code> 用于移除开头或结尾处的特定字符。</p><p><code>numpy.char.join()</code> 通过指定分隔符来连接数组中的元素或字符串 。</p><p><code>numpy.char.replace()</code> 函数使用新字符串替换字符串中的所有子字符串。</p><p><code>numpy.char.encode()</code> 对数组中的每个元素调用 str.encode 函数。 默认编码是'utf-8'，可以使用标准 Python 库中的编解码器。</p><p><code>numpy.char.decode()</code> 函数对编码的元素进行 str.decode() 解码。</p><pre><code class="hljs python">a = np.char.encode(<span class="hljs-string">&#x27;geek-docs&#x27;</span>, <span class="hljs-string">&#x27;cp500&#x27;</span>)print(a)  <span class="hljs-comment"># b&#x27;\x87\x85\x85\x92`\x84\x96\x83\xa2&#x27;</span>print(np.char.decode(a, <span class="hljs-string">&#x27;cp500&#x27;</span>)) <span class="hljs-comment"># geek-docs</span></code></pre><hr /><h3 id="数学函数与计算">数学函数与计算</h3><ul><li><p><strong>三角函数</strong></p><p><code>cos</code> <code>cosh</code> <code>sin</code> <code>sinh</code> <code>tan</code> <code>tanh</code> （ 一般三角函数和<a href="https://baike.baidu.com/item/%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0/8704306?fr=aladdin">双曲函数</a> ）</p><p><code>arccos</code> <code>arccosh</code> <code>arcsin</code> <code>arcsinh</code> <code>arctan</code> <code>arctanh</code> （反三角函数）</p></li></ul><pre><code class="hljs python">cos = np.cos(a*np.pi/<span class="hljs-number">180</span>)inv = np.arccos(cos)np.degrees(inv)(弧度转化为度数)</code></pre><ul><li><p><strong>四舍五入函数</strong></p><p><code>numpy.around(array,decimals)</code></p><p>decimals默认为0，n表示保留到小数点后n位，-n表示保留到小数点前n位置。</p></li><li><p><strong>向上、下取整</strong></p><p><code>numpy.ceil()</code> <code>numpy.floor()</code></p></li><li><p><strong>算数函数</strong></p><p><code>add()</code> <code>subtract()</code> <code>multiply()</code> <code>divide()</code> 加减乘除</p><p><code>numpy.reciprocal()</code> 函数返回参数逐元素的倒数</p><p><code>numpy.power()</code> 第一个输入数组中的元素作为底数，第二个输入为幂</p><p><code>numpy.mod()</code> 求余，函数 <code>numpy.remainder()</code> 也产生相同的结果。</p></li><li><p><strong>统计函数</strong></p><p><strong>(不使用axis参数则返回所有元素的最大、最小值)</strong></p><p><code>numpy.amin(arr, axis)</code> 用于计算数组中的元素沿指定轴的最小值。</p><p><code>numpy.amax(arr, axis)</code> 用于计算数组中的元素沿指定轴的最大值。</p><p><code>numpy.ptp(arr, axis)</code> 计算数组中元素最大值与最小值的差（最大值 – 最小值）</p><p><code>numpy.percentile(a, q, axis,keepdims=false)</code></p><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。</p><p>a是输入数组，q是计算的百分位数，axis为轴向，keepdims为true保持原形状。</p><p><code>numpy.median()</code> 函数用于计算数组 a 中元素的中位数（中值）</p><p><code>numpy.mean()</code></p><p>函数返回数组中元素的算术平均值。</p><p>如果提供了轴，则沿其计算。算术平均值是沿轴的元素的总和除以元素的数量。</p><p><code>numpy.average(arr, axis, weights, returned)</code></p><p>函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。 该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。 如果 <code>returned</code> 参数设为 true，则返回 (average, sum_of_weights) 。</p><p><code>numpy.std(a, axis=None, dtype=None)</code></p><p>标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。</p><p>标准差的计算等同于 <code>std = sqrt(mean(abs(x - x.mean())**2))</code></p></li><li><p><strong>排序函数</strong></p><p><code>numpy.sort(a, axis, kind, order)</code></p><p>返回待排序数组的有序副本。<code>kind</code> 可以选择排序方法，默认quicksort，如果数组包含字段，则设置order根据字段排序。默认为升序排序降序排列（ np.sort(arr)[::-1]）。</p><pre><code class="hljs python">dt = np.dtype([(<span class="hljs-string">&#x27;name&#x27;</span>,  <span class="hljs-string">&#x27;S10&#x27;</span>),(<span class="hljs-string">&#x27;age&#x27;</span>,  int)]) a = np.array([(<span class="hljs-string">&quot;raju&quot;</span>,<span class="hljs-number">21</span>),(<span class="hljs-string">&quot;anil&quot;</span>,<span class="hljs-number">25</span>),(<span class="hljs-string">&quot;ravi&quot;</span>,  <span class="hljs-number">17</span>),  (<span class="hljs-string">&quot;amar&quot;</span>,<span class="hljs-number">27</span>)], dtype = dt)  <span class="hljs-keyword">print</span> (np.sort(a, order =  <span class="hljs-string">&#x27;name&#x27;</span>))<span class="hljs-comment"># 结果</span>我们的数组是：[(<span class="hljs-string">b&#x27;raju&#x27;</span>, <span class="hljs-number">21</span>) (<span class="hljs-string">b&#x27;anil&#x27;</span>, <span class="hljs-number">25</span>) (<span class="hljs-string">b&#x27;ravi&#x27;</span>, <span class="hljs-number">17</span>) (<span class="hljs-string">b&#x27;amar&#x27;</span>, <span class="hljs-number">27</span>)]按 name 排序：[(<span class="hljs-string">b&#x27;amar&#x27;</span>, <span class="hljs-number">27</span>) (<span class="hljs-string">b&#x27;anil&#x27;</span>, <span class="hljs-number">25</span>) (<span class="hljs-string">b&#x27;raju&#x27;</span>, <span class="hljs-number">21</span>) (<span class="hljs-string">b&#x27;ravi&#x27;</span>, <span class="hljs-number">17</span>)]</code></pre><p><code>numpy.argsort()</code> 函数返回的是数组值从小到大的索引值。</p><pre><code class="hljs python">x = np.array([<span class="hljs-number">3</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>])y = np.argsort(x)x[y]我们的数组是：[<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>]对 x 调用 argsort() 函数，返回所以：[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>]以排序后的索引，顺序重构原数组：[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]</code></pre><p><code>numpy.lexsort()</code> 用于对多个序列进行排序，返回其索引。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><p>小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p><pre><code class="hljs python">nm =  (<span class="hljs-string">&#x27;raju&#x27;</span>,<span class="hljs-string">&#x27;anil&#x27;</span>,<span class="hljs-string">&#x27;ravi&#x27;</span>,<span class="hljs-string">&#x27;amar&#x27;</span>) dv =  (<span class="hljs-string">&#x27;f.y.&#x27;</span>,  <span class="hljs-string">&#x27;s.y.&#x27;</span>,  <span class="hljs-string">&#x27;s.y.&#x27;</span>,  <span class="hljs-string">&#x27;f.y.&#x27;</span>) ind = np.lexsort((dv,nm))  <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;调用 lexsort() 函数：&#x27;</span>) <span class="hljs-keyword">print</span> (ind) <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;使用这个索引来获取排序后的数据：&#x27;</span>) <span class="hljs-keyword">print</span> ([nm[i]  +  <span class="hljs-string">&quot;, &quot;</span>  + dv[i]  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ind])调用 lexsort() 函数：[<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span>]使用这个索引来获取排序后的数据：[<span class="hljs-string">&#x27;amar, f.y.&#x27;</span>, <span class="hljs-string">&#x27;anil, s.y.&#x27;</span>, <span class="hljs-string">&#x27;raju, f.y.&#x27;</span>, <span class="hljs-string">&#x27;ravi, s.y.&#x27;</span>]</code></pre><p><code>msort(a)</code></p><p>数组按第一个轴排序，返回排序后的数组副本，相等于 np.sort(a, axis=0)。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>np.msort(result)array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>resultarray([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">4</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">5</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>np.sort(result,axis = <span class="hljs-number">0</span>)array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]])</code></pre><p><code>sort_complex(a)</code> 对复数按照先实部后虚部的顺序进行排序。</p><p><code>partition(a, kth[, axis, kind, order])</code></p><p>指定一个数，对数组进行分区。</p><p><code>np.partition</code> 的工作流程可以看做是先对数组排序（升序），然后以索引是kth的元素为基准，将元素分成两部分，即大于该元素的放在其后面，小于该元素的放在其前面，这里有点类似于快排。常用于求一个数组的前k（k = kth+1求最小，k = kth求最大）个最值元素，时间复杂度很低 O(n) 。</p><p><a href="https://blog.csdn.net/weixin_42001089/article/details/89204112">参考链接</a></p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>result = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>,(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>resultarray([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">4</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">5</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>result1 = np.sort(result,axis=<span class="hljs-number">0</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>result1array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>result2 = np.partition(result, kth=<span class="hljs-number">1</span>, axis=<span class="hljs-number">0</span>)[:<span class="hljs-number">2</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>result2  <span class="hljs-comment"># 求每一列前k = 2小,所以参数kth = 1</span>array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>result3 = np.partition(result, kth=<span class="hljs-number">-2</span>, axis=<span class="hljs-number">1</span>)[::,<span class="hljs-number">-2</span>:]<span class="hljs-meta">&gt;&gt;&gt; </span>result3  <span class="hljs-comment"># 求每一行最大k = 2个元素，</span>array([[ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>],       [ <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>]])</code></pre><p><code>argpartition(a, kth[, axis, kind, order])</code></p><p>类似上面的函数，常用于求一个数组的前k个最值元素的索引，可以通过关键字 kind 指定算法（默认"introselect"），沿着指定轴axis对数组进行分区。(introselect参考快排过程)</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa = np.array([<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>])print(np.argpartition(a, <span class="hljs-number">4</span>)) <span class="hljs-comment">#将数组a中所有元素（包括重复元素）从小到大排列，比索引为第5的元素小的放在前面，大的放在后面（除了第五个元素，其余元素可能都是乱序的），输出新数组索引。</span>&gt;&gt; [<span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">0</span>]a[np.argpartition(a, <span class="hljs-number">4</span>)]     <span class="hljs-comment">#输出新数组索引对应的数组</span>&gt;&gt; array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])a[np.argpartition(a, <span class="hljs-number">-5</span>)[<span class="hljs-number">-5</span>:]] <span class="hljs-comment"># 输出top5</span>&gt;&gt; array([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>result3 = result[np.c_[np.arange(result.shape[<span class="hljs-number">0</span>]),np.arange(result.shape[<span class="hljs-number">0</span>])],np.argpartition(result, kth=<span class="hljs-number">-2</span>, axis=<span class="hljs-number">1</span>)[:,<span class="hljs-number">-2</span>:]]<span class="hljs-meta">&gt;&gt;&gt; </span>result3 <span class="hljs-comment"># 操作略复杂，直接partition可以得到一样的效果，两者相同</span>array([[ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>],       [ <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>]])条件筛选函数</code></pre></li><li><p>条件筛选函数</p><p><code>numpy.argmax()</code> 和 <code>numpy.argmin()</code> 返回最大值和最小值索引</p><p><code>numpy.nonzero()</code> 返回非0值索引</p><pre><code class="hljs python"> <span class="hljs-comment"># 对应两个两个维度的坐标我们的数组是：</span>[[<span class="hljs-number">30</span> <span class="hljs-number">40</span>  <span class="hljs-number">0</span>] [ <span class="hljs-number">0</span> <span class="hljs-number">20</span> <span class="hljs-number">10</span>] [<span class="hljs-number">50</span>  <span class="hljs-number">0</span> <span class="hljs-number">60</span>]]调用 nonzero() 函数：(array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], dtype=int64), array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>], dtype=int64)) <span class="hljs-comment"># 对应两个两个维度的坐标</span></code></pre><p><code>numpy.where()</code> 根据条件返回符合的元素的索引</p><pre><code class="hljs python">x = np.arange(<span class="hljs-number">9.</span>).reshape(<span class="hljs-number">3</span>,  <span class="hljs-number">3</span>)  y = np.where(x &gt;  <span class="hljs-number">3</span>)  x[y] <span class="hljs-comment"># 根据索引求原来的元素</span>我们的数组是：[[<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">2.</span>] [<span class="hljs-number">3.</span> <span class="hljs-number">4.</span> <span class="hljs-number">5.</span>] [<span class="hljs-number">6.</span> <span class="hljs-number">7.</span> <span class="hljs-number">8.</span>]]大于 <span class="hljs-number">3</span> 的元素的索引：(array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]), array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])) <span class="hljs-comment"># y是元组</span>使用这些索引来获取满足条件的元素：[<span class="hljs-number">4.</span> <span class="hljs-number">5.</span> <span class="hljs-number">6.</span> <span class="hljs-number">7.</span> <span class="hljs-number">8.</span>]</code></pre><p><code>numpy.extract()</code> 也是返回一定满足一定条件的元素。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>arrarray([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>condition = np.mod(arr, <span class="hljs-number">3</span>)==<span class="hljs-number">0</span><span class="hljs-meta">&gt;&gt;&gt; </span>conditionarray([[ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>],       [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>],       [<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>np.extract(condition, arr)array([<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])<span class="hljs-comment"># condition是布尔型的，等价于array[condition]</span></code></pre></li><li><p><strong>字节交换</strong></p><p><code>numpy.ndarray.byteswap()</code> 大小端的转化，参数为True</p></li><li><p><strong>NumPy 副本和视图</strong></p><p><code>np.ndarray.view()</code> 创建一个新的数组对象，该方法创建的新数组的维数改变不会更改原始数据的维数。修改元素会改变原始值。</p><p>但是， 使用切片创建视图修改数据<strong>会影响到</strong>原始数组 。</p><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">12</span>)arra=arr[<span class="hljs-number">3</span>:]b=arr[<span class="hljs-number">3</span>:]a[<span class="hljs-number">1</span>]=<span class="hljs-number">123</span>b[<span class="hljs-number">2</span>]=<span class="hljs-number">234</span>arrid(a),id(b),id(arr[<span class="hljs-number">3</span>:])我们的数组：[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]创建切片：[  <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span> <span class="hljs-number">123</span> <span class="hljs-number">234</span>   <span class="hljs-number">6</span>   <span class="hljs-number">7</span>   <span class="hljs-number">8</span>   <span class="hljs-number">9</span>  <span class="hljs-number">10</span>  <span class="hljs-number">11</span>]<span class="hljs-number">2142679040208</span> <span class="hljs-number">2142679040288</span> <span class="hljs-number">2142816278048</span><span class="hljs-comment"># 变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。</span></code></pre><p><code>np.ndarray.copy()</code> 创建一个副本，对副本数据进行修改，不会影响原始数据，物理内存不在一个位置。</p><p><strong>无复制： </strong> <strong>简单的赋值</strong> 不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p></li></ul><hr /><h2 id="矩阵">矩阵</h2><h3 id="简介-1">简介</h3><p>NumPy 矩阵库(Matrix)，NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。一个 m x n 的矩阵是一个由m行(row)n列（column）元素排列成的矩形阵列。</p><h3 id="相关函数">相关函数</h3><ul><li><p>创建矩阵</p><p><code>numpy.matlib.empty(shape, dtype, order)</code> 创建矩阵，填充伪随机数（通常非常小）。</p><p><code>numpy.matlib.zeros()</code></p><p><code>numpy.matlib.ones()</code></p><p><code>numpy.matlib.eye(n, M,k, dtype)</code> 函数返回一个矩阵，对角线元素为 1，其他位置为零。创建一个n*M的矩阵，为对角线索引。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy.matlib<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (np.matlib.eye(n =  <span class="hljs-number">3</span>, M =  <span class="hljs-number">4</span>, k =  <span class="hljs-number">0</span>, dtype =  float))[[<span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (np.matlib.eye(n =  <span class="hljs-number">3</span>, M =  <span class="hljs-number">4</span>, k =  <span class="hljs-number">1</span>, dtype =  float))[[<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (np.matlib.eye(n =  <span class="hljs-number">3</span>, M =  <span class="hljs-number">4</span>, k =  <span class="hljs-number">-1</span>, dtype =  float))[[<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>]]</code></pre><p><code>numpy.matlib.identity()</code> 创建单位矩阵</p><p><code>numpy.matlib.rand()</code> 创建一个矩阵，用[0,1)之间伪随机数填充。</p><p>可以使用 <code>np.asmatrix()</code> 和 <code>np.asarray()</code> 互相转化。</p></li><li><p>矩阵运算</p><p><code>numpy.dot()</code> 两个数组的点积，即元素对应相乘。</p><p>对于两个一维数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和。</p><pre><code class="hljs python">dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。numpy.dot(a, b, out=<span class="hljs-literal">None</span>)</code></pre><p><code>numpy.vdot()</code> 两个向量的点积。</p><p>函数是两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开，计算之后得到的是一个标量值。、</p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])b = np.array([[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">14</span>]])<span class="hljs-comment"># vdot 将数组展开计算内积</span><span class="hljs-keyword">print</span> (np.vdot(a,b)) <span class="hljs-comment"># 130</span></code></pre><p><code>numpy.inner()</code> 两个数组的内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>np.inner(np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]),np.array([<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]))<span class="hljs-number">17</span>  <span class="hljs-comment"># 一维数组</span><span class="hljs-meta">&gt;&gt;&gt; </span>np.inner(np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]),np.array([[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]))array([[<span class="hljs-number">17</span>, <span class="hljs-number">23</span>],       [<span class="hljs-number">39</span>, <span class="hljs-number">53</span>]]) <span class="hljs-comment"># 多维数组</span></code></pre><p><code>numpy.matmul()</code> 两个数组的矩阵积。</p><p>虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。对于二维数组，它就是矩阵乘法：</p><pre><code class="hljs python">a = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]] b = [[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]] <span class="hljs-keyword">print</span> (np.matmul(a,b))[[<span class="hljs-number">4</span>  <span class="hljs-number">1</span>] [<span class="hljs-number">2</span>  <span class="hljs-number">2</span>]]<span class="hljs-comment"># 二维</span>a = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]] b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] <span class="hljs-keyword">print</span> (np.matmul(a,b))<span class="hljs-keyword">print</span> (np.matmul(b,a))[<span class="hljs-number">7</span>  <span class="hljs-number">10</span>] [<span class="hljs-number">5</span>  <span class="hljs-number">11</span>]<span class="hljs-comment"># 三维</span>a = np.arange(<span class="hljs-number">8</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) b = np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">print</span> (np.matmul(a,b))[[[ <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]  [ <span class="hljs-number">6</span> <span class="hljs-number">11</span>]] [[<span class="hljs-number">10</span> <span class="hljs-number">19</span>]  [<span class="hljs-number">14</span> <span class="hljs-number">27</span>]]]</code></pre><p><code>numpy.linalg.det()</code> 数组的行列式。</p><p><code>numpy.linalg.solve()</code> 求解线性矩阵方程。AX = B或者X = A^(-1)B</p><p><code>numpy.linalg.inv()</code> 计算矩阵的乘法逆矩阵。</p></li></ul><hr /><h2 id="其他">其他</h2><h3 id="io及磁盘存储">IO及磁盘存储</h3><p>​ Numpy可以读写磁盘上的文本数据或二进制数据，NumPy 为 ndarray 对象引入了一个简单的文件格式(.npy)。npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p><p><code>numpy.save() 和 numpy.load()</code></p><p>函数 <code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code> 可以存储数组为".npy"格式。</p><p><code>numpy.savez(file, *args, **kwds)</code></p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])b = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.1</span>)c = np.sin(b)<span class="hljs-comment"># c 使用了关键字参数 sin_array</span>np.savez(<span class="hljs-string">&quot;geek-docs.npz&quot;</span>, a, b, sin_array = c)r = np.load(<span class="hljs-string">&quot;geek-docs.npz&quot;</span>)print(r.files) <span class="hljs-comment"># 查看各个数组名称</span>print(r[<span class="hljs-string">&quot;arr_0&quot;</span>]) <span class="hljs-comment"># 数组 a</span>print(r[<span class="hljs-string">&quot;arr_1&quot;</span>]) <span class="hljs-comment"># 数组 b</span>print(r[<span class="hljs-string">&quot;sin_array&quot;</span>]) <span class="hljs-comment"># 数组 c</span><span class="hljs-comment"># 输出</span>[<span class="hljs-string">&#x27;sin_array&#x27;</span>, <span class="hljs-string">&#x27;arr_0&#x27;</span>, <span class="hljs-string">&#x27;arr_1&#x27;</span>][[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]][<span class="hljs-number">0.</span>  <span class="hljs-number">0.1</span> <span class="hljs-number">0.2</span> <span class="hljs-number">0.3</span> <span class="hljs-number">0.4</span> <span class="hljs-number">0.5</span> <span class="hljs-number">0.6</span> <span class="hljs-number">0.7</span> <span class="hljs-number">0.8</span> <span class="hljs-number">0.9</span>][<span class="hljs-number">0.</span>         <span class="hljs-number">0.09983342</span> <span class="hljs-number">0.19866933</span> <span class="hljs-number">0.29552021</span> <span class="hljs-number">0.38941834</span> <span class="hljs-number">0.47942554</span> <span class="hljs-number">0.56464247</span> <span class="hljs-number">0.64421769</span> <span class="hljs-number">0.71735609</span> <span class="hljs-number">0.78332691</span>]</code></pre><p><code>numpy.savetxt(FILENAME, a, fmt="%d", delimiter=",")</code></p><p><code>numpy.loadtxt(FILENAME, dtype=int, delimiter=' ')</code></p><p>以简单的文本文件格式(.txt)存储数据， 参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</p><pre><code class="hljs python">a=np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0.5</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>)np.savetxt(<span class="hljs-string">&quot;out.txt&quot;</span>,a,fmt=<span class="hljs-string">&quot;%d&quot;</span>,delimiter=<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment"># 改为保存为整数，以逗号分隔</span>b = np.loadtxt(<span class="hljs-string">&quot;out.txt&quot;</span>,delimiter=<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment"># load 时也要指定为逗号分隔</span>print(b)<span class="hljs-comment"># 输出</span>[[<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">1.</span> <span class="hljs-number">2.</span>] [<span class="hljs-number">2.</span> <span class="hljs-number">3.</span> <span class="hljs-number">3.</span> <span class="hljs-number">4.</span> <span class="hljs-number">4.</span>] [<span class="hljs-number">5.</span> <span class="hljs-number">5.</span> <span class="hljs-number">6.</span> <span class="hljs-number">6.</span> <span class="hljs-number">7.</span>] [<span class="hljs-number">7.</span> <span class="hljs-number">8.</span> <span class="hljs-number">8.</span> <span class="hljs-number">9.</span> <span class="hljs-number">9.</span>]]</code></pre><hr /><h3 id="matplotlib">Matplotlib</h3><p><a href="https://liam.page/2014/09/11/matplotlib-tutorial-zh-cn/">学习链接1</a></p><ul><li><p>中文显示 <a href="https://blog.csdn.net/skyli114/article/details/77508247">参考链接</a></p><p>Matplotlib 默认情况不支持中文，我们可以使用以下简单的方法来解决 ：</p><pre><code class="hljs awk">zhfont = matplotlib.font_manager.FontProperties(fname=<span class="hljs-string">r&quot;c:\windows\fonts\simsun.ttc&quot;</span>)</code></pre><p>然后可以设置参数： fontproperties=zhfont`</p><p>或者修改全局字体： <code>plt.rcParams['font.family']=['FontName']</code></p></li><li><p>线形 <a href="https://github.com/rougier/matplotlib-tutorial#quick-references">链接</a></p><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>'-'</code></td><td style="text-align: center;">实线样式</td></tr><tr class="even"><td style="text-align: center;"><code>'--'</code></td><td style="text-align: center;">短横线样式</td></tr><tr class="odd"><td style="text-align: center;"><code>'-.'</code></td><td style="text-align: center;">点划线样式</td></tr><tr class="even"><td style="text-align: center;"><code>':'</code></td><td style="text-align: center;">虚线样式</td></tr><tr class="odd"><td style="text-align: center;"><code>'.'</code></td><td style="text-align: center;">点标记</td></tr><tr class="even"><td style="text-align: center;"><code>','</code></td><td style="text-align: center;">像素标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'o'</code></td><td style="text-align: center;">圆标记</td></tr><tr class="even"><td style="text-align: center;"><code>'v'</code></td><td style="text-align: center;">倒三角标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'^'</code></td><td style="text-align: center;">正三角标记</td></tr><tr class="even"><td style="text-align: center;"><code>'&lt;'</code></td><td style="text-align: center;">左三角标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'&gt;'</code></td><td style="text-align: center;">右三角标记</td></tr><tr class="even"><td style="text-align: center;"><code>'1'</code></td><td style="text-align: center;">下箭头标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'2'</code></td><td style="text-align: center;">上箭头标记</td></tr><tr class="even"><td style="text-align: center;"><code>'3'</code></td><td style="text-align: center;">左箭头标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'4'</code></td><td style="text-align: center;">右箭头标记</td></tr><tr class="even"><td style="text-align: center;"><code>'s'</code></td><td style="text-align: center;">正方形标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'p'</code></td><td style="text-align: center;">五边形标记</td></tr><tr class="even"><td style="text-align: center;"><code>'*'</code></td><td style="text-align: center;">星形标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'h'</code></td><td style="text-align: center;">六边形标记 1</td></tr><tr class="even"><td style="text-align: center;"><code>'H'</code></td><td style="text-align: center;">六边形标记 2</td></tr><tr class="odd"><td style="text-align: center;"><code>'+'</code></td><td style="text-align: center;">加号标记</td></tr><tr class="even"><td style="text-align: center;"><code>'x'</code></td><td style="text-align: center;">X 标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'D'</code></td><td style="text-align: center;">菱形标记</td></tr><tr class="even"><td style="text-align: center;"><code>'d'</code></td><td style="text-align: center;">窄菱形标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'|'</code></td><td style="text-align: center;">竖直线标记</td></tr><tr class="even"><td style="text-align: center;"><code>'_'</code></td><td style="text-align: center;">水平线标记</td></tr></tbody></table></li><li><p>颜色</p><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: center;">颜色</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>'b'</code></td><td style="text-align: center;">蓝色</td></tr><tr class="even"><td style="text-align: center;"><code>'g'</code></td><td style="text-align: center;">绿色</td></tr><tr class="odd"><td style="text-align: center;"><code>'r'</code></td><td style="text-align: center;">红色</td></tr><tr class="even"><td style="text-align: center;"><code>'c'</code></td><td style="text-align: center;">青色</td></tr><tr class="odd"><td style="text-align: center;"><code>'m'</code></td><td style="text-align: center;">品红色</td></tr><tr class="even"><td style="text-align: center;"><code>'y'</code></td><td style="text-align: center;">黄色</td></tr><tr class="odd"><td style="text-align: center;"><code>'k'</code></td><td style="text-align: center;">黑色</td></tr><tr class="even"><td style="text-align: center;"><code>'w'</code></td><td style="text-align: center;">白色</td></tr></tbody></table></li><li><p>绘制子图</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <span class="hljs-comment"># 计算正弦和余弦曲线上的点的 x 和 y 坐标 </span>x = np.arange(<span class="hljs-number">0</span>,  <span class="hljs-number">3</span>  * np.pi,  <span class="hljs-number">0.1</span>) y_sin = np.sin(x) y_cos = np.cos(x)  <span class="hljs-comment"># 建立 subplot 网格，高为 2，宽为 1  </span><span class="hljs-comment"># 激活第一个 subplot</span>plt.subplot(<span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>)  <span class="hljs-comment"># 绘制第一个图像 </span>plt.plot(x, y_sin) plt.title(<span class="hljs-string">&#x27;Sine&#x27;</span>)  <span class="hljs-comment"># 将第二个 subplot 激活，并绘制第二个图像</span>plt.subplot(<span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>) plt.plot(x, y_cos) plt.title(<span class="hljs-string">&#x27;Cosine&#x27;</span>)  <span class="hljs-comment"># 展示图像</span>plt.show()</code></pre></li></ul><hr /><h3 id="结构化数组">结构化数组</h3><pre><code class="hljs python"><span class="hljs-comment"># numpy基本类型</span>bytes                 b1int                   i1,i2,i4,i8unsigned ints         u1,u2,u4,u8floats                f2,f4,f8complex               c8,c16fixed length strings a&lt;n&gt;</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npstructured = np.array([(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>+<span class="hljs-number">2j</span>),                        (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Second&#x27;</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">2</span><span class="hljs-number">-2j</span>),                       (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Third&#x27;</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>+<span class="hljs-number">3j</span>)],                      dtype=[(<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;i2&#x27;</span>), (<span class="hljs-string">&#x27;position&#x27;</span>,<span class="hljs-string">&#x27;a6&#x27;</span>),                              (<span class="hljs-string">&#x27;value&#x27;</span>,<span class="hljs-string">&#x27;f4&#x27;</span>), (<span class="hljs-string">&#x27;complex&#x27;</span>, <span class="hljs-string">&#x27;c8&#x27;</span>)])<span class="hljs-comment"># 或者</span>structured = np.array([(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>+<span class="hljs-number">2j</span>),                        (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Second&#x27;</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">2</span><span class="hljs-number">-2j</span>),                       (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Third&#x27;</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>+<span class="hljs-number">3j</span>)],                       dtype=(<span class="hljs-string">&#x27;i2, a6, f4, c8&#x27;</span>))<span class="hljs-comment">#这里再单独指定字段名称</span>structured.dtype.names = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;order&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;complex&#x27;</span>)print(structured[<span class="hljs-string">&#x27;position&#x27;</span>])<span class="hljs-comment"># 指定字段名，否则自动分配f0,f1,f2</span></code></pre><hr /><ol type="1"><li><p>单元素元组表示（num,）括号内应当加上逗号，否则按照数值处理</p></li><li><p><code>*args, **kwargs</code> 这两个是python中的可变参数。<code>*args</code>表示任何多个无名参数，它是一个tuple；<code>**kwargs</code> 表示关键字参数，它是一个dict。并且同时使用<code>*args</code>和<code>**kwargs</code> 时，必须<code>*args</code>参数列要在<code>**kwargs</code>前。</p><p><a href="https://blog.csdn.net/yjk13703623757/article/details/76521420">参考链接</a></p></li><li><p>参考资料：<a href="https://numpy.org/devdocs/user/quickstart.html#" class="uri">https://numpy.org/devdocs/user/quickstart.html#</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门</title>
    <link href="/2019/10/16/2019-10-16-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <url>/2019/10/16/2019-10-16-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习入门">深度学习入门</h1><p>开始时间：2019年09月17日</p><hr /><h2 id="感知机">感知机</h2><ul><li><p><strong>感知机（perceptron）</strong>接收多个输入信号，输出一个信号。学习是确定合适的参数的过程，而人要做的是思考感知机的构造（模型），并把训练数据交给计算机。</p></li><li><p><span class="math inline">\(y=\left\{\begin{array}{ll}{0} &amp; {\left(b+w_{1} x_{1}+w_{2} x_{2} \leqslant 0\right)} \\ {1} &amp; {\left(b+w_{1} x_{1}+w_{2} x_{2}&gt;0\right)}\end{array}\right.\)</span> ，此处，<span class="math inline">\(b\)</span> 称为偏置，<span class="math inline">\(w_1\)</span> 和 <span class="math inline">\(w_2\)</span> 称为权重。<span class="math inline">\(w_1\)</span> 和 <span class="math inline">\(w_2\)</span> 是控制输入信号的重要性的参数，而偏置是调整神经元被激活的容易程度（输出信号为1的程度）的参数。</p></li><li><p>感知机的<strong>局限性</strong>就在于它只能表示由一条直线分割的空间。由曲线分割而成的空间称为非线性空间，由直线分割而成的空间称为线性空间。e.g. 单层感知机无法表示异或门，但可以叠加层后表示，见下图，而与门，或门个与非门皆可以使用单层感知机实现。</p><figure><img src="Snipaste_2019-09-18_16-01-17.png" alt="利用与门，或门个与非门实现异或逻辑" /><figcaption aria-hidden="true">利用与门，或门个与非门实现异或逻辑</figcaption></figure></li></ul><hr /><h2 id="神经网络及其学习方式">神经网络及其学习方式</h2><p>一般由输入层、中间层（隐藏层）、输出层构成，与感知机的主要区别在激活函数。</p><ul><li><p><strong>激活函数</strong></p><p>就是在人工神经网络上运行的函数，负责将神经元的输入映射到输出端。激活函数不可以使用线性函数，线性函数的问题在于，不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络”。</p><p>实际上，用作激活函数的函数最好具有<strong>关于原点对称</strong>的性质。</p><ul><li><strong>阶跃函数：</strong>以阈值为界，一旦输入超过阈值，就切换输出。</li><li><strong>Sigmoid函数：</strong><span class="math inline">\(h(x) = \frac{1}{1+exp(-x)}\)</span> 。</li><li><strong>ReLU函数：</strong><span class="math inline">\(h(x)=\left\{\begin{array}{ll}{x} &amp; {(x&gt;0)} \\ {0} &amp; {(x \leqslant 0)}\end{array}\right.\)</span> ，全称线性整流函数（Rectified Linear Unit）。</li></ul></li><li><p><strong>符号</strong>解释：<span class="math inline">\(w_{12}^{(1)}\)</span> <span class="math inline">\(a_1^{(2)}\)</span> 如下图</p><p><img src="Snipaste_2019-09-19_15-51-22.png" /></p></li><li><p><strong>输出层函数</strong></p><p>输出层的激活函数，用 <span class="math inline">\(\sigma()\)</span> 表示，一般地，回归问题可以使用恒等函数，二元分类问题可以使用sigmoid函数，多元分类问题可以使用<strong>Softmax函数</strong>（作用于输出层，例子见下图）。</p><ul><li><p><strong>恒等函数：</strong>会将输入原样输出</p></li><li><p><strong>Softmax函数：</strong> <span class="math inline">\(y_k = \frac{exp(a_k)}{\sum_{i=1}^{n} exp(a_i)}\)</span> ，表示假设输出层共有n个神经元，计算第k个神经元的输出 <span class="math inline">\(y_k\)</span> 。</p></li><li><p>使用python实现softmax时需要注意处理指数溢出，改进方法是在分子分母的指数上同时加/减一个常数C，C通常为输入信号最大值。</p></li><li><p>softmax函数的输出范围<span class="math inline">\((0.0, 1.0)\)</span>，输出总和为1，所以可解释为概率。</p></li><li><p>一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果。并且，即便使用softmax函数，输出值最大的神经元的位置也不会变。因此，神经网络在进行分类时，输出层的softmax函数可以省略。在实际的问题中，由于指数函数的运算需要一定的计算机运算量，因此输出层的softmax函数一般会被省略。</p><figure><img src="1569494022849.png" alt="1569494022849" /><figcaption aria-hidden="true">1569494022849</figcaption></figure><p>注：输入图像通过Affi ne层和ReLU层进行转换，10个输入通过Softmax层进行正规化在这个例子中，“0”的得分是5.3，这个值经过Softmax层转换为0.008（0.8%）；“2”的得分是10.1，被转换为0.991（99.1%）</p></li></ul></li><li><p><strong>输出层神经元数量：</strong>对于分类问题，输出层的神经元数量一般设定为类别的数量。</p></li><li><p><strong>前向传播（forward propagation）与反向传播（back propagation）</strong></p></li><li><p><strong>预处理（pre-processing）与数据的正规化（normalization/Feature scaling ）</strong></p><p>（应该有区别，例如将数据范围转化到[0,1]之间）、数据白化（whitening，将数据整体的分布形状均匀化的方法）、数据批处理（batch）</p></li><li><p><strong>损失函数</strong></p><p>神经网络的“学习”过程就是从训练数据中自动获得最优权重参数的过程。设立训练数据和测试数据是为了评估模型的泛化能力。</p><ul><li><p>训练过程的评价指标为<strong>损失函数</strong>，损失函数可以使用任意函数，一般采用:</p><p>① <strong>均方误差（MSE，mean-square error）</strong> <span class="math inline">\(E = \frac{1}{2}\sum_{k}{(y_k - t_k)^2}\)</span> ；</p><p>② <strong>交叉熵误差（cross entropy error）</strong> <span class="math inline">\(E = - \sum_{k}{t_k\log{(y_k[+delta])}}\)</span></p><p>（其中k表示数据维度，<span class="math inline">\(y_k\)</span> 是神经网络输出，<span class="math inline">\(t_k\)</span> 是标签值，log是以e为底的对数，delta是防止对数出现无穷大。）[P85]</p><ul><li><p><strong>均方损失：</strong> 假设误差是正态分布，适用于线性的输出(如回归问题)，特点是对于与真实结果差别越大，则惩罚力度越大，这并不适用于分类问题</p></li><li><p><strong>交叉熵损失：</strong> 假设误差是二值分布，可以视为预测概率分布和真实概率分布的相似程度。在分类问题中有良好的应用。</p></li><li><p>一般我们用预测值和实际值的平方差或者它们平方差的一半，但是通常在<strong>逻辑回归</strong>中我们不这么做，因为当我们在学习逻辑回归参数的时候，会发现我们的<strong>优化目标不是凸优化</strong>，只能找到多个局部最优值，梯度下降法很可能找不到全局最优值，虽然平方差是一个不错的损失函数，但是我们在逻辑回归模型中会定义另外一个损失函数。</p></li><li><p>我们常看到两个交叉熵损失函数对应不同的最后一层的输出。第一个对应的最后一层是 sigmoid，用于二分类问题，第二个对应的最后一层是 softmax，用于多分类问题。但是它们的本质是一样的。</p><p><span class="math inline">\(\begin{array}{c}{\operatorname{cost}\left(h_{\theta}(x), y\right)=-y_{i} \log \left(h_{\theta}(x)\right)-\left(1-y_{i}\right) \log \left(1-h_{\theta}(x)\right)} \\ {C=-\sum_{i}\left(y_{i} \log a_{i}\right)}\end{array}\)</span></p><p>sigmoid 作为最后一层输出的话，那就不能吧最后一层的输出看作成一个分布了，因为加起来不为 1。现在应该将最后一层的每个神经元看作一个分布。</p></li></ul></li></ul></li></ul><p><a href="https://blog.csdn.net/tsyccnh/article/details/79163834">交叉熵的相关推导1</a></p><p><a href="https://blog.csdn.net/xu_ampl/article/details/95179849">交叉熵推导2</a></p><p><a href="https://blog.csdn.net/lanchunhui/article/details/75433608">二项分布、最大似然、交叉熵</a></p><ul><li><p><strong>二分类、多分类与多标签的基本概念</strong></p><p><strong>二分类：</strong>表示分类任务中有两个类别，比如我们想识别一幅图片是不是猫。也就是说，训练一个分类器，输入一幅图片，用特征向量x表示，输出是不是猫，用y=0或1表示。二类分类是假设每个样本都被设置了一个且仅有一个标签 0 或者 1。</p><p><strong>多类分类(Multiclass classification):</strong> 表示分类任务中有多个类别, 比如对一堆水果图片分类, 它们可能是橘子、苹果、梨等. 多类分类是假设每个样本都被设置了一个且仅有一个标签: 一个水果可以是苹果或者梨, 但是同时不可能是两者。</p><p><strong>多标签分类(Multilabel classification):</strong> 给每个样本一系列的目标标签. 可以想象成一个数据点的各属性不是相互排斥的(一个水果既是苹果又是梨就是相互排斥的), 比如一个文档相关的话题. 一个文本可能被同时认为是宗教、政治、金融或者教育相关话题。</p><p><strong>参考交叉熵的相关推导1</strong></p><p>多类分类（单标签）时，每张图片的损失是一个交叉熵，交叉熵针对的是所有类别（所有类别概率和是1，使用softmax）。 多标签分类时，每张图片的损失是N个交叉熵之和（N等于类别数），交叉熵针对的是单个类别（单个类别概率和是1）。</p><p>链接：<a href="https://blog.csdn.net/u011734144/article/details/80915559" class="uri">https://blog.csdn.net/u011734144/article/details/80915559</a></p><p>链接：<a href="https://juejin.im/post/5b38971be51d4558b10aad26" class="uri">https://juejin.im/post/5b38971be51d4558b10aad26</a></p><p><img src="Snipaste_2019-10-21_10-44-33.png" /></p></li><li><p><strong>端到端</strong></p><p>深度学习有时也称为<strong>端到端机器学习（end-to-end machine learning</strong>）。这里所说的端到端是指从一端到另一端的意思，也就是从原始数据（输入）中获得目标结果（输出）的意思。</p></li><li><p><strong>mini_batch</strong></p><p>通过抽取一部分的训练数据来学习和计算误差函数，减小计算量。编程矩阵运算，程序实现参考。[P91]</p></li><li><p>在进行神经网络的学习时，不能将识别精度作为指标。因为如果以识别精度为指标，则参数的导数在绝大多数地方都会变为0。[P93]</p></li><li><p><strong>梯度下降法</strong></p><p>设有函数 <span class="math inline">\(f(x_0,x_1)\)</span> ,像 <span class="math inline">\(\left(\frac{\partial f}{\partial x_{0}}, \frac{\partial f}{\partial x_{1}}\right)\)</span> 这样的由全部变量的偏导数汇总而成的向量称为梯度 <span class="math inline">\(\operatorname{grad} f\left(x_{0}, x_{1}, \ldots, x_{n}\right)=\left(\frac{\partial f}{\partial x_{0}}, \ldots, \frac{\partial f}{\partial x_{j}}, \ldots, \frac{\partial f}{\partial x_{n}}\right)\)</span> ，<strong>梯度法公式：</strong> <span class="math inline">\(x_{i}=x_{i}-\eta \frac{\partial f}{\partial x_{i}}\)</span> 其中 <span class="math inline">\(\eta\)</span> 称为学习率。</p><p>公式含义是在每个变量轴上减小对应变量值。梯度不一定是指向了最低处,实际上，梯度指示的方向是各点处的函数值减小最多的方向。既然在变量空间的某一点处，函数沿梯度方向具有最大的变化率，那么在优化目标函数的时候，自然是<strong>沿着负梯度方向去减小函数值</strong>，以此达到我们的优化目标。</p><ul><li>求梯度的两种方法：① 基于数值微分的方法（中心差分和前向差分，速度慢，一般不容易出错，用于比对验证结果正确性）② 解析性地求解数学式的方法（反向传播，速度快）。</li><li>导数、偏导数、梯度的定义 <a href="https://www.cnblogs.com/lingjiajun/p/9895753.html">链接</a></li></ul></li><li><p><strong>学习高原</strong></p><p>函数的<strong>极小值、最小值</strong>以及被称为<strong>鞍点（saddle point）</strong>的地方，梯度为0。极小值是局部最小值，也就是限定在某个范围内的最小值。鞍点是从某个方向上看是极大值，从另一个方向上看则是极小值的点。虽然梯度法是要寻找梯度为0的地方，但是那个地方不一定就是最小值（也有可能是极小值或者鞍点）。此外，当函数很复杂且呈扁平状时，学习可能会进入一个（几乎）平坦的地区，陷入被称为“<strong>学习高原</strong>”的无法前进的停滞期。</p></li><li><p><strong>学习率、超参数</strong></p><p>学习率这样的参数称为超参数。这是一种和神经网络的参数（权重和偏置）性质不同的参数。相对于神经网络的权重参数是通过训练数据和学习算法自动获得的，学习率这样的超参数则是人工设定的。一般来说，超参数需要尝试多个值，以便找到一种可以使学习顺利进行的设定。<strong>常见超参数包括：</strong> 树的数量或树的深度、矩阵分解中潜在因素的数量、学习率（多种模式）、深层神经网络隐藏层数、k均值聚类中的簇数。</p></li><li><p><strong>随机梯度下降法（stochastic gradient descent）</strong></p><p>对随机选择的数据进行的梯度下降法，结合mini_batch计算损失函数并利用梯度下降法求解参数。</p></li><li><p><strong>epoch</strong></p><p>epoch是一个单位。一个epoch表示学习中所有训练数据均被使用过一次时的更新次数。比如，对于10000笔训练数据，用大小为100笔数据的mini-batch进行学习时，重复随机梯度下降法100次，所有的训练数据就都被“看过”了A 。此时，100次就是一个epoch。</p><p>一般做法是事先<strong>将所有训练数据随机打乱</strong>，然后按指定的批次大小，按序生成mini-batch。这样每个mini-batch均有一个索引号，比如可以是0, 1, 2, . . . , 99，然后用索引号可以遍历所有的mini-batch。遍历一次所有数据，就称为一个epoch。</p></li><li><p><strong>过拟合（overfitting）与欠拟合（underfitting）</strong></p><ul><li><p><strong>欠拟合问题</strong>，根本的原因是特征维度过少，导致拟合的函数无法满足训练集，误差较大。</p><p>解决方法</p><pre><code class="hljs text">增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间;尝试非线性模型，比如核SVM 、决策树、DNN等模型;如果有正则项可以较小正则项参数 $\lambda$;Boosting ,Boosting 往往会有较小的 Bias，比如 Gradient Boosting 等.</code></pre></li><li><p><strong>过拟合问题</strong>，根本的原因则是特征维度过多，导致拟合的函数完美的经过训练集，但是对新数据的预测结果则较差。</p><p>解决方法</p><pre><code class="hljs text">交叉检验，通过交叉检验得到较优的模型参数;特征选择，减少特征数或使用较少的特征组合，对于按区间离散化的特征，增大划分的区间;正则化，常用的有 L1、L2 正则。而且 L1正则还可以自动进行特征选择;如果有正则项则可以考虑增大正则项参数 lambda;增加训练数据可以有限的避免过拟合;Bagging ,将多个弱学习器Bagging 一下效果会好很多，比如随机森林等.</code></pre></li></ul></li></ul><hr /><h2 id="误差反向传播法">误差反向传播法</h2><p>一个能够高效计算权重参数的梯度的方法。BP算法是“误差反向传播”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来训练人工神经网络的常见方法。该方法对网络中所有权重计算损失函数的梯度。反向传播计算导数的原理是<strong>链式法则</strong>。</p><ul><li><p><strong>简单加法层和乘法层</strong></p><p>反向传播时，加法节点直接传递上层导数，乘法节点需要交换输入作为系数与导数相乘。（三个呢？）</p></li><li><p><strong>激活函数层</strong></p><ul><li><p><strong>ReLU层</strong></p><p>对激活函数 <span class="math inline">\(h(x)=\left\{\begin{array}{ll}{x} &amp; {(x&gt;0)} \\ {0} &amp; {(x \leqslant 0)}\end{array}\right.\)</span> <span class="math inline">\({求偏导} \Longrightarrow\)</span> <span class="math inline">\(\frac{\partial y}{\partial x}=\left\{\begin{array}{ll}{1} &amp; {(x&gt;0)} \\ {0} &amp; {(x \leqslant 0)}\end{array}\right.\)</span> ，易知，如果正向传播时的输入x大于0，则反向传播会将上游的值原封不动地传给下游。如果正向传播时的x小于等于0，则反向传播中传给下游的信号将停在此处。（类比开关）</p><p><img src="Snipaste_2019-09-25_15-41-45.png" /></p></li><li><p><strong>Sigmoid层</strong></p><p>激活函数 <span class="math inline">\(h(x) = \frac{1}{1+exp(-x)}\)</span> 的反向传播如下图</p><p><img src="Snipaste_2019-09-25_16-33-50.png" /></p><p>相比ReLU，不仅包含加法和乘法层，还需要计算指数exp()和除法“/”，最后反向传播得到的偏导数可以整理如下：<span class="math inline">\(\begin{aligned} \frac{\partial L}{\partial y} y^{2} \exp (-x) &amp;=\frac{\partial L}{\partial y} \frac{1}{(1+\exp (-x))^{2}} \exp (-x) \\ &amp;=\frac{\partial L}{\partial y} \frac{1}{1+\exp (-x)} \frac{\exp (-x)}{1+\exp (-x)} \\ &amp;=\frac{\partial L}{\partial y} y(1-y) \end{aligned}\)</span> .</p><p>易知，正向传播的结果y可以保存，而后用于计算反向传播时的偏导数。</p></li></ul></li><li><p><strong>Affine/Softmax层</strong></p><ul><li><p><strong>Affine层</strong></p><p>$  $ 分别是形状为(2,)、(2, 3)、(3,)的多维数组，所以，神经元的加权和可以用 <span class="math inline">\(Y = np.dot(X, W) + B\)</span> 计算出来。神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换”。因此，将进行<strong>仿射变换</strong>的处理实现为“Affine层”。其反向传播（使用批处理，N个一组）的计算图如下：</p><p><img src="Snipaste_2019-09-26_17-34-14.png" /></p><p>需要注意的是，正向传播时，偏置会被加到每一个数据上。因此，反向传播时，各个数据的反向传播的值需要汇总为偏置的元素，即偏置 <span class="math inline">\(\boldsymbol{B}\)</span> 需要在列方向（axis = 0）上求和。</p></li><li><p><strong>Softmax-with-Loss 层</strong></p><p><img src="Snipaste_2019-09-26_18-33-06.png" /></p><p>Softmax-with-Loss = Softmax Layer + Multinomial Logistic Loss Layer（交叉熵代价函数） +</p><p>上图是该层的计算图，易知：（这张图有疑问）</p><ol type="1"><li>Softmax层将输入 <span class="math inline">\((a_1,a_2,a_3)\)</span> 正规化，输出 <span class="math inline">\((y_1,y_2,y_3)\)</span> .</li><li>Cross Entropy Error层接收Softmax的输出 <span class="math inline">\((y_1,y_2,y_3)\)</span> 和标签<span class="math inline">\((t_1,t_2,t_3)\)</span> ，从这些数据中输出损失L.</li></ol><p>推导过程：<a href="https://blog.csdn.net/yiranlun3/article/details/78632752">链接</a></p><p><img src="Snipaste_2019-10-19_20-02-01.png" /></p></li></ul></li></ul><hr /><h2 id="神经网络训练技巧">神经网络训练技巧</h2><ul><li><p><strong>参数更新最优化方法</strong></p><p>总结：</p><p><img src="Snipaste_2019-10-18_22-22-17.png" /></p><p><strong>最优化</strong> 是神经网络学习找到使损失函数的值尽可能小的参数的过程。</p><p>原文链接：<a href="https://blog.csdn.net/u010089444/article/details/76725843"><链接></a></p><p>参考论文：<a href="http://ruder.io/optimizing-gradient-descent/index.html"><链接></a></p><p>参考博客：<a href="http://zh.d2l.ai/chapter_optimization/rmsprop.html"><链接></a></p><ul><li><p><strong>梯度下降法</strong></p><p><span class="math inline">\(W \leftarrow W - \eta \frac{\partial{L}}{\partial{W}}\)</span> 这是SGD的数学表达，权重W可以用梯度下降的方式求得。SGD简单一如实现，但它的缺点是，如果函数的形状非均向（anisotropic），比如呈延伸状（导致导致梯度并不指向最小值的方向），搜索的路径就会非常低效。</p><p><strong>Batch Gradient Descent</strong> 在每一轮的训练过程中，Batch Gradient Descent算法用整个训练集的数据计算cost fuction的梯度，并用该梯度对模型参数进行更新。</p><p>优点：cost fuction若为凸函数，能够保证收敛到全局最优值；若为非凸函数，能够收敛到局部最优值。 缺点：由于每轮迭代都需要在整个数据集上计算一次，所以批量梯度下降可能非常慢训练数较多时，需要较大内存批量梯度下降不允许在线更新模型，例如新增实例。</p><p><strong>Stochastic Gradient Descent</strong> 和批梯度下降算法相反，Stochastic gradient descent 算法每读入一个数据，便立刻计算cost fuction的梯度来更新参数。</p><p>优点：算法收敛速度快(在Batch Gradient Descent算法中, 每轮会计算很多相似样本的梯度, 这部分是冗余的)可以在线更新有几率跳出一个比较差的局部最优而收敛到一个更好的局部最优甚至是全局最优。 缺点：容易收敛到局部最优，并且容易被困在鞍点。</p><p><strong>Mini-batch Gradient Descent</strong> mini-batch Gradient Descent的方法是在上述两个方法中取折衷, 每次从所有训练数据中取一个子集（mini-batch） 用于计算梯度：Mini-batch Gradient Descent在每轮迭代中仅仅计算一个mini-batch的梯度，不仅计算效率高，而且收敛较为稳定。该方法是目前深度学训练中的主流方法。</p><p><strong>上述三个方法面临的主要挑战</strong></p><p>选择适当的学习率α较为困难。太小的学习率会导致收敛缓慢，而学习速度太块会造成较大波动，妨碍收敛。</p><p>目前可采用的方法是在训练过程中调整学习率大小，例如模拟退火算法：预先定义一个迭代次数m，每执行完m次训练便减小学习率，或者当cost function的值低于一个阈值时减小学习率。然而迭代次数和阈值必须事先定义，因此无法适应数据集的特点。</p><p>上述方法中, 每个参数的 learning rate 都是相同的，这种做法是不合理的：如果训练数据是稀疏的，并且不同特征的出现频率差异较大，那么比较合理的做法是对于出现频率低的特征设置较大的学习速率，对于出现频率较大的特征数据设置较小的学习速率。</p><p>近期的的研究表明，深层神经网络之所以比较难训练，并不是因为容易进入local minimum。相反，由于网络结构非常复杂，在绝大多数情况下即使是 local minimum 也可以得到非常好的结果。而之所以难训练是因为学习过程容易陷入到马鞍面中，即在坡面上，一部分点是上升的，一部分点是下降的。而这种情况比较容易出现在平坦区域，在这种区域中，所有方向的梯度值都几乎是 0。</p></li><li><p><strong>Momentum</strong></p><p>意为“动量”，数学表达为 <span class="math inline">\(\nu \leftarrow \alpha \nu - \eta \frac{\partial{L}}{\partial{W}}\)</span>, <span class="math inline">\(W \leftarrow W + \nu\)</span> .</p><p>和前面的SGD一样，W表示要更新的权重参数，<span class="math inline">\(\frac{\partial{L}}{\partial{W}}\)</span>表示损失函数关于W的梯度，η表示学习率。这里新出现了一个变量<span class="math inline">\(\nu\)</span>，对应物理上的速度，超参数<span class="math inline">\(\alpha\)</span> 一般设定0.9。</p><p>SGD方法的一个缺点是其更新方向完全依赖于当前batch计算出的梯度，因而十分不稳定。Momentum算法借用了物理中的动量概念，它模拟的是物体运动时的惯性，即更新的时候在一定程度上保留之前更新的方向：Momentum算法会观察历史梯度<span class="math inline">\(v_{t-1}\)</span> ，若当前梯度的方向与历史梯度一致（表明当前样本不太可能为异常点），则会增强这个方向的梯度，若当前梯度与历史梯方向不一致，则梯度会衰减。<strong>一种形象的解释是：</strong>我们把一个球推下山，球在下坡时积聚动量，在途中变得越来越快，γ可视为空气阻力，若球的方向发生变化，则动量会衰减。</p></li><li><p><strong>AdaGrad（Adaptive Gradient）</strong></p><p>上述方法中，对于每一个参数的训练都使用了相同的学习率α。AdaGrad算法能够在训练中自动的对learning rate进行调整，对于出现频率较低参数采用较大的α更新；相反，对于出现频率较高的参数采用较小的α更新。因此，AdaGrad非常适合处理稀疏数据。<span class="math inline">\(\epsilon\)</span> 是平滑项，用于避免分母为0，一般取值1e−8。</p><p>数学表示如下：<span class="math inline">\(h \leftarrow h + \frac{\partial{L}}{\partial{W}} \bigodot \frac{\partial{L}}{\partial{W}}\)</span> , <span class="math inline">\(W \leftarrow W - \eta \frac{1}{\sqrt{h + \epsilon}} \frac{\partial {L}}{\partial{W}}\)</span> . （h初值可设为0）</p><p>简单来讲，设置全局学习率之后，每次通过，全局学习率逐参数的除以历史梯度平方和的平方根，使得每个参数的学习率不同，在某些模型上效果不错。效果是：在参数空间更为平缓的方向，会取得更大的进步（因为平缓，所以历史梯度平方和较小，对应学习下降的幅度较小）。<strong>Adagrad的缺点</strong>是在训练的中后期，分母上梯度平方的累加将会越来越大，从而梯度趋近于0，使得训练提前结束。</p></li><li><p><strong>Nesterov Momentum</strong></p><p>[空]</p></li><li><p><strong>RMSprop</strong></p><p>RMSprop是Geoff Hinton提出的一种自适应学习率方法。Adagrad会累加之前所有的梯度平方，而RMSprop仅仅是计算对应的平均值，因此可缓解Adagrad算法学习率下降较快的问题。<strong>可以看出RMSProp优化算法和AdaGrad算法唯一的不同，就在于累积平方梯度的求法不同。</strong></p><p>数学描述如下：</p><p>​ <span class="math inline">\(\boldsymbol{s}_{t} \leftarrow \gamma \boldsymbol{s}_{t-1}+(1-\gamma) \boldsymbol{g}_{t} \odot \boldsymbol{g}_{t}\)</span></p><p>​ <span class="math inline">\(\boldsymbol{x}_{t} \leftarrow \boldsymbol{x}_{t-1}-\frac{\eta}{\sqrt{\boldsymbol{s}_{t}+\epsilon}} \odot \boldsymbol{g}_{t}\)</span></p><p>(Hinton 建议 γ 为 0.9, 学习率 η 为 0.001)</p></li><li><p><strong>Adam</strong></p><p>Adam(Adaptive Moment Estimation)是另一种自适应学习率的方法。它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。Adam的优点主要在于经过偏置校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳。</p><p>数学描述如下：(稍复杂，稍后再看)</p><p><span class="math inline">\(\begin{array}{l}{m_{t}=\beta_{1} m_{t-1}+\left(1-\beta_{1}\right) g_{t}} \\ {v_{t}=\beta_{2} v_{t-1}+\left(1-\beta_{2}\right) g_{t}^{2}} \end{array} \;\;; \begin{array}{l}{\hat{m}_{t}=\frac{m_{t}}{1-\beta_{1}^{t}}} \\ {\hat{v}_{t}=\frac{v_{t}}{1-\beta_{2}^{t}}}\end{array} \\\;\;; \begin{array}{c} {\Theta_{t+1}=\Theta_{t}-\frac{\alpha}{\sqrt{\hat{v}_{t}}+\epsilon} \hat{m}_{t}}\end{array}\)</span></p><p>建议 <span class="math inline">\(\beta_1 ＝ 0.9，\beta_2 ＝ 0.999，\epsilon ＝ 10e−8\)</span>;</p><p>实践表明，Adam 比其他适应性学习方法效果要好。</p></li></ul></li><li><p><strong>权重初始化(weight initialization)</strong></p><ul><li><p><strong>梯度消失问题和梯度爆炸问题</strong></p><p><strong>梯度消失（gradient vanishing problem）：</strong>在神经网络中，当前面隐藏层的学习速率低于后面隐藏层的学习速率，即随着隐藏层数目的增加，分类准确率反而下降了。这种现象叫做消失的梯度问题。</p><p><strong>梯度爆炸（gradient exploding problem）：</strong>在深层网络或递归神经网络中，误差梯度在更新中累积得到一个非常大的梯度，这样的梯度会大幅度更新网络参数，进而导致网络不稳定。在极端情况下，权重的值变得特别大，以至于结果会溢出（NaN值，无穷与非数值）。当梯度爆炸发生时，网络层之间反复乘以大于1.0的梯度值使得梯度值成倍增长。</p></li><li><p><strong>随机产生权重</strong></p><p>权重不可以设置成一样的值。BP过程会导致所有权重进行相同的更新（值相同，且对称），无论网络训练多少轮，对于每一层中的各个神经元，权重w都是相同的，无法学习（提取）到不同的特征。所以为了防止“权重均一化”，必须随机生成初始值。</p></li><li><p><strong>Xavier初始值</strong>（['zeɪvɪr]）</p><p>论文链接：<a href="http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf"><链接></a></p><p>Xavier初始值是以激活函数是线性函数为前提而推导出来的（sigmoid 函数和 tanh 函数左右对称，且中央附近可以视作线性函数）。Xavier的论文中，为了使各层的激活值呈现出具有相同广度的分布，推导了合适的权重尺度。推导出的结论是，如果前一层的节点数为n，则初始值使用标准差为 <span class="math inline">\(\frac{1}{\sqrt n}\)</span> 的分布，其中n表示与前一层有n个节点连接 。</p></li><li><p><strong>He初始值</strong></p><p>论文链接：<a href="https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/He_Delving_Deep_into_ICCV_2015_paper.pdf"><链接></a></p><p>在ReLU网络中，假定每一层有一半的神经元被激活，另一半为0，所以，要保持variance不变，只需要在Xavier的基础上再除以2。</p></li></ul></li><li><p><strong>Batch Normalization</strong></p><p>顾名思义，Batch Normalization（BN）就是“批规范化”。Google在ICML文中描述的非常清晰，即在每次SGD时，通过mini-batch来对相应的activation做规范化操作，使得结果（输出信号各个维度）的均值为0，方差为1. 而最后的“scale and shift”操作则是为了让因训练所需而“刻意”加入的BN能够有可能还原最初的输入（即当 <span class="math inline">\(\gamma^{(k)}=\sqrt{\operatorname{Var}\left[x^{(k)}\right], \beta^{(k)}}=E\left[x^{(k)}\right]\)</span> ），从而保证整个网络的capacity。</p><ul><li><p><strong>优点：</strong> ① 可以使学习快速进行（可以增大学习率）；② 不那么依赖初始值（对于初始值不用那么神经质）；③ 抑制过拟合（降低Dropout等的必要性）。</p></li><li><p>数学表示： $</p><span class="math display">\[\begin{aligned} \mu_{B} &amp; \leftarrow \frac{1}{m} \sum_{i=1}^{m} x_{i} \\ \sigma_{B}^{2} &amp; \leftarrow \frac{1}{m} \sum_{i=1}^{m}\left(x_{i}-\mu_{B}\right)^{2} \\ \hat{x}_{i} &amp; \leftarrow \frac{x_{i}-\mu_{B}}{\sqrt{\sigma_{B}^{2}+\varepsilon}}｛此处转换为新数据B = \{ \hat{x}_{1} , \hat{x}_{2}, ... , \hat{x}_{m} \}｝ \\ y_{i} &amp; \leftarrow \gamma \hat{x}_{i}+\beta  ｛BN层会对正规化后的数据进行缩放和平移的变换｝\end{aligned}\]</span><p>$</p><p>这里对mini-batch的m个输入数据的集合<span class="math inline">\(B = \{ x_1 , x_2 , ... , x_m \}\)</span> 求均值 <span class="math inline">\(\mu_B\)</span>和方差 <span class="math inline">\(\sigma^2_B\)</span> 。然后，对输入数据进行均值为0、方差为1（合适的分布）的正规化。第3式中的 <span class="math inline">\(\epsilon\)</span> 是一个微小值（e.g.取值10e-7 等），它是为了防止出现除以0的情况。计算图如下：</p><p><img src="Snipaste_2019-10-06_23-18-47.png" /></p><p><a href="https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html">Frederik Kratzert的博客</a>“Understanding the backward pass through Batch Normalization Layer”里有详细说明</p></li></ul></li><li><p><strong>正则化（Regularizer）</strong></p><ul><li><p>过拟合主要原因：模型拥有大量参数，表现力强；训练数据少</p></li><li><p><strong>权值衰减（Weight Decay）</strong>:常被使用的一种抑制过拟合的方法。该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。很多过拟合原本就是因为权重参数取值过大才发生的。数学表示如下：</p><p>原始权重更新为 <span class="math inline">\(w_i \leftarrow w_i - \eta \frac{\partial L}{\partial w_i}\)</span> ，现在在损失函数L中增加一项权值衰减项 <span class="math inline">\(\frac{\lambda}{2}W^2\)</span>（这是权重的<strong>L2范数</strong>，<strong>λ是控制正则化强度的超参数</strong>）来抑制权值变大，损失函数变为 $ L(W) = L(W) + W^2$ ，在求权重梯度的计算中，要为之前的误差反向传播法的结果加上正则化项的导数 <span class="math inline">\(\lambda W\)</span> ，权重更新为 <span class="math inline">\(w_i \leftarrow w_i - \eta \frac{\partial L}{\partial w_i} - \eta \lambda W\)</span> 。</p></li><li><p><strong>Dropout</strong></p><p>在深度学习网络的训练过程中，对于神经网络单元，按照一定的概率将其暂时从网络中丢弃。注意是暂时，对于随机梯度下降来说，由于是随机丢弃，故而每一个mini-batch都在训练不同的网络。</p><p>​</p></li></ul></li><li><p><strong>超参数与验证数据</strong></p><p>数据集分成训练数据和测试数据，训练数据用于学习，测试数据用于评估泛化能力。调整超参数时，必须使用超参数专用的确认数据，这类数据称为<strong>验证数据（validation data）</strong>。<strong>不能用测试数据评估超参数的性能。</strong></p><ul><li>超参数最优化的步骤：设定超参数范围；从设定范围中随机采样；使用选出的超参数进行训练并在验证集上测试识别精度；重复上述步骤（100次左右），根据识别进度进一步缩小超参数范围。</li><li>其他：贝叶斯最优化（论文 Practical Bayesian Optimization of Machine Learning Algorithms）</li></ul></li></ul><hr /><h2 id="卷积神经网络">卷积神经网络</h2><ul><li><p><strong>全连接层的作用</strong></p><p>全连接层（fully connected layers，FC）在整个卷积神经网络中起到“分类器”的作用。如果说卷积层、池化层和激活函数层等操作是将原始数据映射到隐层特征空间的话，全连接层则起到将学到的“分布式特征表示”映射到样本标记空间的作用。（全连接层可以转化为卷积核为1x1的卷积）</p><p>FC层的冗余的参数可保持较大的模型capacity从而保证模型表示能力的迁移。</p></li><li><p><strong>卷积层（Convolutional Layer）</strong></p><p>卷积层是全连接的一种简化形式:不全连接+参数共享，同时还保留了空间位置信息。</p><p>一般全连接层损失了数据的形状这一特征，而卷积层接受三维的数据。卷积层的输入输出又被称为<strong>输入/输出特征图</strong>。卷积运算符号为“<span class="math inline">\(\bigotimes\)</span>”，卷积运算需要有到卷积核（又称“滤波器”）。</p><ul><li>数学描述： <span class="math inline">\((f * g)(1,1)=\sum_{k=0}^{2} \sum_{h=0}^{2} f(h, k) g(1-h, 1-k)\)</span></li></ul><p><strong>一句话解释什么是卷积</strong>：一个函数（如：单位响应）在另一个函数（如：输入信号）上的<strong>加权叠加。</strong>“信号与响应的卷积”体现的是时间上的“加权求和”；“图像平滑处理的卷积”体现的是空间上的“加权求和”。 <a href="https://www.zhihu.com/question/22298352">知乎链接</a></p><ul><li><strong>填充</strong>：卷积运算会使得原来的数据形状缩小，在边界四周需要填补若干圈数据（例如0），填补的数据宽度称为<strong>幅度</strong>（padding）</li><li><strong>步幅</strong>：应用滤波器的位置间隔称为<strong>步幅</strong>（stride）</li></ul><p>假设输入大小为(H, W)，滤波器大小为(FH, FW)，输出大小为(OH, OW)，填充为P，步幅为S。此时，输出大小可通过下式进行计算：<span class="math inline">\(\begin{array}{l} OH &amp; = \frac{H + 2P - FH}{S} + 1 \\ OW &amp; = \frac{W + 2P - FW}{S} + 1 \end{array}\)</span></p><p><strong>卷积核为什么是奇数大小</strong>：保证了锚点刚好在中间；填充的像素可以平均分配在图像四周。</p><p>多维卷积：除了考虑长宽方向，还需要处理通道数，并将各通道的结果相加输出。通道数应设定为和输入数据的通道数相同的值。</p><p>把3维数据表示为多维数组时，书写顺序为（channel, height, width）。比如，通道数为C、高度为H、长度为W的数据的形状可以写成（C, H, W），滤波器同。在通道方向上也拥有多个卷积运算，数量FN，得到的特征图传到下一层就是CNN的处理流（含偏置，也使用mini-batch）。运算过程参考下图：</p><p><img src="Snipaste_2019-10-07_19-56-03.png" /></p><p><strong>卷积层作用</strong>：</p><ol type="1"><li>提取图像的特征，并且卷积核的权重是可以学习的，由此可以猜测，在高层神经网络中，卷积操作能突破传统滤波器的限制，根据目标函数提取出想要的特征。</li><li>“局部感知，参数共享”的特点大大降低了网络参数，保证了网络的稀疏性，防止过拟合之所以可以“参数共享”，是因为样本存在局部相关的特性。</li></ol><ul><li><p><strong>主要参数</strong></p><p>CNN网络的主要参数有下面这么几个：</p><ul><li>卷积核Kernal权重（在Tensorflow中称为filter）；</li><li>填充Padding；</li><li>滑动步长Strides；</li><li>池化核Kernal（在Tensorflow中称为filter）；</li><li>通道数Channels。</li></ul></li></ul><p><font color = "red">???卷积层的反向传播</font></p></li><li><p><strong>池化层（Pooling Layer）</strong></p><p>池化是缩小高、长方向上的空间的运算。一般来说，池化的窗口大小会和步幅设定成相同的值。池化有Max池化和Average池化，相对于Max池化是从目标区域中取出最大值，Average池化则是计算目标区域的平均值。在图像识别领域，主要使用Max池化。池化层没有要训练的参数，且运算后不改变通道数。输入数据发生微小偏差时，池化仍会返回相同的结果。因此，池化对输入数据的微小偏差具有鲁棒性。</p><p><strong>池化种类</strong>：一般池化（General Pooling，最大和平均池化）、重叠池化（Overlapping Pooling，相邻池化窗口之间<strong>有重叠区域</strong>，此时一般sizeX &gt; stride）、<a href="https://blog.csdn.net/g11d111/article/details/80789538">空间金字塔池化</a>（Spatial Pyramid Pooling）</p><p><strong>池化层作用</strong>：特征不变性（feature invariant）、特征降维、在一定程度上能防止过拟合的发生 。</p></li><li><p><a href="https://blog.csdn.net/dwyane12138/article/details/78449898#commentBox">使用im2col展开优化卷积计算</a> （位置7.4.3）<a href="https://zhuanlan.zhihu.com/p/63974249">知乎链接</a></p></li><li><p><strong>常见卷积神经网络</strong></p><ol type="1"><li><p>LeNet</p><p>LeNet有几个不同点：第一个不同点在于激活函数。LeNet中使用sigmoid函数，而现在的CNN中主要使用ReLU函数。此外，原始的LeNet中使用子采样（subsampling）缩小中间数据的大小，而现在的CNN中Max池化是主流。AlexNet还使用了进行局部正规化的LRN（Local Response Normalization）层。</p></li><li><p>AlexNet</p></li><li><p>ZF</p></li><li><p>VGG</p></li><li><p>GoogLeNet</p></li><li><p>ResNet</p></li><li><p>DenseNet</p></li></ol></li></ul><p><font color = red>(!!!经典网络的论文没看)</font></p><ul><li><p>迁移学习、集成学习</p></li><li><p>组合图像和自然语言等多种信息进行的处理称为<strong>多模态处理</strong></p></li><li><p>DCGAN（Deep Convolutional Generative Adversarial Network）</p><p>技术要点是使用了Generator（生成者）和Discriminator（识别者）这两个神经网络</p></li></ul><hr /><h2 id="总结">总结</h2><ol type="1"><li>Python常用数学与图形库的使用</li><li>感知机基本概念和实现</li><li>学习了DL和ANN基本理论（层、权重、激活函数、误差函数等）</li><li>神经网络的基本训练流程、数值微分法</li><li>计算图的概念和反向传播</li><li>寻找最优权重的优化方法（Batch Normalization、SGD、Momentum、Adam等）、参数初始化以及超参数搜索</li><li>CNN卷积层、池化层，了解了LeNet、AlexNet、ResNet、DenseNet（相关论文未看）</li><li>为什么深度学习表现优异、为什么加深层能提高识别精度、为什么隐藏层很重要等问题（见笔记）</li><li>Python实现梯度下降法求最优参数、手写数字识别、超参数搜索</li></ol><hr /><h2 id="to-do">TO-DO</h2><ul class="task-list"><li><input type="checkbox" disabled="" />误差反向传播的代码值得研究研究</li><li><input type="checkbox" disabled="" />numpy和matplotlib使用方法</li><li><input type="checkbox" disabled="" />线性代数和概率论、函数求导</li><li><input type="checkbox" disabled="" />实现基于MNIST的神经网络 P73关于pickle的使用以及代码细节还未细看</li><li><input type="checkbox" disabled="" checked="" />argmax解析：<a href="https://blog.csdn.net/weixin_38145317/article/details/79650188">链接</a></li><li><input type="checkbox" disabled="" checked="" />python中类的继承、类方法、实例变量与类变量：<a href="https://www.cnblogs.com/kex1n/p/5979366.html">链接</a></li><li><input type="checkbox" disabled="" checked="" />python实现数值微分时，需要注意浮点数舍入误差，使用中间差分代替前向差分。[P95]</li><li><input type="checkbox" disabled="" />掌握python的图表绘制基本操作，散点图、三维图、梯度图，多个曲线的合并，图表标签设置、坐标轴设置</li><li><input type="checkbox" disabled="" checked="" />python实例变量和类变量辨析：<a href="http://kuanghy.github.io/2015/12/19/python-variable">链接</a></li><li><input type="checkbox" disabled="" />ILSVRC ImageNet Large Scale Visual Recognition Challenge</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法整理（更新中...）</title>
    <link href="/2019/05/21/2019-05-21-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2019/05/21/2019-05-21-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ul><li><h1 id="算法整理"><font color="#0000dd">算法整理</font></h1><h2 id="基础数据结构">基础数据结构</h2><h3 id="数组">数组</h3><h3 id="链表双向链表">链表、双向链表</h3><h3 id="队列单调队列优先队列双端队列">队列、单调队列、优先队列、双端队列</h3><h3 id="栈单调栈">栈、单调栈</h3><h2 id="中级数据结构">中级数据结构</h2><h3 id="堆">堆</h3><h3 id="并查集带权并查集">并查集、带权并查集</h3><h3 id="hash表">Hash表</h3><h4 id="自然溢出">自然溢出</h4><h4 id="双hash">双Hash</h4><h2 id="高级数据结构">高级数据结构</h2><h3 id="树状数组">树状数组</h3><p><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/79492190">1</a> <a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/">[2]</a></p><p>i + (i&amp;-1)非常有意思，构造分形图案。i &amp; (~i + 1)</p><h3 id="线段树线段树合并">线段树、线段树合并</h3><h3 id="平衡树">平衡树</h3><h4 id="treap">Treap</h4><h4 id="splay">splay</h4><h4 id="替罪羊树">替罪羊树</h4><h3 id="块状数组块状链表">块状数组、块状链表</h3><h3 id="嵌套数据结构">嵌套数据结构</h3><h4 id="树套树">树套树</h4><h4 id="dp套dp">DP套DP</h4><h3 id="可并堆">可并堆</h3><h4 id="左偏树">左偏树</h4><h4 id="配对堆">配对堆</h4><h3 id="k-d-tree四分树">K-D Tree、四分树</h3><h2 id="可持久化数据结构">可持久化数据结构</h2><h3 id="可持久化线段树">可持久化线段树</h3><h4 id="主席树">主席树</h4><h3 id="可持久化平衡树">可持久化平衡树</h3><h3 id="可持久化并查集">可持久化并查集</h3><h3 id="可持久化块状数组">可持久化块状数组</h3><h2 id="字符串算法">字符串算法</h2><h3 id="kmp">KMP</h3><p>参考资料 <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/">[1]</a> <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">[2]</a></p><h3 id="manacher">Manacher</h3><h3 id="trie">Trie</h3><h3 id="ac自动机">AC自动机</h3><h3 id="后缀数组">后缀数组</h3><h3 id="后缀树">后缀树</h3><h3 id="后缀自动机">后缀自动机</h3><h2 id="图论算法">图论算法</h2><h3 id="图的搜索">图的搜索</h3><h4 id="bfs-dfs"><font color="#00dd00">BFS DFS</font></h4><p>基本思想：BFS使用队列，宽度优先；DFS使用递归写法or非递归(堆栈)实现，深度优先。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_V = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> V, E;<span class="hljs-keyword">int</span> G[MAX_V][MAX_V];<span class="hljs-comment">//邻接矩阵</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><span class="hljs-keyword">int</span> to, cost;Edge(<span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> cost): to(to), cost(cost) &#123;&#125;;&#125;;<span class="hljs-built_in">vector</span>&lt;Edge&gt; M[MAX_V];<span class="hljs-comment">//邻接表</span><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; P;<span class="hljs-comment">//first-to ,second-cost(unused)</span><span class="hljs-keyword">int</span> visited[MAX_V];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;G[u][v] = <span class="hljs-number">1</span>;G[v][u] = <span class="hljs-number">1</span>;M[u].push_back(Edge(v, <span class="hljs-number">0</span>));M[v].push_back(Edge(u, <span class="hljs-number">0</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//递归 邻接矩阵</span><span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;visited[s] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;<span class="hljs-keyword">if</span> ( visited[i] == <span class="hljs-number">0</span> &amp;&amp; G[s][i] != INF) &#123;DFS1(i);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//邻接矩阵</span><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;q.push(s);<span class="hljs-keyword">while</span> (!q.empty()) &#123;<span class="hljs-keyword">int</span> p = q.front();q.pop();<span class="hljs-keyword">if</span> (visited[p] == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;visited[p] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;<span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span> &amp;&amp; G[p][i] &lt; INF) &#123;q.push(i);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//递归 邻接表</span><span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;visited[s] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M[s].size(); i++) &#123;Edge e = M[s][i];<span class="hljs-keyword">if</span> ( visited[e.to] == <span class="hljs-number">0</span>) &#123;DFS1(e.to);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//邻接表</span><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;q.push(s);<span class="hljs-keyword">while</span> (!q.empty()) &#123;<span class="hljs-keyword">int</span> p = q.front();q.pop();<span class="hljs-keyword">if</span> (!visited[p]) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;visited[p] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M[p].size(); i++) &#123;Edge t = M[p][i];<span class="hljs-keyword">if</span> (!visited[t.to]) &#123;q.push(t.to);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//非递归 邻接矩阵</span><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; _s;_s.push(s);<span class="hljs-keyword">while</span> (!_s.empty()) &#123;<span class="hljs-keyword">int</span> p = _s.top();<span class="hljs-keyword">if</span> (!visited[p]) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;visited[p] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;<span class="hljs-keyword">if</span> (!visited[i] &amp;&amp; G[p][i] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// visited[i] = 1;</span><span class="hljs-comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span>_s.push(i);flag = <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;_s.pop();&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//非递归 邻接表</span><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; _s;_s.push(s);<span class="hljs-keyword">while</span> (!_s.empty()) &#123;<span class="hljs-keyword">int</span> p = _s.top();<span class="hljs-keyword">if</span> (!visited[p]) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;visited[p] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M[p].size(); i++) &#123;Edge e = M[p][i];<span class="hljs-keyword">if</span> (!visited[e.to]) &#123;<span class="hljs-comment">// visited[i] = 1;</span><span class="hljs-comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span>_s.push(e.to);flag = <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;_s.pop();&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX_V * MAX_V, INF);<span class="hljs-built_in">cin</span> &gt;&gt; V &gt;&gt; E;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<span class="hljs-keyword">int</span> u, v, w;<span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;add_edge(u, v);&#125;<span class="hljs-keyword">int</span> st = <span class="hljs-number">1</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);DFS1(st);<span class="hljs-comment">//邻接矩阵</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);BFS1(st);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);DFS2(st);<span class="hljs-comment">//邻接表</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);BFS2(st);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);DFS3(st);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);DFS4(st);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment">8 9</span><span class="hljs-comment">1 2</span><span class="hljs-comment">1 3</span><span class="hljs-comment">2 4</span><span class="hljs-comment">2 5</span><span class="hljs-comment">4 8</span><span class="hljs-comment">5 8</span><span class="hljs-comment">3 6</span><span class="hljs-comment">3 7</span><span class="hljs-comment">6 7</span><span class="hljs-comment">*/</span></code></pre><h3 id="最短路径次短路">最短路径、次短路</h3><hr /><p>连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。 强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。 连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。 最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p><hr /><h4 id="dijkstra"><font color="#00dd00">Dijkstra</font></h4><p><strong>基本思想</strong>（邻接矩阵表述）</p><p><a href="https://blog.csdn.net/C2681595858/article/details/85687836#1_Dijkstra_3">参考资料</a></p><p>设定两个集合<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>，<span class="math inline">\(A\)</span>中存放我们已经处理过的顶点，<span class="math inline">\(B\)</span>中存放图中剩余顶点。刚开始的时候，<span class="math inline">\(A\)</span>中只有一个我们选定的起点<span class="math inline">\(v_0\)</span>，每一次从集合<span class="math inline">\(B\)</span>中取到<span class="math inline">\(v_0\)</span>的代价最小的点并入，每一次并入时都需要修改<span class="math inline">\(v_0\)</span>到<span class="math inline">\(B\)</span>中顶点的代价，直到所有的顶点都并入为止。</p><p><strong>算法准备</strong></p><ol type="1"><li><p>数组<span class="math inline">\(dist\)</span>，用于存放<span class="math inline">\(v_0\)</span>到图中个顶点的代价，数组下标表示顶点编号</p></li><li><p>数组<span class="math inline">\(path\)</span>，用于存放路径，数组下标表示顶点编号，下标所对应的数组值表示能够到达当前这个顶点的前一个顶点编号，最后连起来就是<span class="math inline">\(v_0\)</span>到图中各顶点的最短路径了。如果没有前前驱顶点，则内容值为-1。</p></li><li><p>数组<span class="math inline">\(set\)</span>，用于标识图中顶点是否被处理过，数组下标表示顶点编号。处理过为1，没处理过为0。</p></li><li><p>使用图的邻接矩阵来存储有向带权图，<span class="math inline">\(graph[i][j]\)</span>。</p></li></ol><p><strong>算法过程（我们选择编号为0的顶点作为起点）</strong></p><ol type="1"><li>首先进行3个数组的初始化，把set数组全部初始化为0；<span class="math inline">\(dist\)</span>数组全部初始化为无穷大，<span class="math inline">\(path\)</span>数组全部初始化为-1。</li><li>将<span class="math inline">\(set[0]\)</span>的值设置为1，然后遍历邻接矩阵的第0行，依次更新<span class="math inline">\(dist\)</span>数组的每一项。</li><li>将<span class="math inline">\(dist\)</span>数组中值不为无穷大的在<span class="math inline">\(path\)</span>中的对应下标，把它们的值改为0。因为编号为0的点是它们的前驱嘛。</li><li>选择<span class="math inline">\(dist\)</span>数组中值最小的点的下标，这里为1。</li><li>将<span class="math inline">\(set[1]\)</span>的值设置为1</li><li>遍历邻接矩阵的第1行(因为1是最小权值的下标)，将dist[1]的值与邻接矩阵<span class="math inline">\(graph[1][i]\)</span>的值相加（此时是以编号为1的点作为中间点，看看由<span class="math inline">\(v_0\)</span>-&gt;<span class="math inline">\(v_1\)</span>再到其余点的路径长度会不会比<span class="math inline">\(v_0\)</span>直接到它们的路径长度短），如果这个值比dist[i]的值小，就更新<span class="math inline">\(dist[i]\)</span>，同时将<span class="math inline">\(path[i]\)</span>的值设置为1，执行这个操作的前提是，<span class="math inline">\(set[i]==0\)</span>。</li><li>重复（4）~（6）步，如果已经处理过的点就不用再判断了。直到<span class="math inline">\(set\)</span>数组全变为1。</li></ol><pre><code class="hljs C++"><span class="hljs-function">function <span class="hljs-title">Dijkstra</span><span class="hljs-params">(G, w, s)</span></span>for each vertex v in V[G]   // 初始化d[v] := infinity     <span class="hljs-comment">// 将各点的已知最短距离先设成无穷大</span>previous[v] := undefined   <span class="hljs-comment">// 各点的已知最短路径上的前趋都未知</span>d[s] := <span class="hljs-number">0</span>           <span class="hljs-comment">// 因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0</span>S := empty <span class="hljs-built_in">set</span>Q := <span class="hljs-built_in">set</span> of all vertices<span class="hljs-keyword">while</span> Q is <span class="hljs-keyword">not</span> an empty <span class="hljs-built_in">set</span>      <span class="hljs-comment">// Dijkstra算法主体</span>u := Extract_Min(Q)<span class="hljs-comment">//从Q中找一个距离远点s距离最小的点，加入S</span>S.append(u)<span class="hljs-keyword">for</span> each edge outgoing from u as (u,v)<span class="hljs-keyword">if</span> d[v] &gt; d[u] + w(u,v)    <span class="hljs-comment">// 拓展边（u,v）。w(u,v)为从u到v的路径长度。</span>d[v] := d[u] + w(u,v)  <span class="hljs-comment">// 更新路径长度到更小的那个和值。</span>previous[v] := u   <span class="hljs-comment">// 纪录前趋顶点</span></code></pre><pre><code class="hljs C++"><span class="hljs-comment">//采用邻接矩阵存储</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_V = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> V, E;<span class="hljs-keyword">int</span> G[MAX_V][MAX_V];<span class="hljs-keyword">int</span> dist[MAX_V];<span class="hljs-keyword">int</span> path[MAX_V];<span class="hljs-keyword">int</span> visited[MAX_V];<span class="hljs-comment">/*</span><span class="hljs-comment">采用邻接矩阵存储,需要设置visited数组判断是否已经访问过,</span><span class="hljs-comment">保证已计算出最短路的结点访问次数唯一,</span><span class="hljs-comment">作为对比可参考邻接表存储时的相应操作.</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;fill(path, path + MAX_V, <span class="hljs-number">-1</span>);fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;dist[j] = G[s][j];<span class="hljs-keyword">if</span> (G[s][j] &lt; INF) &#123;path[j] = s;&#125;&#125;dist[s] = <span class="hljs-number">0</span>;visited[s] = <span class="hljs-number">1</span>;path[s] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-keyword">int</span> minp = s, minw = INF;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<span class="hljs-keyword">if</span> (visited[j] == <span class="hljs-number">0</span> &amp;&amp; dist[j] &lt; minw) &#123;minw = dist[j];minp = j;&#125;&#125;visited[minp] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<span class="hljs-keyword">if</span> (visited[j] == <span class="hljs-number">0</span> &amp;&amp; minw &lt; INF &amp;&amp; dist[j] &gt; G[minp][j] + minw) &#123;dist[j] = G[minp][j] + minw;path[j] = minp;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ed)</span> </span>&#123;<span class="hljs-keyword">if</span> (path[ed] != <span class="hljs-number">-1</span>)get_path(path[ed]);<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span>;<span class="hljs-built_in">cout</span> &lt;&lt; ed &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; V &gt;&gt; E;fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX_V * MAX_V, INF);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<span class="hljs-keyword">int</span> u, v, w;<span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;G[u][v] = w;&#125;<span class="hljs-keyword">int</span> st = <span class="hljs-number">2</span>, ed = <span class="hljs-number">1</span>;dijkstra(st);get_path(ed);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; dist[ed] &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//采用邻接表存储</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_V = <span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span>    <span class="hljs-keyword">int</span> to, cost;    Edge(<span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> cost): to(to), cost(cost) &#123;&#125;;<span class="hljs-comment">//C++初始化列表-构造函数内容：（参数列表，函数体，初始化列表）</span>&#125;;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; P;<span class="hljs-comment">//first-to ,second-cost</span><span class="hljs-keyword">int</span> V, E;<span class="hljs-built_in">vector</span>&lt;Edge&gt; G[MAX_V];<span class="hljs-keyword">int</span> dist[MAX_V];<span class="hljs-keyword">int</span> path[MAX_V];<span class="hljs-comment">//bool visited[MAX_V];</span><span class="hljs-comment">/*</span><span class="hljs-comment">采用邻接表存储,不需要设置visited数组判断是否已经访问过,</span><span class="hljs-comment">因为采用优先队列维护已经保证访问次数唯一,</span><span class="hljs-comment">作为对比可参考邻接矩阵存储时的相应操作.</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;    <span class="hljs-built_in">priority_queue</span>&lt;P, <span class="hljs-built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;    fill(dist, dist + V + <span class="hljs-number">1</span>, INF);    fill(path, path + V + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);    dist[s] = <span class="hljs-number">0</span>;    path[s] = <span class="hljs-number">0</span>;    que.push(P(s, <span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span> (!que.empty()) &#123;        P p = que.top();        que.pop();        <span class="hljs-keyword">int</span> v = p.first;        <span class="hljs-keyword">if</span> (dist[v] &lt; p.second) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">/*细节问题！这里是剪枝操作，因为之前加入的点更新的距离可能已经不是最短，</span><span class="hljs-comment">        此时找到了另外一条最短路，节点也更新，即在优先队列中存在多个相同顶点序号，</span><span class="hljs-comment">        不同距离的pair&lt;&gt;，例如&lt;2,3&gt;,&lt;2,2&gt;（下面样例）会同时存在，显然，&lt;2,3&gt;这对数据没必要在运行*/</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[v].size(); i++) &#123;            Edge e = G[v][i];            <span class="hljs-keyword">if</span> (dist[e.to] &gt; dist[v] + e.cost) &#123;                dist[e.to] = dist[v] + e.cost;                que.push(P(e.to, dist[e.to]));                path[e.to] = v;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ed)</span> </span>&#123;    <span class="hljs-keyword">if</span> (path[ed]!=<span class="hljs-number">-1</span>)        get_path(path[ed]);    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; ed &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; V &gt;&gt; E;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;        <span class="hljs-keyword">int</span> u, v, w;        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;        G[u].push_back(Edge(v, w));    &#125;    <span class="hljs-keyword">int</span> st = <span class="hljs-number">1</span>, ed = <span class="hljs-number">4</span>;    dijkstra(st);    get_path(ed);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; dist[ed] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">5 7</span><span class="hljs-comment">1 2 1</span><span class="hljs-comment">1 3 4</span><span class="hljs-comment">1 5 1</span><span class="hljs-comment">2 4 5</span><span class="hljs-comment">5 2 1</span><span class="hljs-comment">5 3 2</span><span class="hljs-comment">3 4 2</span><span class="hljs-comment">*/</span></code></pre><p>在最短路径问题中，对于带权有向图G = (V, E)，<strong>Dijkstra</strong> 算法的初始实现版本未使用最小优先队列实现，其<strong>时间复杂度</strong>为O(V2)，基于Fibonacci heap 的最小优先队列实现版本，其<strong>时间复杂度</strong>为O(E + VlogV)。</p><hr /><h4 id="bell-man-ford">Bell-man Ford</h4><p><strong>算法思路</strong></p><p><a href="https://blog.csdn.net/C2681595858/article/details/85687836#1_Dijkstra_3">参考资料</a></p><p><strong>核心思想是：</strong>首先对距离进行松弛，然后随着迭代次数的增加，距离越来越接近最短路径，直到最后得出最短路径。更具体一点说就是每一次检查每一条边 <span class="math inline">\(&lt;u,v&gt;\)</span> ,看是否有 <span class="math inline">\(d[v] &gt; d[u] + L_{uv}\)</span> 情况，如果有就更新 <span class="math inline">\(d[v]\)</span> 的值，这样一来每一遍大的循环就把源点的情况全局推进一步，然后最多推进n-1步也就把原点的情况推到了每一个节点。</p><p><strong>松弛：</strong>每次松弛操作实际上是对相邻节点的访问，第 <span class="math inline">\(k\)</span> 次松弛操作保证了所有深度为 <span class="math inline">\(k\)</span> 的路径最短。由于图的最短路径最长不会经过超过 <span class="math inline">\(|V|-1\)</span> 条边，所以可知贝尔曼-福特算法所得为最短路径。</p><p><strong>负边权操作：</strong>与迪科斯彻算法不同的是，迪科斯彻算法的基本操作“拓展”是在深度上寻路；而“松弛”操作则是在广度上寻路，这就确定了贝尔曼-福特算法可以对负边进行操作而不会影响结果。</p><p><strong>负权环判定：</strong>因为负权环可以无限制的降低总花费，所以如果发现第 <span class="math inline">\(n\)</span> 次操作仍可降低花销，就一定存在负权环。</p><pre><code class="hljs C++"><span class="hljs-function">procedure <span class="hljs-title">BellmanFord</span><span class="hljs-params">(<span class="hljs-built_in">list</span> vertices, <span class="hljs-built_in">list</span> edges, vertex source)</span></span><span class="hljs-function">   <span class="hljs-comment">//读入边和顶点的列表并对distance和predecessor写入最短路径</span></span><span class="hljs-function">   <span class="hljs-comment">// 初始化图</span></span><span class="hljs-function">   <span class="hljs-keyword">for</span> each vertex v in vertices:</span>       if v is source then distance[v] := 0       <span class="hljs-keyword">else</span> distance[v] := infinity       predecessor[v] := null   <span class="hljs-comment">// 对每一条边重复进行“松弛”操作</span>   <span class="hljs-keyword">for</span> i from <span class="hljs-number">1</span> to size(vertices)<span class="hljs-number">-1</span>: <span class="hljs-comment">// V - 1 次松弛</span>       <span class="hljs-keyword">for</span> each edge (u, v) with weight w in edges:           <span class="hljs-keyword">if</span> distance[u] + w &lt; distance[v]:               distance[v] := distance[u] + w               predecessor[v] := u   <span class="hljs-comment">// 检查图中包含有负权重的环</span>   <span class="hljs-keyword">for</span> each edge (u, v) with weight w in edges:       <span class="hljs-keyword">if</span> distance[u] + w &lt; distance[v]:           error <span class="hljs-string">&quot;图中包含有负权重的环&quot;</span></code></pre><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxnum = <span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxint = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-comment">// 边，</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span>    <span class="hljs-keyword">int</span> u, v;    <span class="hljs-comment">// 起点，重点</span>    <span class="hljs-keyword">int</span> weight;  <span class="hljs-comment">// 边的权值</span>&#125;Edge;Edge edge[maxnum];     <span class="hljs-comment">// 保存边的值</span><span class="hljs-keyword">int</span>  dist[maxnum];     <span class="hljs-comment">// 结点到源点最小距离</span><span class="hljs-keyword">int</span> nodenum, edgenum, source;    <span class="hljs-comment">// 结点数，边数，源点</span><span class="hljs-comment">// 初始化图</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 输入结点数，边数，源点</span>    <span class="hljs-built_in">cin</span> &gt;&gt; nodenum &gt;&gt; edgenum &gt;&gt; source;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=nodenum; ++i)        dist[i] = maxint;    dist[source] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=edgenum; ++i)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].weight;        <span class="hljs-keyword">if</span>(edge[i].u == source)          <span class="hljs-comment">//注意这里设置初始情况</span>            dist[edge[i].v] = edge[i].weight;    &#125;&#125;<span class="hljs-comment">// 松弛计算</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">relax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> weight)</span></span>&#123;    <span class="hljs-keyword">if</span>(dist[v] &gt; dist[u] + weight)        dist[v] = dist[u] + weight;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=nodenum<span class="hljs-number">-1</span>; ++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=edgenum; ++j)            relax(edge[j].u, edge[j].v, edge[j].weight);    <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 判断是否有负环路</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=edgenum; ++i)        <span class="hljs-keyword">if</span>(dist[edge[i].v] &gt; dist[edge[i].u] + edge[i].weight)&#123;            flag = <span class="hljs-number">0</span>;            <span class="hljs-keyword">break</span>;        &#125;    <span class="hljs-keyword">return</span> flag;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//freopen(&quot;input3.txt&quot;, &quot;r&quot;, stdin);</span>    init();    <span class="hljs-keyword">if</span>(Bellman_Ford())&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ;i &lt;= nodenum; i++)            <span class="hljs-built_in">cout</span> &lt;&lt; dist[i] &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>复杂度O(VE)</p><hr /><h4 id="spfa">SPFA</h4><p>算法思路</p><p><strong>算法思想：</strong></p><p>我们用数组记录每个结点的最短路径估计值，用邻接表来存储图G。</p><p>我们采取的方法是动态逼近法：1.设立一个先进先出的队列用来保存待优化的结点。 2.优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。 3.这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</p><p>期望的时间复杂度O(ke)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2。（?）</p><pre><code class="hljs C++">procedure Shortest-Path-Faster-Algorithm(G, s)   <span class="hljs-keyword">for</span> each vertex v ≠ <span class="hljs-function">s in <span class="hljs-title">V</span><span class="hljs-params">(G)</span></span><span class="hljs-function">       <span class="hljs-title">d</span><span class="hljs-params">(v)</span> :</span>= ∞   d(s) := <span class="hljs-number">0</span>   offer s into PQ <span class="hljs-comment">//PQ是优先队列</span>   <span class="hljs-keyword">while</span> PQ is <span class="hljs-keyword">not</span> empty       u := poll PQ       <span class="hljs-keyword">for</span> each edge (u, v) in E(G)           <span class="hljs-keyword">if</span> d(u) + w(u, v) &lt; d(v) then               d(v) := d(u) + w(u, v)               <span class="hljs-keyword">if</span> v is <span class="hljs-keyword">not</span> in PQ then                   offer v into PQ</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//bfs 万能啊</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa_bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;    <span class="hljs-built_in">queue</span> &lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span>(d));    d[s]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    q.push(s);  vis[s]=<span class="hljs-number">1</span>; c[s]=<span class="hljs-number">1</span>;    <span class="hljs-comment">//顶点入队vis要做标记，另外要统计顶点的入队次数</span>    <span class="hljs-keyword">int</span> OK=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> x;        x=q.front(); q.pop();  vis[x]=<span class="hljs-number">0</span>;        <span class="hljs-comment">//队头元素出队，并且消除标记</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=f[x]; k!=<span class="hljs-number">0</span>; k=nnext[k]) <span class="hljs-comment">//遍历顶点x的邻接表</span>        &#123;            <span class="hljs-keyword">int</span> y=v[k];            <span class="hljs-keyword">if</span>( d[x]+w[k] &lt; d[y])            &#123;                d[y]=d[x]+w[k];  <span class="hljs-comment">//松弛</span>                <span class="hljs-keyword">if</span>(!vis[y])  <span class="hljs-comment">//顶点y不在队内</span>                &#123;                    vis[y]=<span class="hljs-number">1</span>;    <span class="hljs-comment">//标记</span>                    c[y]++;      <span class="hljs-comment">//统计次数</span>                    q.push(y);   <span class="hljs-comment">//入队</span>                    <span class="hljs-keyword">if</span>(c[y]&gt;NN)  <span class="hljs-comment">//超过入队次数上限，说明有负环</span>                        <span class="hljs-keyword">return</span> OK=<span class="hljs-number">0</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> OK;&#125;<span class="hljs-comment">//dfs处理负环更快，但是仅限于有限深度</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa_dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><span class="hljs-function"></span>&#123;    vis[u]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=f[u]; k!=<span class="hljs-number">0</span>; k=e[k].next)    &#123;        <span class="hljs-keyword">int</span> v=e[k].v,w=e[k].w;        <span class="hljs-keyword">if</span>( d[u]+w &lt; d[v] )        &#123;            d[v]=d[u]+w;            <span class="hljs-keyword">if</span>(!vis[v])            &#123;                <span class="hljs-keyword">if</span>(spfa_dfs(v))                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    vis[u]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>时间复杂度是O(α(n)n)，n为边数，α(n)为n的反阿克曼函数，一般小于等于4</p><hr /><h4 id="floyd">Floyd</h4><p>算法思路</p><p><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6995648.html">参考资料</a></p><p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd算法的时间复杂度为 <span class="math inline">\(O(N^3)\)</span> ，空间复杂度为 <span class="math inline">\(O(N^2)\)</span> 。Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点 u 到点 v 的最短路径，有两种情况：（1）直接从点 u 到 v 点（2）从点 u 经过若干个中间点 w 到点 v 。</p><p>算法描述：a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。</p><pre><code class="hljs C++">let dist be a |V| × |V| <span class="hljs-built_in">array</span> of minimum distances initialized to ∞ (infinity)<span class="hljs-keyword">for</span> each vertex v    dist[v][v] ← <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">for</span> each <span class="hljs-title">edge</span> <span class="hljs-params">(u,v)</span></span>    dist[u][v] ← w(u,v)  // the weight of the edge (u,v)<span class="hljs-keyword">for</span> k from <span class="hljs-number">1</span> to |V|    <span class="hljs-keyword">for</span> i from <span class="hljs-number">1</span> to |V|       <span class="hljs-keyword">for</span> j from <span class="hljs-number">1</span> to |V|          <span class="hljs-keyword">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]              dist[i][j] ← dist[i][k] + dist[k][j]          end <span class="hljs-keyword">if</span></code></pre><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyed</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//顶点的编号1~n</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;                dist[i][j] = min(dis[i][j],dis[i][k]+dis[k][j]);                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">4 8   </span><span class="hljs-comment">1 2 2   </span><span class="hljs-comment">1 3 6   </span><span class="hljs-comment">1 4 4   </span><span class="hljs-comment">2 3 3   </span><span class="hljs-comment">3 1 7   </span><span class="hljs-comment">3 4 1   </span><span class="hljs-comment">4 1 5   </span><span class="hljs-comment">4 3 12 </span><span class="hljs-comment">*/</span><span class="hljs-comment">//传递闭包问题的修改版</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;                dp[i][j]=dp[i][j]||(dp[i][k]&amp;&amp;dp[k][j]);            &#125;        &#125;    &#125;&#125;</code></pre><p>时间复杂度：<span class="math inline">\(O(n^3)\)</span></p><hr /><h3 id="图的连通">图的连通</h3><h4 id="强连通分量">强连通分量</h4><p>tarjan，</p><h4 id="双连通分量">双连通分量</h4><h4 id="割点桥">割点、桥</h4><h3 id="网络流">网络流</h3><p>用于解决流量问题。</p><p><strong>网络流</strong>：所有弧上流量的集合<span class="math inline">\(f=\{f(u,v)\}\)</span>，称为该容量网络的一个网络流(flow)。</p><p><strong>定义</strong>：带权的有向图<span class="math inline">\(G=(V,E)\)</span>，满足以下条件，则称为<strong>流网络</strong>(flow network)：</p><ul><li>仅有一个入度为0的顶点，源点<span class="math inline">\(s\)</span> (source)</li><li>仅有一个出度为0的顶点，汇点<span class="math inline">\(t\)</span> (sink)</li><li>每条边<span class="math inline">\((u,v) \in E\)</span>，都有一个非负权重 <span class="math inline">\(c(u,v)\)</span>，表示边的容量(capacity)</li></ul><p><strong>性质</strong>：</p><p>对于任意一个时刻，设<span class="math inline">\(f(u,v)\)</span>为实际流量，则整个图G的流网络满足3个性质：</p><ol type="1"><li><strong>容量限制</strong>：对任意<span class="math inline">\(u,v∈V\)</span>，<span class="math inline">\(f(u,v)≤c(u,v)\)</span>。</li><li><strong>反对称性</strong>：对任意<span class="math inline">\(u,v∈V\)</span>，<span class="math inline">\(f(u,v) = -f(v,u)\)</span>。 每条边的流量与其相反边的流量之和为 0 。</li><li><strong>流守恒性</strong>：<span class="math inline">\(\forall x \in V-\{s,t\}, \sum_{(u,x)\in E} f(u,x) = \sum_{(x,v)\in E} f(x,v)\)</span> ，即，源点流出的流量等于汇点流入的流量。</li></ol><p><strong>剩余容量</strong>：<span class="math inline">\(c(u,v) - f(u,v)\)</span></p><p><strong>整个网络的流量</strong>： 从源点发出的所有流量之和 <span class="math inline">\(\sum_{(s,v)\in E} f(s,v)\)</span> 。</p><p><strong>可行流</strong>：在<span class="math inline">\(G\)</span>中，满足下列条件的网络流称为可行流：</p><ul><li><span class="math inline">\(0 \leq f(u,v) \leq c(u,v)\)</span></li><li><span class="math inline">\(\sum_{e\in E^-(u)} f(e) = \sum_{e \in E^+(u)f(e)}\)</span>， 即流入一个点的流量要等于流出这个点的流量</li></ul><p><strong>零流</strong>：若网络流上每条弧上的流量都为0，则该网络流称为零流。 <strong>伪流</strong>：如果一个网络流只满足弧流量限制条件，不满足平衡条件，则这种网络流为伪流，或称为容量可行流。</p><p><strong>最大流</strong>：最大可行流。</p><p><strong>割(cut)</strong>：割其实就是把节点分成两部分<span class="math inline">\((S,T)\)</span> ，而且<span class="math inline">\(s\)</span>位于<span class="math inline">\(S\)</span>中，<span class="math inline">\(t\)</span>位于<span class="math inline">\(T\)</span>中。</p><p><strong>最大流最小割(Max-flow min-cut)定理</strong>：网络流的最大流量等于最小割的容量。（最大流小于任意最小割的容量）</p><p><strong>链</strong>：在容量网络中，称顶点序列<span class="math inline">\((u1,u2,u3,u4,..,un,v)\)</span>为一条链，要求相邻的两个顶点之间有一条弧。 设<span class="math inline">\(P\)</span>是<span class="math inline">\(G\)</span>中一条从<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的链,约定从s指向t的方向为正方向。在链中并不要求所有的弧的方向都与链的方向相同。</p><p><strong>增广路径</strong>：</p><p>设<span class="math inline">\(f\)</span>是一个容量网络<span class="math inline">\(G\)</span>中的一个可行流，<span class="math inline">\(P\)</span>是从<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span> 的一条链，若<span class="math inline">\(P\)</span>满足以下条件:</p><ol type="a"><li><p><span class="math inline">\(P\)</span>中所有前向弧都是非饱和弧（流大小严格<span class="math inline">\(&lt;\)</span>容量）</p></li><li><p><span class="math inline">\(P\)</span>中所有后向弧都是非零弧</p></li></ol><p>则称<span class="math inline">\(P\)</span>为关于可行流<span class="math inline">\(f\)</span>的一条增广路。</p><p><strong>残留网络</strong>： 给定容量网络<span class="math inline">\(G(V,E)\)</span>，及可行流<span class="math inline">\(f\)</span>，弧<span class="math inline">\((u,v)\)</span>上的剩余容量记为<span class="math inline">\(cl(u,v)=c(u,v)-f(u,v)\)</span>。每条弧上的残留容量表示这条弧上可以增加的流量。因为从顶点<span class="math inline">\(u\)</span>到顶点<span class="math inline">\(v\)</span>的流量减少，等效与从顶点<span class="math inline">\(v\)</span>到顶点<span class="math inline">\(u\)</span>的流量增加，所以每条弧<span class="math inline">\((u,v)\)</span>上还有一个反方向的残留容量<span class="math inline">\(cl(v,u)=-f(u,v)\)</span>。</p><p><img src="Snipaste_2020-12-22_22-08-48.png" /></p><p>算法： <a href="https://fireworks99.github.io/2019/05/21/%E6%9C%80%E5%A4%A7%E6%B5%81EK%E7%AE%97%E6%B3%95/">EK</a>（Edmond—Karp）算法，<a href="https://blog.csdn.net/weixin_40673608/article/details/86707598">Ford-Fulkerson</a>算（方）法，<a href="https://www.cnblogs.com/SYCstudio/p/7260613.html">Dinic</a>算法</p><p><img src="Snipaste_2020-12-23_09-31-21.png" /></p><p><img src="Snipaste_2020-12-23_08-55-41.png" /></p><p>参考资料 <a href="https://blog.csdn.net/mystery_guest/article/details/51910913">[1]</a> <a href="https://blog.csdn.net/orion_pistachio/article/details/78090074">[自己]</a></p><h4 id="最大流">最大流</h4><p>我们有一张图，要求从源点流向汇点的最大流量（可以有很多条路到达汇点），就是我们的最大流问题。</p><h4 id="最小割">最小割</h4><p>割其实就是删边的意思，当然最小割就是割掉<span class="math inline">\(X\)</span>条边来让<span class="math inline">\(s\)</span>跟<span class="math inline">\(t\)</span>不互通。我们要求<span class="math inline">\(X\)</span>条边加起来的流量综合最小。这就是最小割问题，一般转化到最大流上。</p><ol type="1"><li><p>网络流的割：是网络中顶点的一个划分，把所有顶点划分成两个顶点集合S和T，其中源点<span class="math inline">\(s\)</span>属于<span class="math inline">\(S\)</span>，汇点<span class="math inline">\(t\)</span>属于<span class="math inline">\(T\)</span>，记作<span class="math inline">\(CUT(S,T)\)</span>。(包括正向边与反向边)</p></li><li><p>割的割边：如果一条弧的两个顶点一个属于顶点集<span class="math inline">\(S\)</span>一个属于顶点集<span class="math inline">\(T\)</span>，该弧为割<span class="math inline">\(CUT(S,T)\)</span>的一条割边。</p></li><li><p>从<span class="math inline">\(S\)</span>指向<span class="math inline">\(T\)</span>的割边是正向割边；从<span class="math inline">\(T\)</span>指向<span class="math inline">\(S\)</span>的割边是逆向割边。</p></li><li><p>割的容量：所有<strong>正向割边的容量和</strong>，不同割的容量不同。</p></li></ol><p>但注意，割的容量只记从<span class="math inline">\(S\)</span>点集到<span class="math inline">\(T\)</span>点集的而<span class="math inline">\(T\)</span>点集到<span class="math inline">\(S\)</span>点集的不算，所以割的容量等于这从<span class="math inline">\(S\)</span>点集到<span class="math inline">\(T\)</span>点集所有边的容量之和。</p><p>参考资料 <a href="https://imlogm.github.io/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/mincut-maxflow/">[1]</a></p><h4 id="费用流">费用流</h4><p>最小费用最大流问题是这样的：每条边都有一个费用，代表单位流量流过这条边的开销。我们要在求出最大流的同时，要求花费的费用最小。</p><h4 id="分数规划">分数规划</h4><h4 id="无汇无源可行流">无汇无源可行流</h4><h3 id="二分图">二分图</h3><ul><li>KM算法</li><li>Hungary算法、HK算法</li></ul><hr /><h3 id="最小生成树">最小生成树</h3><p>1.Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣。</p><p>2.Prim+Heap在任何时候都有令人满意的的时间复杂度，但是代价是空间消耗极大。【以及代码很复杂&gt;_&lt;】</p><p>3.时间复杂度并不能反映出一个<a href="https://blog.csdn.net/Haskei/article/details/53132681">算法</a>的实际优劣。</p><h4 id="prim"><font color="#00dd00">Prim</font></h4><p><strong>算法思路</strong></p><p><a href="https://www.cnblogs.com/alantu2018/p/8464561.html">参考资料</a></p><p>定义：一个连通图的生成树是一个极小的连通子图，它包含图中全部的顶点（n个顶点），但只有n-1条边。最小生成树是构造连通网的最小代价（最小权值）生成树。</p><p>最小生成树MST性质：假设N=（V,{E}）是一个连通网，U是顶点集V的一个非空子集。若（u,v）是一条具有最小权值（代价）的边，其中u∈U，v∈V-U，则必存在一颗包含边（u,v）的最小生成树。</p><p><strong>Prim算法过程为：</strong></p><p>书上是这么说的：假设N=（V,{E}）是连通图，TE是N上最小生成树中边的集合。算法从U={u_0}（u_0∈V），TE={}开始，重复执行下述操作：在所有u∈U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0，v0）并入集合TE，同时v0 并入U，直至U=V为止。此时TE中必有n-1条边，则T=（V，{TE}）为N的最小生成树。</p><p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><p>图的所有顶点集合为V；初始令集合u={s}, v=V−u; 在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。 由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组mincost[MAX_V]，用来维护集合v中每个顶点与集合u中最小代价边信息。</p><pre><code class="hljs C++"><span class="hljs-comment">/* wiki伪代码</span><span class="hljs-comment">从单一顶点开始，普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</span><span class="hljs-comment">输入：一个加权连通图，其中顶点集合为V，边集合为E；</span><span class="hljs-comment">初始化：Vnew=&#123;x&#125;，其中x为集合V中的任一节点（起始点），Enew=&#123;&#125;；</span><span class="hljs-comment">重复下列操作，直到Vnew = V：</span><span class="hljs-comment">在集合E中选取权值最小的边（u, v），其中u为集合Vnew中的元素，而v则是V中没有加入Vnew的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</span><span class="hljs-comment">将v加入集合Vnew中，将（u, v）加入集合Enew中；</span><span class="hljs-comment">输出：使用集合Vnew和Enew来描述所得到的最小生成树。</span><span class="hljs-comment">*/</span></code></pre><p><strong>主要过程是以“点”集合为中心算的，此外还可以使用Heap + Prim优化。</strong></p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> cost[MAX _V][MAX _V]; <span class="hljs-comment">//cost[u][v]表 示边e=(u,v)的权值(不存在的情况下设为INF )</span><span class="hljs-keyword">int</span> mincost[MAX_ V] ;  <span class="hljs-comment">//从集合X出发的边到每个顶点的最小权值</span><span class="hljs-keyword">bool</span> used[MAX_ _V];  <span class="hljs-comment">// 顶点i是否包含在集合X中</span><span class="hljs-keyword">int</span> V;  <span class="hljs-comment">//顶点数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;        mincost[i] = INF;        used[i] = <span class="hljs-literal">false</span>;    &#125;    mincost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">int</span> v = <span class="hljs-number">-1</span>;          <span class="hljs-comment">//从不属于X的顶点中选取从X到其权值最小的顶点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; V; u++) &#123;            <span class="hljs-keyword">if</span> (!used[u] &amp;&amp; (v == <span class="hljs-number">-1</span> || mincost[u] &lt; mincost[v])) &#123;                v = u;            &#125;        &#125;        <span class="hljs-keyword">if</span> (v == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;        used[v] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//把顶点v加入X</span>        res += mincost[v];  <span class="hljs-comment">//把边的长度加到结果里</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; V; u++) &#123;            mincost[u] = min(mincost[u], cost[v][u]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//返回MST权值</span>&#125;</code></pre><p>复杂度：临接矩阵<span class="math inline">\(O(|V|^2)\)</span> 邻接表 <span class="math inline">\(O(|E| log |V|)\)</span></p><hr /><h4 id="krusual"><font color="#00dd00">Krusual</font></h4><p>算法思路</p><p><a href="https://blog.csdn.net/qq_41754350/article/details/81460643">参考资料</a></p><p>克鲁斯卡尔算法的基本思想是以边为主导地位，始终选择当前可用的最小边权的边（可以sort）。每次选择边权最小的边链接两个端点是kruskal的规则，并实时判断两个点之间有没有间接联通。</p><p>Kruskal算法原理如下。首先，将每个顶点放入其自身的数据集合中。然后，按照权值的升序来选择边。当选择每条边时，判断定义边的顶点是否在不同的数据集中。如果是，将此边插入最小生成树的集合中，同时，将集合中包含每个顶点的联合体取出，如果不是，就移动到下一条边。重复这个过程直到所有的边都探查过。</p><p>算法简单，需要使用到<a href="https://blog.csdn.net/qq_41754350/article/details/81271567">并查集</a>。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,m,tot=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<span class="hljs-comment">//n端点总数，m边数，tot记录最终答案，k已经连接了多少边 </span><span class="hljs-keyword">int</span> fat[<span class="hljs-number">200010</span>];<span class="hljs-comment">//记录集体老大 </span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> from,to,dis;<span class="hljs-comment">//结构体储存边 </span>&#125;edge[<span class="hljs-number">200010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> node &amp;a,<span class="hljs-keyword">const</span> node &amp;b)</span><span class="hljs-comment">//sort排序（当然你也可以快排） </span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> a.dis&lt;b.dis;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">father</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//找集体老大，并查集的一部分 </span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(fat[x]!=x)<span class="hljs-keyword">return</span> father(fat[x]);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unionn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span><span class="hljs-comment">//加入团体，并查集的一部分 </span></span><span class="hljs-function"></span>&#123;fat[father(y)]=father(x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-comment">//输入点数，边数 </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;edge[i].from,&amp;edge[i].to,&amp;edge[i].dis);<span class="hljs-comment">//输入边的信息 </span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) fat[i]=i;<span class="hljs-comment">//自己最开始就是自己的老大 （初始化） </span>sort(edge+<span class="hljs-number">1</span>,edge+<span class="hljs-number">1</span>+m,cmp);<span class="hljs-comment">//按权值排序（kruskal的体现） </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<span class="hljs-comment">//从小到大遍历 </span>&#123;<span class="hljs-keyword">if</span>(k==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//n个点需要n-1条边连接 </span><span class="hljs-keyword">if</span>(father(edge[i].from)!=father(edge[i].to))<span class="hljs-comment">//假如不在一个团体 </span>&#123;unionn(edge[i].from,edge[i].to);<span class="hljs-comment">//加入 </span>tot+=edge[i].dis;<span class="hljs-comment">//记录边权 </span>k++;<span class="hljs-comment">//已连接边数+1 </span>&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,tot);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>时间复杂度：O(|Elog|E|)</p><hr /><ul><li><p>最小树形图</p><ul><li>朱刘算法</li></ul></li><li><p>欧拉图</p></li><li><p>环套树</p></li><li><p>仙人掌</p></li></ul><h2 id="树相关">树相关</h2><ul><li><p>树上倍增</p></li><li><p>最近公共祖先 LCA</p></li><li><p>树链剖分</p></li><li><p>动态树</p><ul><li>Link-Cut Tree</li><li>树分块</li></ul></li><li><p>树分治</p><ul><li>点分治</li><li>边分治</li></ul></li><li><p>虚树</p></li><li><p>Prufer编码</p></li><li><p>拓扑排序</p><p><strong>基于DFS的拓扑排序</strong></p><p><pre><code class="hljs c++">摘录一段维基百科上的伪码：L ← Empty <span class="hljs-built_in">list</span> that will contain the sorted nodesS ← Set of all nodes with no outgoing edges<span class="hljs-keyword">for</span> each node n in S <span class="hljs-keyword">do</span>    visit(n) <span class="hljs-function">function <span class="hljs-title">visit</span><span class="hljs-params">(node n)</span></span><span class="hljs-function">    <span class="hljs-keyword">if</span> n has <span class="hljs-keyword">not</span> been visited yet then</span><span class="hljs-function">        mark n as visited</span><span class="hljs-function">        <span class="hljs-keyword">for</span> each node m with an edgefrom m to ndo</span><span class="hljs-function">            <span class="hljs-title">visit</span><span class="hljs-params">(m)</span></span><span class="hljs-function">        add n to L</span></code></pre></p><p>DFS的实现更加简单直观，使用递归实现。利用DFS实现拓扑排序，实际上只需要添加一行代码，即上面伪码中的最后一行：add n to L .需要注意的是，将顶点添加到结果List中的时机是在visit方法即将退出之时。这种方法十分巧妙。</p><p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> T, n, m, cases;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;Map[maxn];<span class="hljs-keyword">int</span> c[maxn];<span class="hljs-comment">//标记数组c[i] = 0 表示还未访问过点i， c[i] = 1表示已经访问过点i，并且还递归访问过它的所有子孙，c[i] = -1表示正在访问中，尚未返回</span><span class="hljs-keyword">int</span> topo[maxn], t;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span><span class="hljs-comment">//从u出发</span></span><span class="hljs-function"></span>&#123;    c[u] = <span class="hljs-number">-1</span>;<span class="hljs-comment">//访问标志</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Map[u].size(); i++)    &#123;        <span class="hljs-keyword">int</span> v = Map[u][i];        <span class="hljs-keyword">if</span>(c[v] &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果子孙比父亲先访问，说明存在有向环，失败退出</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[v] &amp;&amp; !dfs(v))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果子孙未被访问，访问子孙返回假，说明也是失败</span>    &#125;    c[u] = <span class="hljs-number">1</span>;    topo[--t] = u;<span class="hljs-comment">//在递归结束才加入topo排序中，这是由于在最深层次递归中，已经访问到了尽头，此时才是拓扑排序中的最后一个元素</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    t = n;    <span class="hljs-built_in">memset</span>(c, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(c));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; u++)<span class="hljs-keyword">if</span>(!c[u])        <span class="hljs-keyword">if</span>(!dfs(u))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m)    &#123;        <span class="hljs-keyword">if</span>(!n &amp;&amp; !m)<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">int</span> u, v;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  i &lt;= n; i++)Map[i].clear();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;            Map[u].push_back(v);        &#125;        <span class="hljs-keyword">if</span>(toposort())        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Great! There is not cycle.&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-built_in">cout</span>&lt;&lt;topo[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Network has a cycle!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><p><strong>Kahn算法</strong></p><p><strong>Kahn算法：</strong></p><p><pre><code class="hljs C++">摘一段维基百科上关于Kahn算法的伪码描述：L← Empty <span class="hljs-built_in">list</span> that will contain the sorted elementsS ← Set of all nodes with no incoming edges<span class="hljs-keyword">while</span> S is non-empty <span class="hljs-keyword">do</span>    remove a node n from S    insert n into L    foreach node m with an edge e from nto m <span class="hljs-keyword">do</span>        remove edge e from thegraph        ifm has no other incoming edges then            insert m into S<span class="hljs-keyword">if</span> graph has edges then    <span class="hljs-keyword">return</span> error (graph has at least onecycle)<span class="hljs-keyword">else</span>     <span class="hljs-keyword">return</span> L (a topologically sortedorder)</code></pre></p><p>不难看出该算法的实现十分直观，关键在于需要维护一个入度为0的顶点的集合：每次从该集合中取出(没有特殊的取出规则，随机取出也行，使用队列/栈也行，下同)一个顶点，将该顶点放入保存结果的List中。紧接着循环遍历由该顶点引出的所有边，从图中移除这条边，同时获取该边的另外一个顶点，如果该顶点的入度在减去本条边之后为0，那么也将这个顶点放到入度为0的集合中。然后继续从集合中取出一个顶点......当集合为空之后，检查图中是否还存在任何边，如果存在的话，说明图中至少存在一条环路。不存在的话则返回结果List，此List中的顺序就是对图进行拓扑排序的结果。</p><p>实现算法：<a href="https://blog.csdn.net/qinzhaokun/article/details/48541117">博客链接</a></p></li></ul><h2 id="数论">数论</h2><ul><li>欧几里得算法<ul><li>扩展欧几里得算法</li></ul></li><li>筛法</li><li>杜教筛</li><li>快速幂</li><li>裴蜀定理</li><li>欧拉函数<ul><li>欧拉定理</li><li>费马小定理</li></ul></li><li>排列组合<ul><li>Lucas定理</li></ul></li><li>乘法逆元</li><li>矩阵乘法</li><li>数学概率与期望</li><li>博弈论<ul><li>SG函数</li><li>树上删边游戏</li></ul></li><li>拉格朗日乘子法</li><li>中国剩余定理</li><li>线性规划<ul><li>单纯形</li></ul></li><li>辛普森积分</li><li>模线性方程组</li><li>莫比乌斯反演<ul><li>莫比乌斯函数</li></ul></li><li>容次原理</li><li>置换群</li><li>FFT、NTT</li><li>BSGS<ul><li>扩展BSGS</li></ul></li></ul><h2 id="动态规划">动态规划</h2><p>动态规划常常适用于有<strong>重叠子问题和最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p><p>动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p><p>参考资料 <a href="https://leetcode.com/discuss/general-discussion/592146/dynamic-programming-summary/513130">[1]</a></p><ul><li>背包问题</li><li>概率DP</li><li>状压DP</li><li>区间DP</li><li>树形DP</li><li>数位DP</li><li>插头DP</li><li>斯坦纳树</li><li>DP优化<ul><li>单调队列优化</li><li>矩阵乘法优化</li><li>斜率优化</li><li>四边形不等式优化</li></ul></li></ul><h2 id="计算几何">计算几何</h2><ul><li>计算几何基础</li><li>梯形剖分</li><li>三角形剖分</li><li>旋转卡壳</li><li>半平面交</li><li>pick定理</li><li>扫描线</li></ul><h2 id="搜索">搜索</h2><ul><li>DFS、BFS</li><li>A<em>、IDA</em></li><li>迭代加深搜索</li><li>双向BFS</li></ul><h2 id="随机化">随机化</h2><ul><li>模拟退火</li><li>爬山算法</li><li>随机增量法</li></ul><hr /><h2 id="排序算法">排序算法</h2><p>这里将展示十中排序算法，包括内部排序和外部排序，各类排序算法的复杂度总结如下表：</p><p>！！！待插入汇总表</p><hr /><h3 id="插入排序">插入排序</h3><h4 id="直接插入排序">直接插入排序</h4><p><strong>算法思想：</strong> 将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。此方法可用于链表。</p><p><strong>要点：</strong> 设立哨兵，作为临时存储和判断数组边界之用。</p><pre><code class="hljs C++"><span class="hljs-comment">//插入排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">list</span>[],<span class="hljs-keyword">int</span> count)</span></span>&#123;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-comment">/*此处充当哨兵，不在list数组里面单独占一个单位*/</span>    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;count;i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>[i]&lt;<span class="hljs-built_in">list</span>[i<span class="hljs-number">-1</span>])&#123;            temp = <span class="hljs-built_in">list</span>[i];            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;<span class="hljs-built_in">list</span>[j]&gt;temp&amp;&amp;j&gt;=<span class="hljs-number">0</span>;j--)&#123;                <span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>[j];            &#125;            <span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>] = temp;        &#125;    &#125;&#125;<span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> len)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;        <span class="hljs-keyword">if</span>(a[i]&lt;a[i<span class="hljs-number">-1</span>])&#123;            <span class="hljs-keyword">int</span> tmp = a[i];            <span class="hljs-keyword">int</span> j;            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;                <span class="hljs-keyword">if</span>(tmp&lt;a[j])&#123;                    a[j+<span class="hljs-number">1</span>] = a[j];                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-comment">//上面那个拆开就是这样</span>            &#125;            a[j+<span class="hljs-number">1</span>] = tmp;        &#125;    &#125;&#125;</code></pre><h4 id="折半插入排序">折半插入排序</h4><p><strong>基本概念：</strong> 折半插入排序（binary insertion sort）是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。</p><p><strong>算法思想：</strong> 在将一个新元素插入已排好序的数组的过程中，寻找插入点时，将待插入区域的首元素设置为a[low]，末元素设置为a[high]，则轮比较时将待插入元素与a[m]，其中m=(low+high)/2相比较,如果比参考元素大，则选择a[low]到a[m-1]为新的插入区域(即high=m-1)，否则选择a[m+1]到a[high]为新的插入区域（即low=m+1），如此直至low&lt;=high不成立，即将此位置之后所有元素后移一位，并将新元素插入a[high+1]。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BinaryInsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span>   </span>&#123;    <span class="hljs-keyword">int</span> i, j, k, low, high, m;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;        low = <span class="hljs-number">0</span>;        high = i - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(low &lt;= high) &#123; <span class="hljs-comment">//主要优化就是用二分法寻找有序数组的目标值</span>            m = (low + high) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(a[m] &gt; a[i]) high = m - <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> low = m + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(j != i - <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">int</span> temp = a[i];            <span class="hljs-keyword">for</span>(k = i - <span class="hljs-number">1</span>; k &gt;= high + <span class="hljs-number">1</span>; k--)                a[k + <span class="hljs-number">1</span>] = a[k];            a[k + <span class="hljs-number">1</span>] = temp;        &#125;    &#125;&#125;</code></pre><h4 id="希尔排序">希尔排序</h4><p><strong>基本思想：</strong> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p><strong>排序过程：</strong> 先取一个正整数<span class="math inline">\(d_1&lt;n\)</span> ，把所有序号相隔 <span class="math inline">\(d_1\)</span> 的数组元素放一组，组内进行直接插入排序；然后取 <span class="math inline">\(d_2&lt;d_1\)</span> ，重复上述分组和排序操作；直至 <span class="math inline">\(d_i=1\)</span> ，即所有记录放进一个组中排序为止。</p><pre><code class="hljs C++"><span class="hljs-comment">//shell排序，序号是0~count-1，序号如果从1开始，写法上有一点区别</span><span class="hljs-comment">//待排序数组和数组长度count</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shell_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = len / <span class="hljs-number">2</span>; d &gt;= <span class="hljs-number">1</span>; d /= <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = d; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (a[i] &lt; a[i - d]) &#123;                <span class="hljs-keyword">int</span> tmp = a[i];                <span class="hljs-keyword">int</span> j;                <span class="hljs-keyword">for</span> (j = i - d; j &gt;= <span class="hljs-number">0</span>; j -= d) &#123;                    <span class="hljs-keyword">if</span> (tmp &lt; a[j]) &#123;                        a[j + d] = a[j];                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;                &#125;                a[j + d] = tmp;            &#125;        &#125;    &#125;&#125;</code></pre><hr /><h3 id="交换排序">交换排序</h3><h4 id="冒泡排序">冒泡排序</h4><p>算法思想：冒泡排序比较简单，俩层循环，第一层循环决定终止位置，第二层循环从起点位置开始遍历，到终止位置，其间对比相邻俩个元素，根据升序或者降序需求比较值并进行兑换。假设有一个大小为 N 的无序序列，冒泡排序就是要每趟排序过程中通过两两比较，找到第 i 个小（大）的元素，将其往上排。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-comment">//数组序号从0开始</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++)&#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//递增排序，把大的先放到数组后面</span>                swap(arr[j], arr[j + <span class="hljs-number">1</span>]);                            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">//逆序的写法，有序后加入flag提前退出</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//判断本轮的冒泡是否更新</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n<span class="hljs-number">-1</span>; j &gt; i; j--)&#123;<span class="hljs-comment">//把小的先放到数组前面,本轮选择第i小的数字</span>            <span class="hljs-keyword">if</span> (arr[j<span class="hljs-number">-1</span>] &gt; arr[j])&#123;<span class="hljs-comment">//递增排序</span>                swap(arr[j<span class="hljs-number">-1</span>], arr[j]);                flag = <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(!flag)<span class="hljs-keyword">return</span>;    &#125;&#125;</code></pre><h4 id="快速排序">快速排序</h4><p><strong>算法思想：</strong> 随机找出一个数，可以随机取，也可以取固定位置，一般是取第一个或最后一个称为基准，然后就是比基准小的在左边，比基准大的放到右边，如何放做，就是和基准进行交换，这样交换完左边都是比基准小的，右边都是比较基准大的，这样就将一个数组分成了两个子数组，然后再按照同样的方法把子数组再分成更小的子数组，直到不能分解为止。</p><p><strong>算法流程：</strong> （1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； （2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； （3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； （4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； （5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<span class="hljs-keyword">int</span> temp=arr[left];<span class="hljs-keyword">while</span>(left&lt;right)<span class="hljs-comment">//直达left和right重合的时候，才找到合适的位置</span>&#123;<span class="hljs-comment">//先从后往前找比基准小的</span><span class="hljs-keyword">while</span>(left&lt;right  &amp;&amp;  arr[right]&gt;=temp)            <span class="hljs-comment">//当right的值大于temp的值的时候才执行</span>    <span class="hljs-comment">//等号一定得写，因为可能会出现，保存的temp元素和数据中的元素一样的，不写会出现死循环的现象</span>&#123;right--;&#125;arr[left]=arr[right];        <span class="hljs-comment">//当right的值小于temp的值的时候执行</span><span class="hljs-comment">//从前往后找，找比基准大的</span><span class="hljs-keyword">while</span>(left&lt;right  &amp;&amp; arr[left] &lt;=temp)<span class="hljs-comment">//当left的值小于temp的值的时候执行</span>&#123;left++;&#125;arr[right]=arr[left];<span class="hljs-comment">//当left的值大于temp的时候执行</span>&#125;arr[left]=temp;<span class="hljs-comment">//此时的left和right在同一个位置，此时为合适的位置，把temp的值给left</span><span class="hljs-keyword">return</span> left;<span class="hljs-comment">//此时返回的值是temp合适的位置，即小于它的在它的左边，大于它的在它的右边</span>&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<span class="hljs-keyword">if</span>(left&lt;right)&#123;<span class="hljs-keyword">int</span> pivot=partition(arr,left,right);quick(arr,left,pivot<span class="hljs-number">-1</span>);quick(arr,pivot+<span class="hljs-number">1</span>,right);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[],<span class="hljs-keyword">int</span> len)</span></span>&#123;quick(arr,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> arr[]=&#123;<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">45</span>,<span class="hljs-number">12</span>&#125;;<span class="hljs-keyword">int</span> len=<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);quick_sort(arr,len);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;len;++k)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;arr[k]&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;    <span class="hljs-keyword">int</span> tmp = a[low];    <span class="hljs-keyword">while</span>(low&lt;high)&#123;        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=tmp) --high;        a[low] = a[high];        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=tmp) ++low;        a[high] = a[low];     &#125;    a[low] = tmp;    <span class="hljs-keyword">return</span> low;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span>(low &lt; high)&#123;        <span class="hljs-keyword">int</span> pos = partition(a,low,high);        quickSort(a,low,pos<span class="hljs-number">-1</span>);        quickSort(a,pos+<span class="hljs-number">1</span>,high);    &#125;&#125;</code></pre><p><strong>快速排序的优化方法：</strong> <a href="https://blog.csdn.net/lingling_nice/article/details/80943231">参考资料</a></p><p>（1）三数取中法，解决数据基本有序的（就是找到数组中最小下标，最大下标，中间下标的数字，进行比较，把中间大的数组放在最左边）</p><p>（2）随机选取基准，引入的原因是因为在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴，方法就是取待排序列中任意一个元素作为基准</p><p>（3）优化小数组的交换，就是为了解决大才小用问题，<strong>对于很小和部分有序的数组，快排不如插排好</strong>。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排，快排截止范围：<strong>待排序序列长度N = 10</strong>，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形</p><p>（4）在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割，具体过程：在处理过程中，会有两个步骤第一步，在划分过程中，把与key相等元素放入数组的两端，第二步，划分结束后，把与key相等的元素移到枢轴周围</p><hr /><h3 id="选择排序">选择排序</h3><h4 id="简单选择排序">简单选择排序</h4><p>算法思想：在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p><pre><code class="hljs C++"><span class="hljs-comment">//选择排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Select_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">list</span>[],<span class="hljs-keyword">int</span> count)</span></span>&#123;    <span class="hljs-keyword">int</span> min,i,j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;        min = i;        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;count;j++)&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>[min]&gt;<span class="hljs-built_in">list</span>[j])&#123;                min = j;            &#125;        &#125;        <span class="hljs-keyword">if</span>(min!=i)&#123;            swap(<span class="hljs-built_in">list</span>[i],<span class="hljs-built_in">list</span>[min]);        &#125;    &#125;&#125;</code></pre><h4 id="堆排序">堆排序</h4><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。堆是一种特殊的树形数据结构，即完全二叉树。堆分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆。</p><p><strong>算法思想：</strong></p><ul><li>步骤一：建立大根堆--将n个元素组成的无序序列构建一个堆，从最后一个非叶子节点开始向下调整。</li><li>步骤二：交换堆元素--交换堆尾元素和堆首元素，使堆尾元素为最大元素；</li><li>步骤三：重建大根堆--将前n-1个元素组成的无序序列调整为大根堆；</li></ul><p>​ 重复执行步骤二和步骤三，直到整个序列有序。</p><p>需要注意的是数组的序号可以从0开始也可以从1开始，写法上稍有不同，若初始序号是0，则对于序号是i的结点，</p><pre><code class="hljs C++"><span class="hljs-comment">//调整为一个堆</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_AdjustDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> m)</span><span class="hljs-comment">//数组的序号的从1开始</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>] = <span class="hljs-built_in">list</span>[s];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*s;j&lt;=m;j = <span class="hljs-number">2</span>*j)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>[j]&lt;<span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>]&amp;&amp;j&lt;m)        &#123;            j++;        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>]&gt;<span class="hljs-built_in">list</span>[j])            <span class="hljs-keyword">break</span>;        <span class="hljs-built_in">list</span>[s] = <span class="hljs-built_in">list</span>[j];        s = j;    &#125;    <span class="hljs-built_in">list</span>[s] = <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">/*这样写也可以</span><span class="hljs-comment">void adjustDown(int a[],int k, int len)&#123;</span><span class="hljs-comment">    a[0] = a[k];</span><span class="hljs-comment">    for(int i=2*k;i&lt;=len;i*=2)&#123;</span><span class="hljs-comment">        if(a[i]&lt;a[i+1]&amp;&amp;i&lt;len)i++;</span><span class="hljs-comment">        //if(a[0]&gt;a[i])break;</span><span class="hljs-comment">        if(a[i]&gt;a[k])&#123;</span><span class="hljs-comment">            swap(a[i],a[k]);k = i;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        else break;</span><span class="hljs-comment">        //a[k] = a[i];</span><span class="hljs-comment">        </span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    //a[k] = a[0];</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-comment">//堆排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> len)</span><span class="hljs-comment">//数组的序号的从1开始</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//创建一个大顶堆</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s = len/<span class="hljs-number">2</span>;s&gt;<span class="hljs-number">0</span>;s--)    &#123;        Heap_AdjustDown(<span class="hljs-built_in">list</span>,s,len);    &#125;     <span class="hljs-comment">//排序</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len;i &gt; <span class="hljs-number">1</span>;i--)    &#123;        swap(<span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>],<span class="hljs-built_in">list</span>[i]);        Heap_AdjustDown(<span class="hljs-built_in">list</span>,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);    &#125;&#125;</code></pre><p>补充，堆的插入和删除：删除堆顶元素操作需要将堆顶元素与堆尾交换，由于破坏了堆的性质，需要向下调整Heap_AdjustDown。而插入元素操作，需要在堆尾插入，然后从堆尾开始向上调整Heap_AdjustUp。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_AdjustUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> k)</span><span class="hljs-comment">//数组的序号的从1开始，参数k是向上调整的节点位置(list[k])，也是堆元素个数;list[0]用作临时变量存放结点数字</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>] = <span class="hljs-built_in">list</span>[k];    <span class="hljs-keyword">int</span> i = k/<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">list</span>[i]&lt;<span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>])&#123;        <span class="hljs-built_in">list</span>[k] = <span class="hljs-built_in">list</span>[i];        k = i;        i = k/<span class="hljs-number">2</span>;    &#125;    <span class="hljs-built_in">list</span>[k] = <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>];&#125;</code></pre><p>另外一种写法，差不多。</p><pre><code class="hljs C++"><span class="hljs-comment">//调整为一个堆，这个写法是0序号开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_AdjustDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> m)</span><span class="hljs-comment">//list是待排序数组，s是开始调整的父亲结点，m是堆尾结点的序号</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">list</span>[s];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*s+<span class="hljs-number">1</span>;j&lt;=m;j = <span class="hljs-number">2</span>*j+<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">if</span>(j&lt;m &amp;&amp; <span class="hljs-built_in">list</span>[j]&lt;<span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>])        &#123;            j++;        &#125;        <span class="hljs-keyword">if</span>(temp&gt;<span class="hljs-built_in">list</span>[j])            <span class="hljs-keyword">break</span>;        <span class="hljs-built_in">list</span>[s] = <span class="hljs-built_in">list</span>[j];        s = j;    &#125;    <span class="hljs-built_in">list</span>[s] = temp;&#125; <span class="hljs-comment">//堆排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> len)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//创建一个大顶堆</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s = len/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;s&gt;=<span class="hljs-number">0</span>;s--)    &#123;        Heap_AdjustDown(<span class="hljs-built_in">list</span>,s,len<span class="hljs-number">-1</span>);    &#125;     <span class="hljs-comment">//排序</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">1</span>;i--)    &#123;        swap(<span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>],<span class="hljs-built_in">list</span>[i]);        Heap_AdjustDown(<span class="hljs-built_in">list</span>,<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_AdjustUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> k)</span><span class="hljs-comment">//数组的序号的从0开始，参数k是向上调整的节点位置，也是堆元素个数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> tmp = <span class="hljs-built_in">list</span>[k];    <span class="hljs-keyword">int</span> i = (k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">list</span>[i]&lt;tmp)&#123;        <span class="hljs-built_in">list</span>[k] = <span class="hljs-built_in">list</span>[i];        k = i;        i = (k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//这里跳出，有空再改</span>    &#125;    <span class="hljs-built_in">list</span>[k] = tmp;&#125;</code></pre><p>n个元素建立堆的时间复杂度是O(n)，调整堆的时间复杂度是O(h)</p><hr /><h3 id="归并排序">归并排序</h3><p><strong>算法思想：</strong>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><a href="https://blog.csdn.net/orion_pistachio/article/details/70766898">参考资料</a></p><pre><code class="hljs C++"><span class="hljs-comment">//非递归</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &lt; y ? x : y;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">int</span> *a = arr;    <span class="hljs-keyword">int</span> *b = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));    <span class="hljs-keyword">int</span> seg, start;    <span class="hljs-keyword">for</span> (seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg) &#123;        <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; len; start += seg * <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class="hljs-number">2</span>, len);            <span class="hljs-keyword">int</span> k = low;            <span class="hljs-keyword">int</span> start1 = low, end1 = mid;            <span class="hljs-keyword">int</span> start2 = mid, end2 = high;            <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            <span class="hljs-keyword">while</span> (start1 &lt; end1)                b[k++] = a[start1++];            <span class="hljs-keyword">while</span> (start2 &lt; end2)                b[k++] = a[start2++];        &#125;        <span class="hljs-keyword">int</span> *temp = a;        a = b;        b = temp;    &#125;    <span class="hljs-keyword">if</span> (a != arr) &#123;        <span class="hljs-keyword">int</span> i;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)            b[i] = a[i];        b = a;    &#125;    <span class="hljs-built_in">free</span>(b);&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//递归</span><span class="hljs-comment">//merge_sort_recursive（待排序数组，辅助数组，起始位置，结束位置）</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_recursive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> reg[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start &gt;= end)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="hljs-number">1</span>) + start;<span class="hljs-comment">//mid = (len)/2 + st</span>    <span class="hljs-keyword">int</span> start1 = start, end1 = mid;    <span class="hljs-keyword">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = end;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    <span class="hljs-keyword">int</span> k = start;    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    <span class="hljs-keyword">while</span> (start1 &lt;= end1)        reg[k++] = arr[start1++];    <span class="hljs-keyword">while</span> (start2 &lt;= end2)        reg[k++] = arr[start2++];    <span class="hljs-keyword">for</span> (k = start; k &lt;= end; k++)        arr[k] = reg[k];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">int</span> reg[len];    merge_sort_recursive(arr, reg, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);&#125;</code></pre><h3 id="基数排序">基数排序</h3><p>两种多关键码排序方法：最高位优先(Most Significant Digit first)法，简称MSD 法；最低位优先(Least Significant Digit first)法，简称LSD 法。实现方法是将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//辅助函数，求数据的最大位数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> maxData = data[<span class="hljs-number">0</span>];<span class="hljs-comment">///&lt; 最大数</span>    <span class="hljs-comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)    &#123;        <span class="hljs-keyword">if</span> (maxData &lt; data[i])            maxData = data[i];    &#125;    <span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;    <span class="hljs-keyword">while</span> (maxData &gt;= p)    &#123;        <span class="hljs-comment">//p *= 10; // Maybe overflow</span>        maxData /= <span class="hljs-number">10</span>;        ++d;    &#125;    <span class="hljs-keyword">return</span> d;<span class="hljs-comment">/*    int d = 1; //保存最大的位数</span><span class="hljs-comment">    int p = 10;</span><span class="hljs-comment">    for(int i = 0; i &lt; n; ++i)</span><span class="hljs-comment">    &#123;</span><span class="hljs-comment">        while(data[i] &gt;= p)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            p *= 10;</span><span class="hljs-comment">            ++d;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    return d;*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radixsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//基数排序</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> d = maxbit(data, n);    <span class="hljs-keyword">int</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];    <span class="hljs-keyword">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//计数器</span>    <span class="hljs-keyword">int</span> i, j, k;    <span class="hljs-keyword">int</span> radix = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= d; i++) <span class="hljs-comment">//进行d次排序</span>    &#123;        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)            count[j] = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次分配前清空计数器</span>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++)        &#123;            k = (data[j] / radix) % <span class="hljs-number">10</span>; <span class="hljs-comment">//统计每个桶中的记录数</span>            count[k]++;        &#125;        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)            count[j] = count[j - <span class="hljs-number">1</span>] + count[j]; <span class="hljs-comment">//将tmp中的位置依次分配给每个桶</span>        <span class="hljs-keyword">for</span>(j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) <span class="hljs-comment">//将所有桶中记录依次收集到tmp中</span>        &#123;            k = (data[j] / radix) % <span class="hljs-number">10</span>;            tmp[count[k] - <span class="hljs-number">1</span>] = data[j];            count[k]--;        &#125;        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++) <span class="hljs-comment">//将临时数组的内容复制到data中</span>            data[j] = tmp[j];        radix = radix * <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">delete</span> []tmp;    <span class="hljs-keyword">delete</span> []count;&#125;</code></pre><h3 id="外部排序算法之多路归并排序">外部排序算法之多路归并排序</h3><hr /><h2 id="其他">其他</h2><ul><li><p>分治</p><ul><li>CDQ分治</li><li>整体二分</li></ul></li><li><p>莫队算法</p><ul><li>树上莫队算法</li><li>待修改莫队算法</li></ul></li><li><p>分块</p></li><li><p>高精度</p></li><li><p>离线</p></li><li><p>RMQ</p><ul><li>ST表</li></ul></li><li><p>二分法</p><ul><li><p>二分答案</p></li><li><p>二分查找</p><p><strong>三种写法不一样</strong> 能够写对一种就好，注意溢出。</p><p>在这里再补充一下lowerbound和upperbound</p></li></ul></li></ul><pre><code class="hljs C++"><span class="hljs-comment">//用这个!!!!!!!!!!</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> tar)</span></span>&#123;    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<span class="hljs-comment">//返回[l,r)中第一个不小于tar的值的下标</span>        <span class="hljs-keyword">int</span> mid = l + (r-l)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(a[mid] &gt;= tar) r = mid;        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> l;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> tag)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">while</span>(left &lt;= right)&#123;        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (a[mid] == tag)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span>            a[mid] &lt; tag ? left = mid + <span class="hljs-number">1</span> : right = mid - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">//求解区间[l,r]</span></code></pre><p>**ForwardIter lower_bound(ForwardIter first, ForwardIter last,const _Tp&amp; val)**算法返回一个非递减序列[first, last)中的第一个大于等于值val的位置。</p><p>**ForwardIter upper_bound(ForwardIter first, ForwardIter last, const _Tp&amp; val)**算法返回一个非递减序列[first, last)中第一个大于val的位置。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upperBound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> tag)</span></span>&#123;<span class="hljs-comment">//[l,r)区间求解UB</span><span class="hljs-keyword">while</span>(l &lt; r) &#123;<span class="hljs-comment">//在[l,r]求LB,等于[l,l+len)</span><span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(a[mid] &gt; tag)             r = mid;<span class="hljs-keyword">else</span>             l = mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> l;<span class="hljs-comment">//写return l不会错</span>&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowerBound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> tag)</span></span>&#123;<span class="hljs-keyword">while</span>(l&lt;r)&#123;<span class="hljs-comment">//在[l,r)求LB,等于[l,l+len)</span><span class="hljs-keyword">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(a[mid]&gt;=tag)<span class="hljs-comment">//求上下界的区别在于等号的处理</span>r = mid;<span class="hljs-keyword">else</span>l = mid+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-comment">//求上下界的区别在于等号的处理,下界的等号与&quot;&gt;&quot;合并,因为要取得tag的值的索引必定比mid大,而有边界好取</span></code></pre><p>lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。</p><p>在<strong>从小到大的排序数组</strong>中：</p><p><strong>lower_bound( begin,end,num)：</strong>从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><strong>upper_bound( begin,end,num)：</strong>从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>在<strong>从大到小的排序数组</strong>中，重载lower_bound()和upper_bound()：</p><p><strong>lower_bound( begin,end,num,greater<type>() ):</strong>从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><strong>upper_bound( begin,end,num,greater<type>() ):</strong>从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>原文链接：https://blog.csdn.net/qq_40160605/article/details/80150252</p><p><strong>应用一：upper_bound - lower_bound = target的数量</strong></p><pre><code class="hljs angelscript">[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>，<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]lower_bound(<span class="hljs-number">2</span>) --&gt; <span class="hljs-number">3</span>(下标)upper_bound(<span class="hljs-number">2</span>) --&gt; <span class="hljs-number">6</span>(下标)可以得到<span class="hljs-number">2</span>的个数是<span class="hljs-number">3</span></code></pre><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2020-03-27_16-03-57.png" /></p><p>参考链接 <a href="https://www.cnblogs.com/cobbliu/archive/2012/05/21/2512249.html">LINK1</a> <a href="https://www.zhihu.com/question/36132386">LINK2</a> <a href="https://blog.csdn.net/yang20141109/article/details/51934437">LINK3</a></p><ul><li><p>三分法</p></li><li><p>贪心</p></li><li><p>模拟</p></li><li><p><strong>P类问题：</strong>存在多项式时间算法的问题。(P：polynomial，多项式)</p><p><strong>NP类问题：</strong>能在多项式时间内验证得出一个正确解的问题。(NP:Nondeterministic polynomial，非确定性多项式)P类问题是NP问题的子集，因为存在多项式时间解法的问题，总能在多项式时间内验证他。注意定义，这里是验证。NP类问题，我用个人的俗话理解就是，不知道这个问题是不是存在多项式时间内的算法，所以叫non-deterministic非确定性，但是我们可以在多项式时间内验证并得出这个问题的一个正确解。举个例子，</p><p><strong>NPC问题：</strong>如果所有np问题都能在多项式时间内转化为他，则称该np问题为npc问题(NPC:NP complete又叫NP完全问题)NPC问题是NP问题的子集。</p><p><strong>NPH问题：</strong>我们又叫NP难问题，他不是一个NP问题，然后所有的NPC问题都可以在多项式时间内转化为他的话，我们就叫他NPH（hard）问题。</p></li><li><p>牛顿迭代法</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSDN博客链接</title>
    <link href="/2019/05/20/2019-05-20-CSDN%E5%8D%9A%E5%AE%A2/"/>
    <url>/2019/05/20/2019-05-20-CSDN%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>第一篇博客的链接，<a href="https://blog.csdn.net/orion_pistachio/article/details/56961411">最近没时间搬运了</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何安装Nest-simulator</title>
    <link href="/2019/04/01/2019-04-01-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Nest-simulator/"/>
    <url>/2019/04/01/2019-04-01-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Nest-simulator/</url>
    
    <content type="html"><![CDATA[<h2 id="如何安装nest-simulator">如何安装nest simulator</h2><p>官方参考链接：<a href="https://nest-simulator.readthedocs.io/en/latest/installation/linux_install.html#dependencies" class="uri">https://nest-simulator.readthedocs.io/en/latest/installation/linux_install.html#dependencies</a></p><p>官方是不支持直接在windows上安装nest的，但是可以使用virtualBox或者vmware来间接使用。</p><h4 id="所需材料"><strong>所需材料</strong></h4><ol type="1"><li>nest simulator源代码（我使用的是2.16.0版本，github上可以找到源代码）</li></ol><p><a href="https://nest-simulator.readthedocs.io/en/latest/download.html" class="uri">https://nest-simulator.readthedocs.io/en/latest/download.html</a></p><ol type="1"><li>vmware player 15（正版免费，官网有）</li><li>Ubuntu16.04.4的iso镜像</li><li>windows10上安装</li></ol><h4 id="安装步骤">安装步骤</h4><ol type="1"><li><p>首先安装好vmware并创建虚拟机，建议安装linux tool，可以直接在主机和虚拟机之间复制粘贴、可以全屏。可参考：<a href="https://blog.csdn.net/stpeace/article/details/78598333" class="uri">https://blog.csdn.net/stpeace/article/details/78598333</a></p></li><li><p>在Ubuntu中安装下列包：</p><pre><code class="hljs Shell">sudo apt-get install -y build-essential cmake libltdl7-dev libreadline6-dev \libncurses5-dev libgsl0-dev python-all-dev python-numpy python-scipy \python-matplotlib ipython openmpi-bin libopenmpi-dev python-nose//注意，这里可以先不安装，编译、安装nest的时候遇到有缺少的在安装，直接安装//在Ubuntu16.04上会遇到一些包的依赖的问题，见下。</code></pre></li><li><p>解压缩tarball：</p><pre><code class="hljs shell">tar -xzvf nest-simulator-2.16.0.tar.gz</code></pre></li><li><p>创建编译的目录：</p><pre><code class="hljs shell">mkdir nest-simulator-2.16.0-build</code></pre></li><li><p>cmake</p><pre><code class="hljs shell">cmake -DCMAKE_INSTALL_PREFIX:PATH=&lt;/install/path&gt; &lt;/path/to/NEST/src&gt;//&lt;/install/path&gt;是安装的目录，即nest-simulator-2.16.0-build文件夹//&lt;/path/to/NEST/src&gt;是源代码的目录//目录最好都是绝对路径</code></pre><p>出现NEST Configuration Summary之后不报错就可以make、make install、make installcheck了。</p></li></ol><p><strong>会遇到的问题！！</strong></p><p>安装过程中第一步就出现了错误</p><pre><code class="hljs shell">orion@orion233:~$ sudo apt-get install -y build-essential cmake libltdl7-dev libreadline6-dev \<span class="hljs-meta">&gt;</span><span class="bash"> libncurses5-dev libgsl0-dev python-all-dev python-numpy python-scipy \</span><span class="hljs-meta">&gt;</span><span class="bash"> python-matplotlib ipython openmpi-bin libopenmpi-dev python-nose</span>sudo: unable to resolve host orion233[sudo] password for orion: Sorry, try again.[sudo] password for orion: Reading package lists... DoneBuilding dependency tree       Reading state information... DoneNote, selecting &#x27;libltdl-dev&#x27; instead of &#x27;libltdl7-dev&#x27;Note, selecting &#x27;libgsl-dev&#x27; instead of &#x27;libgsl0-dev&#x27;build-essential is already the newest version (12.1ubuntu2).cmake is already the newest version (3.5.1-1ubuntu1).libgsl-dev is already the newest version (2.1+dfsg-2).libltdl-dev is already the newest version (2.4.6-0.1).libncurses5-dev is already the newest version (6.0+20160213-1ubuntu1).libreadline6-dev is already the newest version (6.3-8ubuntu2).ipython is already the newest version (2.4.1-1).openmpi-bin is already the newest version (1.10.2-8ubuntu1).Some packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: libopenmpi-dev : Depends: libhwloc-dev but it is not going to be installed python-all-dev : Depends: python (= 2.7.11-1) but 2.7.12-1~16.04 is to be installed                  Depends: python-all (= 2.7.11-1) but it is not going to be installed                  Depends: libpython-all-dev (= 2.7.11-1) but it is not going to be installed                  Depends: python-dev (= 2.7.11-1) but it is not going to be installed                  Depends: python2.7-dev (&gt;= 2.7-7) but it is not going to be installed python-numpy : Depends: liblapack3 but it is not going to be installed or                         liblapack.so.3 python-scipy : Depends: libgfortran3 (&gt;= 4.6) but it is not going to be installed                Depends: liblapack3 but it is not going to be installed or                         liblapack.so.3                Recommends: python-dev but it is not going to be installedE: Unable to correct problems, you have held broken packages.</code></pre><p>这是一些包之间相互依赖出现了问题，Linux下经常需要安装不同类型的库，在Ubuntu中，这些类库都是以“lib_name-version”的形式命名的。很多库之间存在依赖关系，即要安装这个就必须安装那个。有时候，类库之间依赖关系无法满足，你所要安装的程序就不能安装。 这类问题大多是由于相互依赖的几个库中一个或多个的版本已经更新，而用户要安装的库依赖于这几个库的较低的版本，这时候可以试试使用“sudo aptitude install ”（尖括号内为你要安装的程序的名字）。我们莫慌，先安装<strong>aptitude</strong></p><p><strong>使用aptitude</strong></p><p>aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。</p><p>sudo aptitude install python-numpy</p><p>运行后，不接受未安装方案，接受降级方案。搞定。</p><pre><code class="hljs angelscript"><span class="hljs-symbol">orion@</span>orion233:~$ sudo aptitude install libopenmpi-devThe following NEW packages will be installed:  libhwloc-dev&#123;a&#125; libibverbs-dev&#123;a&#125; libnuma-dev&#123;ab&#125; libopenmpi-dev <span class="hljs-number">0</span> packages upgraded, <span class="hljs-number">4</span> newly installed, <span class="hljs-number">0</span> to remove <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> <span class="hljs-keyword">not</span> upgraded.Need to <span class="hljs-keyword">get</span> <span class="hljs-number">802</span> kB of archives. After unpacking <span class="hljs-number">5.510</span> kB will be used.The following packages have unmet dependencies: libnuma-dev : Depends: libnuma1 (= <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) but <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1<span class="hljs-number">.1</span> <span class="hljs-keyword">is</span> installed.The following actions will resolve these dependencies:     Keep the following packages at their current version:<span class="hljs-number">1</span>)     libhwloc-dev [Not Installed]                       <span class="hljs-number">2</span>)     libnuma-dev [Not Installed]                        <span class="hljs-number">3</span>)     libopenmpi-dev [Not Installed]                     Accept <span class="hljs-keyword">this</span> solution? [Y/n/q/?] nThe following actions will resolve these dependencies:     Downgrade the following packages:                               <span class="hljs-number">1</span>)     libnuma1 [<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1<span class="hljs-number">.1</span> (now) -&gt; <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1 (xenial)]Accept <span class="hljs-keyword">this</span> solution? [Y/n/q/?] YThe following packages will be DOWNGRADED:  libnuma1 The following NEW packages will be installed:  libhwloc-dev&#123;a&#125; libibverbs-dev&#123;a&#125; libnuma-dev&#123;a&#125; libopenmpi-dev <span class="hljs-number">0</span> packages upgraded, <span class="hljs-number">4</span> newly installed, <span class="hljs-number">1</span> downgraded, <span class="hljs-number">0</span> to remove <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> <span class="hljs-keyword">not</span> upgraded.Need to <span class="hljs-keyword">get</span> <span class="hljs-number">823</span> kB of archives. After unpacking <span class="hljs-number">5.510</span> kB will be used.Do you want to <span class="hljs-keyword">continue</span>? [Y/n/?] YGet: <span class="hljs-number">1</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/main amd64 libnuma1 amd64 2.0.11-1ubuntu1 [21,0 kB]</span>Get: <span class="hljs-number">2</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/main amd64 libnuma-dev amd64 2.0.11-1ubuntu1 [31,7 kB]</span>Get: <span class="hljs-number">3</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/universe amd64 libhwloc-dev amd64 1.11.2-3 [155 kB]</span>Get: <span class="hljs-number">4</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/main amd64 libibverbs-dev amd64 1.1.8-1.1ubuntu2 [77,6 kB]</span>Get: <span class="hljs-number">5</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/universe amd64 libopenmpi-dev amd64 1.10.2-8ubuntu1 [537 kB]</span>Fetched <span class="hljs-number">823</span> kB <span class="hljs-keyword">in</span> <span class="hljs-number">2</span>s (<span class="hljs-number">275</span> kB/s)         dpkg: warning: downgrading libnuma1:amd64 <span class="hljs-keyword">from</span> <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1<span class="hljs-number">.1</span> to <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1(Reading database ... <span class="hljs-number">180946</span> files <span class="hljs-keyword">and</span> directories currently installed.)Preparing to unpack .../libnuma1_2<span class="hljs-number">.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1_amd64.deb ...Unpacking libnuma1:amd64 (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) over (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1<span class="hljs-number">.1</span>) ...Selecting previously unselected package libnuma-dev:amd64.Preparing to unpack .../libnuma-dev_2<span class="hljs-number">.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1_amd64.deb ...Unpacking libnuma-dev:amd64 (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) ...Selecting previously unselected package libhwloc-dev:amd64.Preparing to unpack .../libhwloc-dev_1<span class="hljs-number">.11</span><span class="hljs-number">.2</span><span class="hljs-number">-3</span>_amd64.deb ...Unpacking libhwloc-dev:amd64 (<span class="hljs-number">1.11</span><span class="hljs-number">.2</span><span class="hljs-number">-3</span>) ...Selecting previously unselected package libibverbs-dev.Preparing to unpack .../libibverbs-dev_1<span class="hljs-number">.1</span><span class="hljs-number">.8</span><span class="hljs-number">-1.1</span>ubuntu2_amd64.deb ...Unpacking libibverbs-dev (<span class="hljs-number">1.1</span><span class="hljs-number">.8</span><span class="hljs-number">-1.1</span>ubuntu2) ...Selecting previously unselected package libopenmpi-dev.Preparing to unpack .../libopenmpi-dev_1<span class="hljs-number">.10</span><span class="hljs-number">.2</span><span class="hljs-number">-8</span>ubuntu1_amd64.deb ...Unpacking libopenmpi-dev (<span class="hljs-number">1.10</span><span class="hljs-number">.2</span><span class="hljs-number">-8</span>ubuntu1) ...Processing triggers <span class="hljs-keyword">for</span> libc-bin (<span class="hljs-number">2.23</span><span class="hljs-number">-0</span>ubuntu10) ...Processing triggers <span class="hljs-keyword">for</span> man-db (<span class="hljs-number">2.7</span><span class="hljs-number">.5</span><span class="hljs-number">-1</span>) ...Setting up libnuma1:amd64 (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) ...Setting up libnuma-dev:amd64 (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) ...Setting up libhwloc-dev:amd64 (<span class="hljs-number">1.11</span><span class="hljs-number">.2</span><span class="hljs-number">-3</span>) ...Setting up libibverbs-dev (<span class="hljs-number">1.1</span><span class="hljs-number">.8</span><span class="hljs-number">-1.1</span>ubuntu2) ...Setting up libopenmpi-dev (<span class="hljs-number">1.10</span><span class="hljs-number">.2</span><span class="hljs-number">-8</span>ubuntu1) ...update-alternatives: using /usr/lib/openmpi/include to provide /usr/include/mpi (mpi) <span class="hljs-keyword">in</span> <span class="hljs-built_in">auto</span> modeProcessing triggers <span class="hljs-keyword">for</span> libc-bin (<span class="hljs-number">2.23</span><span class="hljs-number">-0</span>ubuntu10) ...</code></pre><p>按照上述方法（主要是17、15行）全部处理好包的版本和依赖问题，那么就可以一次输入一开始的那段指令，安装所有的包了。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sublime乱码解决方法</title>
    <link href="/2019/03/26/2019-03-26-sublime%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2019/03/26/2019-03-26-sublime%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>sublime text 3是一款非常好用的代码编辑器，通过一些配置可以实现多种语言的编译运行，但是也会遇到出现中文显示乱码或者运行程序之后输出结果为乱码，今天就针对这个问题进行一个汇总。</p><p>对于代码中中文注释或其他内容出现乱码，通常情况下使用"ConvertToUTF8"这个插件就可以解决问题，如果解决不了，可以尝试在文本文件中另存为，保存编码格式从ASCII修改为UTF-8，复制另存的代码，然后删除之前在sublime中出现乱码的文件，重新创建并将代码粘贴。（如果没有解决，可留言交流或者在看看其他解决方法）</p><p>另外一种情况的乱码可以修改环境配置文件，常用参考配置如下，容易采用UTF-8的编码。（"-fexec-charset=gbk"这句一定要加上）</p><p>C/C++：</p><pre><code class="hljs C++"> &#123; <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;gcc&quot;</span>, <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>, <span class="hljs-string">&quot;-fexec-charset=gbk&quot;</span>,<span class="hljs-string">&quot;-o&quot;</span>, <span class="hljs-string">&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;$&#123;file_base_name&#125; &amp; echo. &amp; pause&quot;</span>], <span class="hljs-string">&quot;file_regex&quot;</span>: <span class="hljs-string">&quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;</span>, <span class="hljs-string">&quot;working_dir&quot;</span>: <span class="hljs-string">&quot;$&#123;file_path&#125;&quot;</span>, <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.c, source.c++&quot;</span>, <span class="hljs-string">&quot;shell&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;encoding&quot;</span>:<span class="hljs-string">&quot;UTF-8&quot;</span>,&#125;<span class="hljs-number">2.</span> 保存为g++.sublime-build即可（g++可以改成自己好记的）<span class="hljs-number">3.</span> 然后ctrl+shift+b选择g++编译</code></pre><p>或者：</p><pre><code class="hljs C++">&#123;    <span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;utf-8&quot;</span>,    <span class="hljs-string">&quot;working_dir&quot;</span>: <span class="hljs-string">&quot;$file_path&quot;</span>,    <span class="hljs-string">&quot;shell_cmd&quot;</span>: <span class="hljs-string">&quot;g++ -Wall -std=c++11 -fexec-charset=GBK \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;</span>,    <span class="hljs-string">&quot;file_regex&quot;</span>: <span class="hljs-string">&quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;</span>,    <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.c++&quot;</span>,    <span class="hljs-string">&quot;variants&quot;</span>:     [        &#123;           <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Run&quot;</span>,        <span class="hljs-string">&quot;shell_cmd&quot;</span>: <span class="hljs-string">&quot;g++ -Wall -std=c++11 -fexec-charset=GBK \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot;</span>        &#125;    ]&#125;</code></pre><p>Python：</p><pre><code class="hljs C++">&#123; <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;c:/Python36/python.exe&quot;</span>,<span class="hljs-string">&quot;-u&quot;</span>, <span class="hljs-string">&quot;$file&quot;</span>], <span class="hljs-comment">//自己安装路径</span><span class="hljs-string">&quot;file_regex&quot;</span>:<span class="hljs-string">&quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9])*&quot;</span>,<span class="hljs-string">&quot;env&quot;</span>: &#123;<span class="hljs-string">&quot;PYTHONIOENCODING&quot;</span>: <span class="hljs-string">&quot;utf8&quot;</span>&#125;, <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.python&quot;</span> &#125;</code></pre><p>Java:</p><p>预先安装JDK并配置环境变量</p><ul><li>新建JAVA_HOME C:Files.0_181（jdk绝对路径）path 最前面添加%JAVA_HOME%;%JAVA_HOME%;</li><li>新建CLASSPATH .;%JAVA_HOME%;%JAVA_HOME%.jar;%JAVA_HOME%.jar</li></ul><pre><code class="hljs C++">    &#123;<span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;javac&quot;</span>, <span class="hljs-string">&quot;-encoding&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>, <span class="hljs-string">&quot;-d&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;$file&quot;</span>],    <span class="hljs-string">&quot;file_regex&quot;</span>: <span class="hljs-string">&quot;^(...*?):([0-9]*):?([0-9]*)&quot;</span>,    <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.java&quot;</span>,    <span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;GBK&quot;</span>,    <span class="hljs-comment">//执行完上面的命令就结束</span>     <span class="hljs-comment">// 下面的命令需要按Ctrl+Shift+b来运行</span>    <span class="hljs-string">&quot;variants&quot;</span>: [&#123;        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Run&quot;</span>,        <span class="hljs-string">&quot;shell&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;java $&#123;file_base_name&#125; &amp;echo. &amp; pause&quot;</span>],        <span class="hljs-comment">// /c是执行完命令后关闭cmd窗口,</span>        <span class="hljs-comment">// /k是执行完命令后不关闭cmd窗口。</span>        <span class="hljs-comment">// echo. 相当于输入一个回车</span>        <span class="hljs-comment">// pause命令使cmd窗口按任意键后才关闭</span>        <span class="hljs-string">&quot;working_dir&quot;</span>: <span class="hljs-string">&quot;$&#123;file_path&#125;&quot;</span>,        <span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;GBK&quot;</span>    &#125;]&#125;</code></pre><p>或者写一个runJava.bat文件放在jdk的bin目录下（具体可自行搜索）：</p><pre><code class="hljs bat">@<span class="hljs-built_in">ECHO</span> OFF <span class="hljs-built_in">cd</span> %~dp1 <span class="hljs-built_in">ECHO</span> Compiling %~nx1<span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXIST</span> %~n1.class ( <span class="hljs-built_in">DEL</span> %~n1.class ) javac %~nx1 <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXIST</span> %~n1.class ( <span class="hljs-built_in">ECHO</span> [OUTPUT]:java %~n1 )</code></pre><p>配合下面的配置文件：</p><pre><code class="hljs C++">&#123;<span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;runJava.bat&quot;</span>, <span class="hljs-string">&quot;$file&quot;</span>],<span class="hljs-string">&quot;file_regex&quot;</span>: <span class="hljs-string">&quot;^(...*?):([0-9]*):?([0-9]*)&quot;</span>,<span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.java&quot;</span>,<span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;UTF-8&quot;</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《Java核心技术（卷I）》学习笔记 (一)</title>
    <link href="/2019/02/27/2019-02-27-Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2019/02/27/2019-02-27-Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="java核心技术卷i学习笔记">Java核心技术（卷I）学习笔记</h1><h2 id="第三章-java基本程序设计结构"><strong>第三章 Java基本程序设计结构</strong></h2><p>[2019-02-27]</p><ol type="1"><li><p>在Java中使用"final"指示常量，一般来说变量名使用全大写字母，且该变量只可以赋值一次。在main方法外使用"static final"定义类常量，可以在同一个类中所有的方法中使用，若定义为"public"则可以再其它类中使用。</p></li><li><p>Integer是整数类，已封装，而int是基本的数据类型。</p></li><li><p>public static strictfp void main.........该方法中所有计算使用严格的浮点计算，中间结果不会截断。</p></li><li><p>常用数学函数：</p><p>Math.sin Math.cos Math.tan Math.atan Math.atan2 Math.exp Math.log Math.log10 Math.PI Math.E</p><figure><img src="C:\Users\Orion_wyc\AppData\Roaming\Typora\typora-user-images\1551248540993.png" alt="1551248540993" /><figcaption aria-hidden="true">1551248540993</figcaption></figure></li><li><p>32位的int型数字如果移位运算需要mod32，1&lt;&lt;37 &lt;=&gt; 1&lt;&lt;5。</p></li><li><p>Java中可使用"+"连接两个字符串，当某个字符串与非字符串类型P连接时，会自动将P转化成字符串类型。</p></li><li><p>Java中不可直接修改字符串某个位置具体的字符，但是可以修改整个字符串变量，例如，str = str.substring(0,3) + "p!",可将原来的str(内容是Hel)改为"Help!"。</p><p>String类对象被称为不可变对象。</p><p>检测两个字符串（变量）是否相等可使用s.equals(p)。</p><p><strong>（P50）具体参见Java String类 API文档</strong></p></li><li><p>有时要检查一个字符串既不是null 也不为空串，这种情况下就需要使用以下条件： if (str != null &amp;&amp; str.length() != 0)</p></li><li><p><strong><em>码点与代码单元部分暂时略过</em></strong></p></li><li><p>使用字符串构建器(StringBuilder类)来构建多个短小字符（串）的拼接字符串，最后使用builder.toString方法来得到一个完整的字符串。</p></li><li><p>（卷I）【P58】 printf 格式化输出控制字符，【P60】时间输出格式，文件读写等。</p></li><li><p>在C++ 中， 可以在嵌套的块中重定义一个变量。在内层定义的变量会覆盖在 外层定义的变量。这样， 有可能会导致程序设计错误， 因此在Java 中不允许这样做。</p></li><li><p>Java中的switch-case结构与C语言中相同：</p><pre><code class="hljs Java"><span class="hljs-keyword">switch</span> (choice)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-comment">// bad input</span><span class="hljs-keyword">break</span>;&#125;</code></pre></li><li><p>【P76-78】Java大数计算 BigInteger（整数）和BigDecimal（浮点数）</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//计算1000!</span>        BigInteger ans = BigInteger.valueOf(<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;            BigInteger input = BigInteger.valueOf(i);            ans = ans.multiply(input);        &#125;        System.out.print(ans);    &#125;&#125;</code></pre></li><li><p>Java中数组声明方式有二：Type[] a或者Type a[]，一般使用前者，只有Type[] a = new Type[N]，才算声明了一个长度为N的数组。多维数组的声明相同，并且可以声明不规则长度的数组，先初始化行数，在分配每一行的长度大小。【P89】</p><p>int[] small Primes = { 2, 3, 5, 7, 11, 13 };//不使用new来初始化</p><p>small Primes = new int[] { 17, 19, 23, 29, 31, 37 };//重新初始化</p><p>--匿名数组？？？</p><p>copyOf(array,arraylength)数组拷贝。</p></li><li><p>for each循环，功能与C++、Python相同。</p><pre><code class="hljs Java"></code></pre></li><li><p>命令行参数 "String[] agrs"，网上有详细说明。</p></li></ol><p><strong>[2019-02-28]--还未UP</strong></p><h2 id="第四章-对象与类">第四章 对象与类</h2><ol type="1"><li><p>OOP三特性：对象的行为、状态和标识。</p></li><li><p>类之间三大关系：</p><p>依赖(uses-a)--如果一个类的方法操纵另一个 类的对象，我们就说一个类依赖于另一个类</p><p>聚合(has-a)--聚合关系意味着类A 的对象包含类B 的对象</p><p>集成(is-a)--用于表示特殊与一般关系。</p></li><li><p>UML ( Unified Modeling Language , 统一建模语言）绘制类图（软工未选修）。</p><figure><img src="C:\Users\Orion_wyc\AppData\Roaming\Typora\typora-user-images\1551352375509.png" alt="1551352375509" /><figcaption aria-hidden="true">1551352375509</figcaption></figure></li><li><p>LocalDate类（感觉好奇怪）</p><p>只访问对象而不修改对象的方法有时称为访问器方法(accesser method)</p><p>会对对象造成影响，改变其状态的方法叫做更改器方法(mutator method)</p><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.time.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Orion233</span><span class="hljs-comment"> * print this month‘s calendar</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        LocalDate date = LocalDate.now();        <span class="hljs-keyword">int</span> month = date.getMonthValue();        <span class="hljs-keyword">int</span> today = date.getDayOfMonth() ;        date = date.minusDays(today - <span class="hljs-number">1</span>); <span class="hljs-comment">// Set to start of month</span>        DayOfWeek weekday = date.getDayOfWeek() ;        <span class="hljs-keyword">int</span> value = weekday.getValue();        System.out.println(<span class="hljs-string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span> + value) ;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; value; i++)            System.out.print(<span class="hljs-string">&quot;    &quot;</span>);        <span class="hljs-keyword">while</span> (date.getMonthValue() == month)        &#123;            System.out.printf(<span class="hljs-string">&quot;%3d&quot;</span>, date.getDayOfMonth()) ;            <span class="hljs-keyword">if</span> (date.getDayOfMonth() == today)                System.out.print(<span class="hljs-string">&quot;*&quot;</span>);            <span class="hljs-keyword">else</span>                System.out.print(<span class="hljs-string">&quot; &quot;</span>) ;            date = date.plusDays(<span class="hljs-number">1</span>) ;            <span class="hljs-keyword">if</span> (date.getDayOfWeek() .getValue() == <span class="hljs-number">1</span>) System.out.println();        &#125;        <span class="hljs-keyword">if</span> (date.getDayOfWeek() .getValue() != <span class="hljs-number">1</span>) System.out.println() ;    &#125;&#125;</code></pre></li><li><p>Java构造器（所有的Java 对象都是在堆中构造的）：</p><p>•构造器与类同名 •每个类可以有一个以上的构造器 •构造器可以有0 个、1 个或多个参数 •构造器没有返回值 •构造器总是伴随着new 操作一起调用</p></li><li><p>隐式参数与显式参数</p><p>this标识隐式参数，这样可以更好地实例域与局部变量明显地区分开来。</p><p><strong>成员变量：</strong></p><p>​ ①成员变量定义在类中，在整个类中都可以被访问。</p><p>​ ②成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。</p><p>​ ③成员变量有默认初始化值。</p><p><strong>局部变量：</strong></p><p>​ ①局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。</p><p>​ ②局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。</p><p>​ ③局部变量没有默认初始化值</p><pre><code class="hljs Java">进行局部运算的时候，局部变量会屏蔽全局变量。Example：Class A&#123;<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>；   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function"></span>&#123;A c = <span class="hljs-keyword">new</span> A(); a = <span class="hljs-number">2</span>;System.out.println(a);System.out.println(c.a);&#125;&#125;</code></pre><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age=<span class="hljs-number">1000</span>;<span class="hljs-comment">//定义成员变量，年龄为1000</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        age=age;        System.out.println(<span class="hljs-string">&quot;方法内的年龄&quot;</span>+age);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;我的年龄是&quot;</span>+age+<span class="hljs-string">&quot;.&quot;</span>);    &#125;&#125;......Person p=<span class="hljs-keyword">new</span> Person();p.setAge(<span class="hljs-number">20</span>);p.sayHello();......Results:<span class="hljs-comment">//方法内的年龄20</span><span class="hljs-comment">//我的年龄是1000.</span><span class="hljs-comment">/*</span><span class="hljs-comment">如果不同名，那么方法内的变量名代表成员变量；如果同名，那么方法内的变量名就只表示局部变量了，和成员变量一毛钱关系都没有了。</span><span class="hljs-comment">所以，首先当我们创建了一个Person对象p，在创建对象的时候就已经完成了成员变量的初始化了。成员变量age的初始值是1000。</span><span class="hljs-comment">当我们p.setAge(20)的时候，其实这个20只在setAge这个方法内起作用，所以输出了方法内年龄20，执行完这句话后，20就被销毁了。</span><span class="hljs-comment">然后执行sayHello，它里面的age代表的是成员变量的值，所以依旧是1000。</span><span class="hljs-comment"></span><span class="hljs-comment">所以这里应该使用this表示当前对象。</span><span class="hljs-comment">this.age在这里具体表示p对象的age(即p对象的成员变量age)的值是20。</span><span class="hljs-comment">*/</span></code></pre></li><li><p>方法可以访问所属类的私有特性（ feature ), 而不仅限于访问隐式参数的私有特性。一个方法可以访问所属类的所有 对象的私有数据。</p></li><li><p>另参考：</p></li><li><p>可以将实例域定义为final。构建对象时必须初始化这样的域。也就是说， 必须确保在每一个构造器执行之后， 这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。例如， 可以将Employee 类中的name 域声明为final , 因为在对象构建之后， 这个值不会再被修改， 即没有setName 方法。</p><p>PS：StringBUilder的例子不大一样，他可以修改，见【P112】</p><p>[2019-03-01]</p></li><li><p>如果将域定义为static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域 却都有自己的一份拷贝。</p><p>参考资料：<a href="https://www.cnblogs.com/dolphin0520/p/3799052.html">Java中的static关键字解析</a></p><p>静态变量、静态常量</p><p>静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。</p><p>--What is a field in java?</p><p>--A field is an attribute. A field may be a class’s variable, an object’s variable, an object’s method’s variable, or a parameter of a function.</p><p>field，域是一种属性，可以是一个类变量，一个对象变量，一个对象方法变量或者是一个函数的参数。（补充，class's variables，类的实例变量和静态变量称为class's variables，类属变量，也称类变量或数据域，其实翻译成属性也可以，类属性，听起来不会怪怪的，来自百度百科）。</p></li><li><p>可以使用对象调用静态方法e.g.可以用 harry.getNextId( ) 代替 Employee.getNextId( )，但是建议使用类名，而不是对象来调用 静态方法。</p><p>在下面2种情?下使用静态方法：</p><p>&lt;1&gt; 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow )</p><p>&lt;2&gt; 一个方法只需要访问类的静态域（例如：Employee.getNextld）</p></li><li><p>P132 4.4.4 工厂方法</p><ol type="1"><li><p>博客出处：http://blog.csdn.net/cgwshxs/archive/2008/12/05/3455136.aspx</p><p><strong>静态工厂方法讲解<一></strong> ​ 创建类的实例的最常见的方式是用new语句调用类的构造方法。在这种情况下，程序可以创建类的任意多个实例，每执行一条new语句，都会导致Java虚拟机的堆区中产生一个新的对象。假如类需要进一步封装创建自身实例的细节，并且控制自身实例的数目，那么可以提供静态工厂方法。 例如Class实例是Java虚拟机在加载一个类时自动创建的，程序无法用new语句创建java.lang.Class类的实例，因为Class类没有提供public类型的构造方法。为了使程序能获得代表某个类的Class实例，在Class类中提供了静态工厂方法</p><pre><code class="hljs reasonml"><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(String <span class="hljs-params">name</span>)</span>，它的使用方式如下：Class c=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;Sample&quot;</span>)</span>; <span class="hljs-comment">//返回代表Sample类的实例</span></code></pre><p>静态工厂方法与用new语句调用的构造方法相比，有以下区别。</p><p>（1）构造方法的名字必须与类名相同。这一特性的优点是符合Java语言的规范，缺点是类的所有重载的构造方法的名字都相同，不能从名字上区分每个重载方法，容易引起混淆。静态工厂方法的方法名可以是任意的，这一特性的优点是可以提高程序代码的可读性，在方法名中能体现与实例有关的信息。例如Gender类有两个静态工厂方法：getFemale()和getMale()。</p><pre><code class="hljs Java">Gender.java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gender</span></span>&#123;   <span class="hljs-keyword">private</span> String description;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Gender female=<span class="hljs-keyword">new</span> Gender(<span class="hljs-string">&quot;女&quot;</span>);   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Gender male=<span class="hljs-keyword">new</span> Gender(<span class="hljs-string">&quot;男&quot;</span>);   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Gender</span><span class="hljs-params">(String description)</span></span>&#123;<span class="hljs-keyword">this</span>.description=description;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Gender <span class="hljs-title">getFemale</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-keyword">return</span> female;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Gender <span class="hljs-title">getMale</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> male;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> description;&#125;&#125;</code></pre><p>这一特性的缺点是与其他的静态方法没有明显的区别，使用户难以识别类中到底哪些静态方法专门负责返回类的实例。为了减少这一缺点带来的负面影响，可以在为静态工厂方法命名时尽量遵守约定俗成的规范，当然这不是必需的。目前比较流行的规范是把静态工厂方法命名为valueOf或者getInstance。</p><pre><code class="hljs Java">valueOf：该方法返回的实例与它的参数具有同样的值，例如：       Integer a=Integer.valueOf(<span class="hljs-number">100</span>); <span class="hljs-comment">//返回取值为100的Integer对象</span></code></pre><p>从上面代码可以看出，valueOf()方法能执行类型转换操作，在本例中，把int类型的基本数据转换为Integer对象。</p><p>getInstance：返回的实例与参数匹配，例如：</p><p>//返回符合中国标准的日历</p><pre><code class="hljs Java">Calendar cal=Calendar.getInstance(Locale.CHINA);</code></pre><p>（2）每次执行new语句时，都会创建一个新的对象。而静态工厂方法每次被调用的时候，是否会创建一个新的对象完全取决于方法的实现。</p><p>（3）new语句只能创建当前类的实例，而静态工厂方法可以返回当前类的子类的实例，这一特性可以在创建松耦合的系统接口时发挥作用。</p><p>静态工厂方法最主要的特点是：每次被调用的时候，不一定要创建一个新的对象。利用这一特点，静态工厂方法可用来创建以下类的实例。 单例类：只有惟一的实例的类。 枚举类：实例的数量有限的类。 具有实例缓存的类：能把已经创建的实例暂且存放在缓存中的类。 具有实例缓存的不可变类：不可变类的实例一旦创建，其属性值就不会被改变。</p><p><strong>静态工厂方法讲解<二></strong> 实例化对象的方法：</p><p>1.构造函数。</p><p>2.静态工厂方法。（我不常用，但JAVA平台库有好多例子）</p><p>对于构造函数，是新建对象是自动调用的方法，返回该对象，主要用于初始化类的成员字段。而另外一种构建对象的方式是采用静态工厂方法。静态工厂方法与别的静态方法没有什么区别，只不过该方法产生的类对象，不做其他事情，如我们常用的Sington单态模式。使用静态工厂方法主要有以下优点：</p><p>第一：静态工厂方法可以突破构造函数不能自由命名的限制，对于不同的工厂方法可以采用不同的会意的名字，是程序具有更好的可读性。JAVA平台库的java.text.Format的子类NumberFormat就有getInstance() , getPrecentInstance() , getCurrencyInstatnce()等静态方法，通过不同的名字产生特定的对象。</p><p>第二：静态工厂方法是用来产生对象用的，至于产生什么类型的对象没有限制，这就意味这只要返回原返回类型或原返回类型的子类型都可以，这样就加大了程序设计和使用的灵活行，如java.util集合框架就采用了这种优势，这样就可以更好达到封装的目的，降低API的数目和用户的使用难度，java.util.Connections是集合框架的辅助类用于对原有的集合类进行进一步封装，产生一些同步的集合，不可修改的视图。都是采用静态工厂方法实现的，至于方法内部的实现类就完全别封装了。也迫使我们使用接口编程。</p><p>第三：静态工厂方法所创建的对象可以在编译时不存在，动态创建对象，采用放射，类似SPRING的IOC容器方转。最典型的例子就是spi服务提供者框架，Service Provider Iframe 是一种用于在运行时刻产生对象的框架，达到对象的创建与使用分离，是对象的客户和对象之间解耦，增加程序的灵活性和可扩展性。既然spi可以动态创建对象，那么采用什么机制来创建什么对象，创建对象的依据是什么了，spi必须一种统一的注册机制，对于要创建的对象，应该在XML文件中配置，到时候，只要提供一个字符串，就可以凭借该字符串来创建配置的对象。简单实现如下：</p><pre><code class="hljs Java"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SPITest</span></span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map SPIMap = <span class="hljs-keyword">new</span> HashMap(); <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSPIMapIfNeccury</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">if</span>(SPIMap == <span class="hljs-keyword">null</span>)&#123; SPIMap = <span class="hljs-keyword">new</span> HashMap(); &#125; <span class="hljs-comment">//initMap user the sepecify XML </span><span class="hljs-comment">//the map key is a beanName ,the value is a Object which config by XML</span> &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getInstace</span><span class="hljs-params">(String beanName)</span></span>&#123; Object result = <span class="hljs-keyword">null</span>; <span class="hljs-keyword">try</span>&#123; <span class="hljs-keyword">if</span>(SPIMap.containsKey(beanName))&#123; result = SPIMap.get(beanName); &#125; <span class="hljs-keyword">else</span>&#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot; please config the xml file ,this bean is not exists!&quot;</span>); &#125; &#125;<span class="hljs-keyword">catch</span>(Exception exce)&#123; exce.printStackTrace(); &#125; <span class="hljs-keyword">return</span> result; &#125;&#125;</code></pre><p>可以明显看出待创建的对象具体创建哪个对象，在编译时并不知道，只有在运行时刻才知道,将对象的创建工作推迟到运行时，这即是优点，有是缺点，失去了编译检查的功能。</p></li></ol><p><strong>但静态工厂方法又有缺点：</strong></p><pre><code>第一：如果将要创建的对象的构造方法是私有的或是default的，就有可能不能创建该对象。</code></pre><p>​ 第二：采用构造函数实例化对象，是语言的规范，而静态工厂方法与其他的静态方法没有区别，就增加了用户使用的区别。但这可以尽量采用一些家喻户晓的名字解决，让用户看到改名字就知道该方法是静态工厂方法。如getInstance（）。</p></li><li><p>未完待续...</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VMWARE使用记录</title>
    <link href="/2019/01/26/2019-01-26-VMWare%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/01/26/2019-01-26-VMWare%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>#<strong>VMWare</strong> ##<strong>解决虚拟机vmware安装64位系统“此主机支持 Intel VT-x，但 Intel VT-x 处于禁用状态”的问题</strong></p><p><strong>所遇到的情况</strong> 虚拟机使用的是VMware Workstation ，并且首次在虚拟机体验64 位系统。在新建好虚拟机，运行时候就出现了VMware Workstation 的提醒：此主机支持 Intel VT-x，但 Intel VT-x 处于禁用状态。如图：</p><pre><code class="hljs angelscript">提示信息：已将该虚拟机配置为使用 <span class="hljs-number">64</span> 位客户机操作系统。但是，无法执行 <span class="hljs-number">64</span> 位操作。此主机支持 Intel VT-x，但 Intel VT-x 处于禁用状态。如果已在 BIOS/固件设置中禁用 Intel VT-x，或主机自更改此设置后从未重新启动，则 Intel VT-x 可能被禁用。(<span class="hljs-number">1</span>) 确认 BIOS/固件设置中启用了 Intel VT-x 并禁用了“可信执行”。(<span class="hljs-number">2</span>) 如果这两项 BIOS/固件设置有一项已更改，请重新启动主机。(<span class="hljs-number">3</span>) 如果您在安装 VMware Workstation 之后从未重新启动主机，请重新启动。(<span class="hljs-number">4</span>) 将主机的 BIOS/固件更新至最新版本。有关更多详细信息，请参见 http:<span class="hljs-comment">//vmware.com/info?id=152。</span></code></pre><p><strong>解决方法</strong></p><p>看上面的提示 也就很好解决了：直接修改BIOS设置即可</p><p>以下以个人HP-暗影精灵2电脑为例：</p><p>1、关机，开机，在启动时，按F10进入BIOS 设置页面；</p><p>2、选择 Security，再选择Virtual ization并点击enter建进入该功能，在新功能中选择Intel (R) Virtualization Technology ，此时该选项应该是disabled（关闭）的；</p><p>3、将Disabled（关闭）改为 Enabled（开启）；</p><p>4、保存设置，点击F10，保存后退出，重启即可</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flex-Bison在windows下的安装与使用</title>
    <link href="/2019/01/15/2018-11-14-Flex-Bison%E5%AE%89%E8%A3%85/"/>
    <url>/2019/01/15/2018-11-14-Flex-Bison%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><strong>Linux下安装：</strong></p><pre><code class="hljs shell">sudo apt-get install flex bisonflex -hbison -h</code></pre><p><strong>Windows下安装：</strong> Flex下载地址：http://gnuwin32.sourceforge.net/packages/flex.htm Biosn下载地址：http://gnuwin32.sourceforge.net/packages/bison.htm</p><p>下载选择 <strong>Complete Package，except sources</strong> <img src="https://img-blog.csdnimg.cn/2018102715103511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29yaW9uX3Bpc3RhY2hpbw==,size_27,color_FFFFFF,t_70" alt="下再说明" /></p><p>安装过程和一般的win应用一样，点击setup.exe安装，默认安装位置是<strong>C盘</strong>，可以自己修改，先安装 <strong>Flex</strong> 在安装 <strong>Bison</strong>（比如我的目录是“<strong>D:</strong>”，<em>一般来说Bison的安装位置和Flex一致，如果不一致请修改成一样</em>）</p><p>安装完成后打开安装目录（flex和bison在一起）： <img src="https://img-blog.csdnimg.cn/20181027151608641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29yaW9uX3Bpc3RhY2hpbw==,size_27,color_FFFFFF,t_70" alt="就是这个样子的" /></p><p><strong>接下来配置环境变量：</strong> 将“**D:*”添加到**“系统变量**”中。</p><p><strong>接下来在cmd中查看是否安装成功：</strong></p><pre><code class="hljs cmd">flex -V      //就是大写的VVVVVVVV！！！！！bison -V     //就是大写的VVVVVVVV！！！！！</code></pre><p>可以得到如下结果 <img src="https://img-blog.csdnimg.cn/2018102715204969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29yaW9uX3Bpc3RhY2hpbw==,size_27,color_FFFFFF,t_70" alt="cmd结果" /></p><pre><code>[Tips]1.如果没有出现以上结果，请重启之后再试。（默认会修改环境变量）2.作为词法分析器使用并编译C代码需要在安装GCC，自行百度。</code></pre><p><strong>下面进行一个小测试：</strong> 代码要求：进行数字转换，比如2e3转换成2000、1.23e1转换成12.3...</p><p>这里发个链接供参考：https://blog.csdn.net/mayuko2012/article/details/51207192?locationNum=5</p><p>JNU CS1604 Orion233</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/01/15/hello-world/"/>
    <url>/2019/01/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><p><span class="math inline">\(Late_x \frac{1}{x^2}\)</span></p><h3 id="create-a-new-post">Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用Flex构造简易C语言词法分析器</title>
    <link href="/2019/01/15/2018-11-14-C%E8%AF%AD%E8%A8%80%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <url>/2019/01/15/2018-11-14-C%E8%AF%AD%E8%A8%80%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>Flex构造C语言词法分析器</strong> 可以识别大部分的C语言关键字和标识符，可以去除注释（多行单行都可以），可以识别整数和浮点数，可以识别错误的浮点数。</p><p>lex文件结构：</p><pre><code class="hljs cpp"> [第一部分：定义段]<span class="hljs-comment">/*</span><span class="hljs-comment"> *按照C语言语法，声明文件包含，宏定义，常数定义，全局变量及外部变量定义，函数声明等</span><span class="hljs-comment"> */</span> %% 第二部分：词法规则段  <span class="hljs-comment">/*</span><span class="hljs-comment"> *核心部分，正则定义和状态定义（解释见后）</span><span class="hljs-comment"> */</span> %% 第三部分：辅助函数段]  <span class="hljs-comment">/*</span><span class="hljs-comment"> * 辅助函数段用C语言语法来写，辅助函数一般是在词法规则段中用到的函数。这一部分一般会被直接拷贝到lex.yy.c中。</span><span class="hljs-comment"> */</span></code></pre><p>状态定义：</p><pre><code class="hljs c"><span class="hljs-string">&quot;//&quot;</span>.* &#123;&#125;<span class="hljs-string">&quot;/*&quot;</span> &#123;BEGIN COMMENT;&#125;&lt;COMMENT&gt;<span class="hljs-string">&quot;*/&quot;</span> &#123;BEGIN INITIAL;&#125;&lt;COMMENT&gt;. &#123;&#125;</code></pre><p>这一部分是根据不同的状态使用不同的规则，比如要识别多行注释，则添加BEGIN COMMENT即可转移到&lt; COMMENT &gt;状态。</p><p>代码如下：</p><pre><code class="hljs cpp">在这里插入代码片<span class="hljs-comment">/*</span><span class="hljs-comment"> *t2.lex 词法分析器</span><span class="hljs-comment"> *班级：计科1604</span><span class="hljs-comment"> *学号：1030416414</span><span class="hljs-comment"> *姓名：wyc（ORION233）</span><span class="hljs-comment"> *时间：2018-11-4</span><span class="hljs-comment"> */</span>%option pointer%option noyywrap%x COMMENT%&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 100</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXTYPE 10</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSTR 15</span><span class="hljs-keyword">char</span> *a[MAXTYPE] = &#123;<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;for&quot;</span>,<span class="hljs-string">&quot;integer&quot;</span>,<span class="hljs-string">&quot;decimal&quot;</span>,<span class="hljs-string">&quot;identify&quot;</span>,<span class="hljs-string">&quot;bracket&quot;</span>,<span class="hljs-string">&quot;QUOTE&quot;</span>,<span class="hljs-string">&quot;OPT&quot;</span>,<span class="hljs-string">&quot;float&quot;</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">int</span> line;<span class="hljs-comment">//store line numbers</span><span class="hljs-keyword">int</span> id;<span class="hljs-comment">// store tag</span><span class="hljs-keyword">char</span> text[MAXSTR];<span class="hljs-comment">//store yytext</span>&#125;tag[MAXLEN];<span class="hljs-comment">//store tags</span><span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//error flag</span><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//array notation counter</span>    <span class="hljs-keyword">int</span> line=<span class="hljs-number">1</span>;<span class="hljs-comment">//line counter</span>%&#125;DIGIT [<span class="hljs-number">0</span><span class="hljs-number">-9</span>]OINTEGER [<span class="hljs-number">1</span><span class="hljs-number">-9</span>]&#123;DIGIT&#125;*INTEGER (<span class="hljs-string">&quot;+&quot;</span>|<span class="hljs-string">&quot;-&quot;</span>)?&#123;OINTEGER&#125;DECIMAL &#123;INTEGER&#125;(.&#123;OINTEGER&#125;)?LETTER [a-zA-Z]ID (&#123;LETTER&#125;|_)(&#123;LETTER&#125;|_|&#123;DIGIT&#125;)*OPT (<span class="hljs-string">&quot;+=&quot;</span>|<span class="hljs-string">&quot;-=&quot;</span>|<span class="hljs-string">&quot;*=&quot;</span>|<span class="hljs-string">&quot;/=&quot;</span>|<span class="hljs-string">&quot;+&quot;</span>|<span class="hljs-string">&quot;-&quot;</span>|<span class="hljs-string">&quot;*&quot;</span>|<span class="hljs-string">&quot;/&quot;</span>|<span class="hljs-string">&quot;&lt;=&quot;</span>|<span class="hljs-string">&quot;&gt;=&quot;</span>|<span class="hljs-string">&quot;==&quot;</span>|<span class="hljs-string">&quot;=&quot;</span>)INDEX &#123;DIGIT&#125;+(\.&#123;DIGIT&#125;+)?e([+-])?&#123;DIGIT&#125;+ERROR &#123;DIGIT&#125;+(\.&#123;DIGIT&#125;+)?e%%<span class="hljs-string">&quot;//&quot;</span>.* &#123;&#125;<span class="hljs-string">&quot;/*&quot;</span> &#123;BEGIN COMMENT;&#125;&lt;COMMENT&gt;<span class="hljs-string">&quot;*/&quot;</span> &#123;BEGIN INITIAL;&#125;&lt;COMMENT&gt;. &#123;&#125;\n &#123;++line;&#125;(<span class="hljs-keyword">int</span>|<span class="hljs-keyword">float</span>|<span class="hljs-keyword">double</span>|<span class="hljs-keyword">short</span>) &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">0</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//has bugs--use strcpy is ok,no pointer </span><span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;<span class="hljs-keyword">for</span> &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">1</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;INTEGER&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">2</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;DECIMAL&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">3</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;ID&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">4</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;(<span class="hljs-string">&quot;(&quot;</span>|<span class="hljs-string">&quot;)&quot;</span>|<span class="hljs-string">&quot;&#123;&quot;</span>|<span class="hljs-string">&quot;&#125;&quot;</span>|<span class="hljs-string">&quot;[&quot;</span>|<span class="hljs-string">&quot;]&quot;</span>) &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">5</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;<span class="hljs-string">&quot;\&quot;&quot;</span> &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">6</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;OPT&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">7</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;INDEX&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">8</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;ERROR&#125; &#123;flag = <span class="hljs-number">1</span>;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">-1</span>;<span class="hljs-comment">//soso</span><span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); cnt++;&#125;. &#123;&#125;%%<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> *begin lexical analysis</span><span class="hljs-comment"> *present all the tags</span><span class="hljs-comment"> *but ...</span><span class="hljs-comment"> */</span>yylex();<span class="hljs-keyword">if</span>(flag) &#123;<span class="hljs-comment">//print ERRORS</span><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<span class="hljs-keyword">if</span>(tag[i].id == <span class="hljs-number">-1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error type A at Line %d: Illegal floating point number \&quot;%s\&quot;.\n&quot;</span>,tag[i].line,tag[i].text);<span class="hljs-keyword">break</span>;&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<span class="hljs-keyword">if</span>(tag[i].id == <span class="hljs-number">5</span>)&#123;<span class="hljs-comment">//print &quot;QUOTE&quot;</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;line%d:(%s, \&quot;%s\&quot;)\n&quot;</span>,tag[i].line,a[tag[i].id],tag[i].text);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;line%d:(%s, %s)\n&quot;</span>,tag[i].line,a[tag[i].id],tag[i].text);&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
