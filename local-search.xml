<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode专题 BFS DFS</title>
    <link href="/2020/07/26/2020-07-01-%E5%8A%9B%E6%89%A3-DFS+BFS/"/>
    <url>/2020/07/26/2020-07-01-%E5%8A%9B%E6%89%A3-DFS+BFS/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-bfs-dfs">LeetCode BFS + DFS</h1><p><strong>代码规范</strong></p><p><strong>TIPS：没有看Java的输入输出如何写，晚点补上。不写main函数。</strong></p><hr /><h2 id="stl专题">STL专题</h2><ul><li><p>map用法总结（<a href="https://blog.csdn.net/sevenjoin/article/details/81943864">整理1</a>）（<a href="https://www.cnblogs.com/tangyikejun/p/4220316.html">整理2</a>）</p></li><li><p>vector用法总结（<a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html">整理1</a>）</p></li><li><p>string用法大全（length() substring() substr()）</p></li></ul><hr /><p>1.<a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p><p>HashMap</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)            map.put(nums[i],i);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;            Integer v = map.get(target - nums[i]);            <span class="hljs-keyword">if</span>(v!=(Integer)i &amp;&amp; v!=<span class="hljs-keyword">null</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,v&#125;;<span class="hljs-comment">//也可以采用遍历一次Map的方法</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>)</span></span>;        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; num_map;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;            <span class="hljs-keyword">if</span>(num_map.count(target - nums[i]) == <span class="hljs-number">1</span>)&#123;                ans[<span class="hljs-number">0</span>] = num_map[target-nums[i]];                ans[<span class="hljs-number">1</span>] = i;                <span class="hljs-keyword">break</span>;            &#125;            num_map.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(nums[i],i));        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>7.<a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></p><p>注意数据的范围，反转之后会超过int_32，使用long不溢出，Java中使用的是 truncate 除法：</p><p>a=b*q +r，其中 |r|&lt;|a|。因此 r 有两个选择，一个为正，一个为负;相应的，q 也有两个选择。如果a、b 都是正数的话，那么一般的编程语言中，r 为正数；或者如果 a、b 都是负数的话，一般 r 为负数。但是如果 a、b 一正一负的话，不同的语言则会根据除法的不同结果而使得 r 的结果也不同，但是一般 r 的计算方法都会满足：r=a-(a/b)*b</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;            ans = ans*<span class="hljs-number">10</span> + x%<span class="hljs-number">10</span>;             x /=<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">int</span> A = (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>);        <span class="hljs-keyword">if</span>(ans &gt;= -A &amp;&amp; ans &lt;= A-<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)ans;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">//cout&lt;&lt; (-11%3)endl;-2147483648</span>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_INT = <span class="hljs-number">2147483647</span>;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MIN_INT = <span class="hljs-number">-2147483648</span>;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> p = x%<span class="hljs-number">10</span>; <span class="hljs-comment">//求x最低位数字</span>            <span class="hljs-comment">//每次对ans乘以10，当ans位数小于MAX_INT/MIN_INT时，一定不溢出；</span>            <span class="hljs-comment">//当ans位数与MAX_INT/MIN_INT相同时，需要考虑最后一位是否大于7或小于-8.</span>            <span class="hljs-keyword">if</span>(ans &gt; MAX_INT/<span class="hljs-number">10</span> || (ans == MAX_INT/<span class="hljs-number">10</span> &amp;&amp; p &gt; <span class="hljs-number">7</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">if</span>(ans &lt; MIN_INT/<span class="hljs-number">10</span> || (ans == MIN_INT/<span class="hljs-number">10</span> &amp; p &lt; <span class="hljs-number">-8</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            ans = ans*<span class="hljs-number">10</span> + p;            x /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>9.<a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></p><pre><code class="hljs Java"><span class="hljs-comment">//其实在T7中给出了计算回文串的一种方式，回文串一定不会溢出</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">long</span> num = <span class="hljs-number">0</span>;        <span class="hljs-keyword">long</span> xx = x;        <span class="hljs-keyword">while</span>(xx!=<span class="hljs-number">0</span>)&#123;            num = num*<span class="hljs-number">10</span> + xx%<span class="hljs-number">10</span>;            xx /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">if</span>(x == num)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-built_in">string</span> s = to_string(x);        <span class="hljs-built_in">string</span> r = to_string(x);        reverse(s.begin(),s.end());        <span class="hljs-keyword">if</span>(s==r)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//反转一半的情况</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">/* 判断特殊情况</span><span class="hljs-comment">         * 情况1:负数  情况2:末尾有0的整数,反转后前缀0没了,满足条件的只有0</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || (x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> &amp;&amp; x!=<span class="hljs-number">0</span>))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//为了防止溢出,反转一半的数字</span>        <span class="hljs-comment">//int len = 0;这里不需要求出长度,数字对半分之后可以比较出大小</span>        <span class="hljs-keyword">int</span> half = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x &gt; half)&#123;            <span class="hljs-keyword">int</span> tmp = x%<span class="hljs-number">10</span>;            half = half*<span class="hljs-number">10</span> + tmp;            x /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-comment">//此处考虑了数字长度为奇数或偶数的情况</span>        <span class="hljs-keyword">return</span> x==half || x==(half/<span class="hljs-number">10</span>);    &#125;&#125;;</code></pre><p>13.<a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></p><p>这道题目学习到了Map的优雅的初始化方式和罗马数字的计数规则。</p><p>罗马数字是阿拉伯数字传入之前使用的一种数码。罗马数字采用七个罗马字母作数字、即Ⅰ（1）、X（10）、C（100）、M（1000）、V（5）、L（50）、D（500）。记数的方法：</p><pre><code class="hljs angelscript">https:<span class="hljs-comment">//www.douban.com/note/335254352/</span>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=<span class="hljs-number">3</span>；小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=<span class="hljs-number">8</span>、Ⅻ=<span class="hljs-number">12</span>；小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=<span class="hljs-number">4</span>、Ⅸ=<span class="hljs-number">9</span>；在一个数的上面画一条横线，表示这个数增值 <span class="hljs-number">1</span>,<span class="hljs-number">000</span> 倍，如V(上面一横) = <span class="hljs-number">5000</span>。</code></pre><pre><code class="hljs java">Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;() &#123;<span class="hljs-comment">//第二个&quot;&lt;&gt;&quot;内的内容不可以缺少</span>    　　&#123;        　　put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;June&quot;</span>);         　　 put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">12</span>);      　　&#125;　　&#125;; 　　　<span class="hljs-comment">/*外层的一组“&#123;&#125;”表示的是一个匿名类，内层的一对“&#123;&#125;”表示的是实例初始化块，然后这边还有一点需要明白，实例初始化块的代码在编译器编译过后，是放在类的构造函数里面的，并且是在原构造函数代码的前面。&quot;*/</span></code></pre><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(String s)</span> </span>&#123;        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;()&#123;            &#123;                put(<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>);                 put(<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>);                put(<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>);                put(<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>);                put(<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>);                put(<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>);                put(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>);            &#125;        &#125;;<span class="hljs-comment">//一开始这里出错了，没有用Character类而用的String类，指针异常</span>        <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> curr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;             curr = map.get(s.charAt(i));            <span class="hljs-keyword">if</span>(curr &gt; last)                ans = ans - <span class="hljs-number">2</span>*last;            ans += curr;            last = curr;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//C++ version</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp&#123;            &#123;<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>&#125;,            &#123;<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>&#125;,            &#123;<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>&#125;,            &#123;<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>&#125;,            &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>&#125;,            &#123;<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>&#125;,            &#123;<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>&#125;        &#125;;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储上一位罗马数字</span>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储当前的罗马数字，与上一位比较大小，若小于直接相加，大于则减去2*pre</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            cur = mp[s[i]];            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; cur &gt; pre)&#123;                ans -= <span class="hljs-number">2</span>*pre;            &#125;            ans += cur;            pre = cur;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//低效</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; num;        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-number">1</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-number">4</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-number">5</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;IX&quot;</span>, <span class="hljs-number">9</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-number">10</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-number">40</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-number">50</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;XC&quot;</span>, <span class="hljs-number">90</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">100</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-number">400</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">500</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;CM&quot;</span>, <span class="hljs-number">900</span>));        num.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-number">1000</span>));        <span class="hljs-keyword">int</span> len = s.length();        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;            <span class="hljs-keyword">if</span>(i&lt;len<span class="hljs-number">-1</span> &amp;&amp; num.count(s.substr(i,<span class="hljs-number">2</span>)) &gt; <span class="hljs-number">0</span>) &#123;                ans += num[s.substr(i,<span class="hljs-number">2</span>)];                i++;            &#125;            <span class="hljs-keyword">else</span> &#123;                ans += num[s.substr(i,<span class="hljs-number">1</span>)];            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>14.<a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></p><p>大概有这五种思路, 一般都会采用第四种, 但是耗时太多</p><p>1、所求的最长公共前缀子串一定是每个字符串的前缀子串。所以随便选择一个字符串作为标准，把它的前缀串，与其他所有字符串进行判断，看是否是它们所有人的前缀子串。这里的时间性能是O(m<em>n</em>m)。</p><p>2、列出所有的字符串的前缀子串，将它们合并后排序，找出其中个数为n且最长的子串。时间性能为O(n<em>m+m</em>n<em>log(m</em>n))</p><p>3、纵向扫描：从下标0开始，判断每一个字符串的下标0，判断是否全部相同。直到遇到不全部相同的下标。时间性能为O(n*m)。</p><p>4、横向扫描：前两个字符串找公共子串，将其结果和第三个字符串找公共子串……直到最后一个串。时间性能为O(n*m)。</p><p>5、借助trie字典树。将这些字符串存储到trie树中。那么trie树的第一个分叉口之前的单分支树的就是所求。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//居然有空的string数组</span>        <span class="hljs-keyword">int</span> maxlen = strs[<span class="hljs-number">0</span>].length();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=maxlen;l++)&#123;            String prefix = strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>,l);            cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;strs.length;i++)&#123;                <span class="hljs-keyword">if</span>(strs[i].startsWith(prefix))&#123;                    cnt++;                &#125;                       &#125;            <span class="hljs-keyword">if</span>(cnt!=strs.length-<span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">if</span>(l==<span class="hljs-number">1</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;                <span class="hljs-keyword">else</span>                     <span class="hljs-keyword">return</span> prefix.substring(<span class="hljs-number">0</span>,l-<span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(l==strs[<span class="hljs-number">0</span>].length())&#123;                    <span class="hljs-keyword">return</span> prefix.substring(<span class="hljs-number">0</span>,l);                &#125;                 &#125;                   &#125;          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs)</span> </span>&#123;        <span class="hljs-built_in">string</span> ans = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">if</span>(strs.size()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> ans;        sort(strs.begin(),strs.end());        <span class="hljs-keyword">int</span> LEN = <span class="hljs-number">0x3f3f3f3f</span>;        <span class="hljs-keyword">int</span> CNT = strs.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;CNT;i++)&#123;            <span class="hljs-keyword">if</span>(strs[i].length() &lt; LEN)&#123;                LEN = strs[i].length();            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;LEN;i++)&#123;            <span class="hljs-keyword">if</span>(strs[<span class="hljs-number">0</span>][i]==strs[CNT<span class="hljs-number">-1</span>][i])&#123;                ans += strs[<span class="hljs-number">0</span>][i];            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>20.<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<span class="hljs-comment">//简单的堆栈应用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-comment">//Stack&lt;Character&gt; stk = new Stack&lt;&gt;();</span>        Stack stk = <span class="hljs-keyword">new</span> Stack();        <span class="hljs-keyword">if</span>(s.length()%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-comment">//stk.push(s.charAt(0));</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            <span class="hljs-keyword">if</span>(stk.empty())&#123;                stk.push(s.charAt(i));                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">char</span> c = (<span class="hljs-keyword">char</span>)stk.peek();            <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; c==<span class="hljs-string">&#x27;(&#x27;</span> || s.charAt(i)==<span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; c==<span class="hljs-string">&#x27;[&#x27;</span> ||s.charAt(i)==<span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; c==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;                stk.pop();            &#125;            <span class="hljs-keyword">else</span>                 stk.push(s.charAt(i));        &#125;        <span class="hljs-keyword">if</span>(stk.empty())            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><pre><code class="hljs Java"><span class="hljs-comment">//巨慢无比124ms 但是短啊</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s.length()%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">while</span>(s.indexOf(<span class="hljs-string">&quot;()&quot;</span>)!=-<span class="hljs-number">1</span> || s.indexOf(<span class="hljs-string">&quot;[]&quot;</span>)!=-<span class="hljs-number">1</span> || s.indexOf(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>)!=-<span class="hljs-number">1</span>)&#123;            s=s.replaceAll(<span class="hljs-string">&quot;\\(\\)&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);            s=s.replaceAll(<span class="hljs-string">&quot;\\[\\]&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);            s=s.replaceAll(<span class="hljs-string">&quot;\\&#123;\\&#125;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> s.length()==<span class="hljs-number">0</span>;    &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//优秀的题解,使用数字来表示括号,判断条件好写</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; m&#123;&#123;<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-number">3</span>&#125;,                                &#123;<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-number">6</span>&#125;&#125;;        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; st;        <span class="hljs-keyword">bool</span> istrue=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:s)&#123;            <span class="hljs-keyword">int</span> flag=m[c];            <span class="hljs-keyword">if</span>(flag&gt;=<span class="hljs-number">1</span>&amp;&amp;flag&lt;=<span class="hljs-number">3</span>) st.push(c);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!st.empty()&amp;&amp;m[st.top()]==flag<span class="hljs-number">-3</span>) st.pop();            <span class="hljs-keyword">else</span> &#123;istrue=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;        &#125;        <span class="hljs-keyword">if</span>(!st.empty()) istrue=<span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> istrue;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//C++版,默认flag为true,去判断括号不匹配的情况</span><span class="hljs-comment">//情况1:当前括号是右括号但是与栈顶的括号不匹配</span><span class="hljs-comment">//情况2:当前括号是右括号但是栈空</span><span class="hljs-comment">//情况3:括号串扫描结束，但栈中有多余的括号(奇数情况)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; st;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span> || s[i]==<span class="hljs-string">&#x27;[&#x27;</span> ||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;                st.push(s[i]);            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(!st.empty())&#123;                    <span class="hljs-keyword">char</span> c = st.top();                    st.pop();                    <span class="hljs-keyword">if</span>((s[i]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;c==<span class="hljs-string">&#x27;(&#x27;</span>) || (s[i]==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;c==<span class="hljs-string">&#x27;[&#x27;</span>) || (s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;c==<span class="hljs-string">&#x27;&#123;&#x27;</span>))&#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        flag = <span class="hljs-literal">false</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;                <span class="hljs-keyword">else</span> &#123;                    flag = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;                <span class="hljs-keyword">if</span>(!st.empty())&#123;            flag = <span class="hljs-literal">false</span>;        &#125;                  <span class="hljs-keyword">return</span> flag;    &#125;&#125;;</code></pre><p>21.<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序表</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode *next;</span><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;        <span class="hljs-comment">//合并不需要再申请空间，直接指针连接，返回结果为L-next.</span>        ListNode* L = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);        ListNode* p = L;        ListNode* p1 = l1;        ListNode* p2 = l2;                <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">NULL</span> &amp;&amp; p2!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">if</span>( p1-&gt;val &lt; p2-&gt;val)&#123;                p-&gt;next = p1;                p = p-&gt;next;                p1 = p1-&gt;next;            &#125;            <span class="hljs-keyword">else</span> &#123;                p-&gt;next = p2;                p = p-&gt;next;                p2 = p2-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">if</span>(p1!=<span class="hljs-literal">NULL</span>)p-&gt;next = p1;        <span class="hljs-keyword">if</span>(p2!=<span class="hljs-literal">NULL</span>)p-&gt;next = p2;        <span class="hljs-keyword">return</span> L-&gt;next;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode *next;</span><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;        ListNode *p1 = l1; <span class="hljs-comment">//链表l1的指针,指向第一个结点</span>        ListNode *p2 = l2; <span class="hljs-comment">//链表l2的指针,指向第一个结点</span>        ListNode *L = <span class="hljs-keyword">new</span> ListNode(); <span class="hljs-comment">//合并后的链表头结点，分配空间</span>        ListNode *p = L; <span class="hljs-comment">//新链表的尾指针</span>        <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">nullptr</span> &amp;&amp; p2!=<span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)&#123;                p-&gt;next = p1;                p = p-&gt;next;                p1 = p1-&gt;next;            &#125;            <span class="hljs-keyword">else</span> &#123;                p-&gt;next = p2;                p = p-&gt;next;                p2 = p2-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">if</span>(p1!=<span class="hljs-literal">nullptr</span>)&#123;            p-&gt;next = p1;            <span class="hljs-comment">// p1 = p1-&gt;next;</span>        &#125;        <span class="hljs-keyword">if</span>(p2!=<span class="hljs-literal">nullptr</span>)&#123;            p-&gt;next = p2;            <span class="hljs-comment">// p2 = p2-&gt;next;</span>        &#125;        <span class="hljs-keyword">return</span> L-&gt;next;    &#125;&#125;;</code></pre><p>26.<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除数组中的重复项</a></p><p>双指针法。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//双指针(游标)法</span>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储新数组的尾部</span>        <span class="hljs-comment">// int cur = 0; //当前遍历到的数字</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;cur&lt;nums.size();cur++)&#123;            <span class="hljs-keyword">if</span>(nums[cur]!=nums[end])&#123;                end ++;                nums[end] = nums[cur];            &#125;        &#125;        <span class="hljs-keyword">return</span> end+<span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><p>27.<a href="https://leetcode-cn.com/problems/remove-element/">移除元素</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;nums.size();j++)&#123;            <span class="hljs-keyword">if</span>(nums[j]!=val)&#123;                swap(nums[i],nums[j]);                i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-comment">// if(nums.size()==0)&#123;</span>        <span class="hljs-comment">//     return 0;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储新数组的最后一个元素的下标,插入到下一个位置</span>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前遍历到的元素下标</span>        <span class="hljs-keyword">for</span>(cur=<span class="hljs-number">0</span>;cur&lt;nums.size();cur++)&#123;            <span class="hljs-keyword">if</span>(nums[cur]!=val)&#123;                nums[end] = nums[cur];                end ++;            &#125;        &#125;                <span class="hljs-keyword">return</span> end;    &#125;&#125;;</code></pre><p>35.<a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//本质上是一个二分查找的题目</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> r = nums.size();        <span class="hljs-comment">//使用[l,r)的二分写法，最后返回首个大于等于target的值的位置</span>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<span class="hljs-comment">//区间[l,r)非空</span>            <span class="hljs-keyword">int</span> mid = l + (r - l)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target)&#123;                r = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                l = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> l;    &#125;&#125;;</code></pre><p>38.<a href="https://leetcode-cn.com/problems/count-and-say/submissions/">报数</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vec2str</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;ans, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;            ans += (<span class="hljs-keyword">char</span>)(nums[i] + <span class="hljs-string">&#x27;0&#x27;</span>);        &#125;    &#125;     <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums[<span class="hljs-number">30</span>];        nums[<span class="hljs-number">0</span>].push_back(<span class="hljs-number">1</span>);                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> val = nums[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;nums[i].size();j++)&#123;                <span class="hljs-keyword">if</span>(nums[i][j]==val)&#123;                    cnt++;                &#125;<span class="hljs-keyword">else</span>&#123;                    nums[i+<span class="hljs-number">1</span>].push_back(cnt);                    nums[i+<span class="hljs-number">1</span>].push_back(val);                    val = nums[i][j];                    cnt = <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">if</span>(j==nums[i].size()<span class="hljs-number">-1</span>)&#123;                    nums[i+<span class="hljs-number">1</span>].push_back(cnt);                    nums[i+<span class="hljs-number">1</span>].push_back(val);                &#125;            &#125;        &#125;        <span class="hljs-built_in">string</span> ans;        vec2str(ans,nums[n<span class="hljs-number">-1</span>]);        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//这个写法还不错</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;1&quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;            <span class="hljs-built_in">string</span> tmp = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">int</span> len = s.length();            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;            <span class="hljs-comment">/*首个数字已经计数,下面的循环需要比较后一个数字与当前数字是否相同:</span><span class="hljs-comment">              若相同,则计数+1,否则,按照规则将已统计的字符写入字符串,设置cnt为1,</span><span class="hljs-comment">              此处的1表示的就是后一个字符重新开始计数,不设置为0。</span><span class="hljs-comment">            */</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;                <span class="hljs-keyword">if</span>(j&lt;len<span class="hljs-number">-1</span> &amp;&amp; s[j]==s[j+<span class="hljs-number">1</span>]) &#123;                    cnt ++;                &#125;                 <span class="hljs-keyword">else</span> &#123;                    tmp += to_string(cnt) + s[j];                    cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">//这里计算的是后一个数字的数量</span>                &#125;            &#125;            s = tmp;        &#125;        <span class="hljs-keyword">return</span> s;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;1&quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;            <span class="hljs-built_in">string</span> tmp = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">int</span> len = s.length();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;                <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<span class="hljs-comment">//这里注意是1</span>                <span class="hljs-keyword">while</span>(j&lt;len<span class="hljs-number">-1</span> &amp;&amp; s[j] == s[j+<span class="hljs-number">1</span>])&#123;                    cnt++;                    j++;                &#125;                tmp += to_string(cnt)+s[j];            &#125;            s = tmp;        &#125;        <span class="hljs-keyword">return</span> s;    &#125;&#125;;</code></pre><p>53.<a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序列和</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//O(n)的算法</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        ll cur_sum = <span class="hljs-number">0</span>;        ll max_sum = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;            cur_sum += nums[i];            <span class="hljs-keyword">if</span>(cur_sum &gt; max_sum)&#123;                max_sum = cur_sum;            &#125;            <span class="hljs-keyword">if</span>(cur_sum &lt; <span class="hljs-number">0</span>)&#123;                cur_sum = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> max_sum;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//O(n)的算法,可返回最大和的区间下标,（未验证）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        ll cur_sum = <span class="hljs-number">0</span>;        ll max_sum = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> max_l = <span class="hljs-number">0</span>, max_r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cur_l = <span class="hljs-number">0</span>, cur_r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;            cur_sum += nums[i];            cur_r = i;            <span class="hljs-keyword">if</span>(cur_sum &gt; max_sum)&#123;                max_sum = cur_sum;                max_l = cur_l;                max_r = cur_r;            &#125;            <span class="hljs-keyword">if</span>(cur_sum &lt; <span class="hljs-number">0</span>)&#123;                cur_sum = <span class="hljs-number">0</span>;                cur_l = i+<span class="hljs-number">1</span>;                cur_r = i+<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt; max_l &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; max_r &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> max_sum;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//1896 ms7 MB</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//下面使用分治法来求解,精妙的方法</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPartitionSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;        <span class="hljs-keyword">if</span>(low==high)&#123;            <span class="hljs-keyword">return</span> nums[low];        &#125;        <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> left_sum = maxPartitionSum(nums, low, mid);        <span class="hljs-keyword">int</span> right_sum = maxPartitionSum(nums, mid+<span class="hljs-number">1</span>, high);        <span class="hljs-comment">//处理跨越中间的区间    </span>        <span class="hljs-keyword">int</span> mid_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> tmp_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> max_tmp_sum = nums[mid];        <span class="hljs-comment">//处理左半区[0,mid]</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            tmp_sum += nums[i];            max_tmp_sum = max(max_tmp_sum, tmp_sum);        &#125;        mid_sum += max_tmp_sum;        <span class="hljs-comment">//处理右半区[mid+1，high]</span>        tmp_sum = <span class="hljs-number">0</span>;        max_tmp_sum = nums[mid+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=high;i++)&#123;            tmp_sum += nums[i];            max_tmp_sum = max(max_tmp_sum, tmp_sum);        &#125;        mid_sum += max_tmp_sum;        <span class="hljs-keyword">return</span> max(mid_sum, max(left_sum,right_sum));    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//递归 分治 分别求左右子区间的最大和, 跨越中间连接的部分特殊处理.</span>        <span class="hljs-keyword">return</span> maxPartitionSum(nums, <span class="hljs-number">0</span>, nums.size()<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><p>58.<a href="https://leetcode-cn.com/problems/length-of-last-word/">最后一个单词的长度</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len = s.length()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(len&gt;=<span class="hljs-number">0</span> &amp;&amp; s[len]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;                len --;        &#125;        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span> || len == <span class="hljs-number">-1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">while</span>(len&gt;=<span class="hljs-number">0</span> &amp;&amp; s[len]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;            ans ++;            len --;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>66.<a href="https://leetcode-cn.com/problems/plus-one/">加一</a></p><pre><code class="hljs C++"><span class="hljs-comment">//可以考虑拓展为加减乘除</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; digits)</span> </span>&#123;        digits[digits.size()<span class="hljs-number">-1</span>] += <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=digits.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;             <span class="hljs-keyword">int</span> num = digits[i];            <span class="hljs-keyword">if</span>(num/<span class="hljs-number">10</span>!=<span class="hljs-number">0</span>)&#123;                digits[i] = num % <span class="hljs-number">10</span>;                <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span>)&#123;                    digits[i<span class="hljs-number">-1</span>] += num/<span class="hljs-number">10</span>;                 &#125;                <span class="hljs-keyword">else</span> &#123;                    digits.insert(digits.begin(), num/<span class="hljs-number">10</span>);                &#125;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> digits;    &#125;&#125;;</code></pre><p>67.<a href="https://leetcode-cn.com/problems/add-binary/">二进制求和</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b)</span> </span>&#123;        <span class="hljs-built_in">string</span> ans = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//感觉可以直接在a b上操作</span>        <span class="hljs-keyword">int</span> len_a = a.length()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">int</span> len_b = b.length()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">bool</span> carry = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">while</span>(len_a &gt;=<span class="hljs-number">0</span> &amp;&amp; len_b&gt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(a[len_a]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; b[len_b]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<span class="hljs-comment">//1+1</span>                ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : (<span class="hljs-string">&quot;0&quot;</span> + ans);                carry = <span class="hljs-literal">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[len_a]==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; b[len_b]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<span class="hljs-comment">//0+0</span>                ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : (<span class="hljs-string">&quot;0&quot;</span> + ans);                carry = <span class="hljs-literal">false</span>;            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//1+0的11情况</span>                ans = carry ? (<span class="hljs-string">&quot;0&quot;</span> + ans) : (<span class="hljs-string">&quot;1&quot;</span> + ans);                <span class="hljs-comment">//carry do not change.</span>            &#125;            len_a --;            len_b --;        &#125;        <span class="hljs-keyword">while</span>(len_a &gt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(a[len_a]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;                ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : (<span class="hljs-string">&quot;0&quot;</span> + ans);                carry = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                ans = carry ? (<span class="hljs-string">&quot;0&quot;</span> + ans) : (<span class="hljs-string">&quot;1&quot;</span> + ans);                <span class="hljs-comment">//carry do not change.</span>            &#125;            len_a --;        &#125;        <span class="hljs-keyword">while</span>(len_b &gt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(b[len_b]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;                ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : (<span class="hljs-string">&quot;0&quot;</span> + ans);                carry = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                ans = carry ? (<span class="hljs-string">&quot;0&quot;</span> + ans) : (<span class="hljs-string">&quot;1&quot;</span> + ans);                <span class="hljs-comment">//carry do not change.</span>            &#125;            len_b --;        &#125;        ans = carry ? (<span class="hljs-string">&quot;1&quot;</span> + ans) : ans ;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><pre><code class="hljs python">//转化成数字看看就好hhh<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addBinary</span>(<span class="hljs-params">self, a, b</span>) -&gt; str:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;0:b&#125;&#x27;</span>.format(int(a, <span class="hljs-number">2</span>) + int(b, <span class="hljs-number">2</span>))</code></pre><pre><code class="hljs Python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">精妙的位运算方法</span><span class="hljs-string">A  B  ^  &amp;  +</span><span class="hljs-string">0  0  0  0  0+0=00</span><span class="hljs-string">0  1  1  0  0+1=01</span><span class="hljs-string">1  0  1  0  1+0=01</span><span class="hljs-string">1  1  0  1  1+1=10</span><span class="hljs-string">统一先计算^这样没有进位，然后统一把进位求出来，加进去。 这样可能还会有进位，所以就继续循环，直到没有进位。</span><span class="hljs-string">&#x27;&#x27;&#x27;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addBinary</span>(<span class="hljs-params">self, a, b</span>) -&gt; str:</span>        x, y = int(a, <span class="hljs-number">2</span>), int(b, <span class="hljs-number">2</span>)        <span class="hljs-keyword">while</span> y:            answer = x ^ y            carry = (x &amp; y) &lt;&lt; <span class="hljs-number">1</span>            x, y = answer, carry        <span class="hljs-keyword">return</span> bin(x)[<span class="hljs-number">2</span>:]</code></pre><p>69.<a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//lower bound,二分给出的解是首个大于等于根号x的整数</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = x;        <span class="hljs-keyword">while</span>(l &lt; r)&#123;             <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>( (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) mid*mid &gt;= x)&#123; <span class="hljs-comment">//这里防止溢出</span>                r = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                l = mid + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-built_in">cout</span>&lt;&lt; l  &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-comment">//此处的二分法在[a,b)求得的结果为首个不小于sqrt(x)的整数</span>        <span class="hljs-comment">//可能解刚好是a,也可能是大于sqrt(x),所以最后需要判断一下。</span>        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) l*l &gt; x) ? l<span class="hljs-number">-1</span> : l;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//upper bound 二分给出的解是首个大于根号x的整数</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = x;        <span class="hljs-keyword">while</span>(l &lt; r)&#123;             <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>( (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) mid*mid &gt; x)&#123; <span class="hljs-comment">//这里防止溢出</span>                r = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                l = mid + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-built_in">cout</span>&lt;&lt; l  &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-comment">//此处的二分法在[a,b)求得的结果为首个大于sqrt(x)的整数</span>        <span class="hljs-comment">//可能解a一定大于正确解(0,1除外)sqrt(x),所以最后需要减去1,判特例</span>        <span class="hljs-keyword">return</span> (x == <span class="hljs-number">0</span> || x == <span class="hljs-number">1</span>) ? x : l<span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//试一下牛顿迭代法！！！ x_&#123;n+1&#125; = x_n - f(x_n)/f^&#x27;(x_n) </span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">double</span> xi = x, C = x; <span class="hljs-comment">//为什么float不行</span>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">double</span> xj = <span class="hljs-number">0.5</span>*(xi + C/xi);            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(xj - xi) &lt; <span class="hljs-number">1e-6</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;            xi = xj;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(xi);    &#125;&#125;;</code></pre><p>70.爬楼梯</p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/shu-xue-zuo-fa-jie-bu-ding-fang-cheng-pai-lie-zu-h/">我的傻瓜题解</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//一开始想到的方法</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">//这个方法不是本题最优解，但是学习到了如何求组合数字</span>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span></span>&#123;         <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;            tmp = tmp*(n-m+i)/i;        &#125;        <span class="hljs-keyword">return</span> tmp;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;=n;x++)&#123;            <span class="hljs-keyword">int</span> y = (n - x) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(n == x + <span class="hljs-number">2</span>*y)&#123;                cnt += C(y,x+y);            &#125;        &#125;        <span class="hljs-keyword">return</span> cnt;    &#125;&#125;;</code></pre><p>动态规划常常适用于有<strong>重叠子问题和最优子结构</strong>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p><p>动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//动态规划</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;            dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//矩阵快速幂</span>以后再说</code></pre><p>83.删除排序链表中的重复元素</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode *next;</span><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        ListNode* p = head; <span class="hljs-comment">//慢指针</span>        ListNode* q = head-&gt;next; <span class="hljs-comment">//快指针</span>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">nullptr</span> &amp;&amp; q!=<span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">if</span>(p-&gt;val == q-&gt;val)&#123;                p-&gt;next = q-&gt;next;                ListNode* del = q;                q = q-&gt;next;                <span class="hljs-keyword">delete</span> del;            &#125;<span class="hljs-keyword">else</span>&#123;                p = p-&gt;next;                q = q-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode *next;</span><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//尝试使用直接删除法</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        ListNode* p = head;        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">if</span>(p-&gt;val==p-&gt;next-&gt;val)&#123;                ListNode* del = p-&gt;next;                p-&gt;next = p-&gt;next-&gt;next;                <span class="hljs-keyword">delete</span> del;            &#125;<span class="hljs-keyword">else</span>&#123;                p = p-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;&#125;;</code></pre><p>88.<a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a> ★</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//这题的特殊之处在于可反向考虑减少数组元素的移动</span><span class="hljs-comment">//总数m+n从后往前一定不会覆盖未排序的nums1元素</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> tal = m + n - <span class="hljs-number">1</span>;        m --;        n --;        <span class="hljs-keyword">while</span>(m&gt;=<span class="hljs-number">0</span> &amp;&amp; n&gt;=<span class="hljs-number">0</span>)&#123;            nums1[tal--] = (nums1[m] &gt;= nums2[n]) ? nums1[m--] : nums2[n--];        &#125;        <span class="hljs-keyword">while</span>(n&gt;=<span class="hljs-number">0</span>)&#123;            nums1[tal--] = nums2[n--];        &#125;    &#125;&#125;;</code></pre><p>100.<a href="https://leetcode-cn.com/problems/same-tree/">相同的树</a> ★</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> &amp;&amp; q==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span>((p!=<span class="hljs-literal">NULL</span>&amp;&amp;q==<span class="hljs-literal">NULL</span>) || (p==<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>) || (p-&gt;val!=q-&gt;val))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//递归地判断左右子树</span>        <span class="hljs-keyword">return</span> isSameTree(p-&gt;left, q-&gt;left)&amp;&amp;isSameTree(p-&gt;right, q-&gt;right);            &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">checkNode</span><span class="hljs-params">(TreeNode *p, TreeNode* q)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> &amp;&amp; q==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>((p!=<span class="hljs-literal">NULL</span>&amp;&amp;q==<span class="hljs-literal">NULL</span>) || (p==<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>) || (p-&gt;val!=q-&gt;val))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;        que.push(p);        que.push(q);<span class="hljs-comment">//可以只用一个队列来存储两个结点</span>        <span class="hljs-comment">//BFS</span>        <span class="hljs-keyword">while</span>(!que.empty())&#123;            TreeNode* r = que.front();<span class="hljs-comment">//由于只使用了一个队列，需要注意存取顺序对应</span>            que.pop();            TreeNode* s = que.front();            que.pop();            <span class="hljs-keyword">switch</span>(checkNode(r,s))&#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                    que.push(r-&gt;left);                    que.push(s-&gt;left);                    que.push(r-&gt;right);                    que.push(s-&gt;right);                <span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre><p>101.<a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//本质上与上一题相同</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> &amp;&amp; q==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> || q==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(p-&gt;val!=q-&gt;val)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> check(p-&gt;left,q-&gt;right)&amp;&amp;check(p-&gt;right,q-&gt;left);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> check(root-&gt;left, root-&gt;right);    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">return</span> check(root, root);    &#125;&#125;;</code></pre><p>104.<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p><p>递归形式的DFS</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//首先想到的方法是DFS的递归写法</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calDepth</span><span class="hljs-params">(TreeNode* p, <span class="hljs-keyword">int</span> depth)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> depth;        &#125;        <span class="hljs-keyword">return</span> max(calDepth(p-&gt;left,depth+<span class="hljs-number">1</span>),calDepth(p-&gt;right,depth+<span class="hljs-number">1</span>));            &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">return</span> calDepth(root,<span class="hljs-number">0</span>);     &#125;&#125;;</code></pre><p>非递归DFS</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">stack</span>&lt; <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; &gt; st;        st.push(<span class="hljs-built_in">make_pair</span>(root,<span class="hljs-number">0</span>));        <span class="hljs-keyword">int</span> max_depth = <span class="hljs-number">0</span>;<span class="hljs-comment">//默认设置为0,根节点空</span>        <span class="hljs-keyword">while</span>(!st.empty())&#123;            <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; t = st.top();            st.pop();            TreeNode* p = t.first;            <span class="hljs-keyword">int</span> depth = t.second;            <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;                max_depth = max(max_depth, depth+<span class="hljs-number">1</span>);                st.push(<span class="hljs-built_in">make_pair</span>(p-&gt;right, depth+<span class="hljs-number">1</span>));                st.push(<span class="hljs-built_in">make_pair</span>(p-&gt;left, depth+<span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-keyword">return</span> max_depth;     &#125;&#125;;</code></pre><p>BFS</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;        que.push(root);        <span class="hljs-keyword">while</span>(!que.empty())&#123;            depth ++; <span class="hljs-comment">//能进入循环说明当前队列中保存了新的一层</span>            <span class="hljs-keyword">int</span> size = que.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;                TreeNode* p = que.front();                que.pop();                <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;left);                &#125;                <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;right);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> depth;     &#125;&#125;;</code></pre><p>107.<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">二叉树的层次遍历 II</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;            que.push(root);            <span class="hljs-keyword">while</span>(!que.empty())&#123;                <span class="hljs-keyword">int</span> size = que.size();                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;                    TreeNode* p = que.front();                    que.pop();                    tmp.push_back(p-&gt;val);                    <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                        que.push(p-&gt;left);                    &#125;                    <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                        que.push(p-&gt;right);                    &#125;                &#125;                ans.push_back(tmp);            &#125;            reverse(ans.begin(),ans.end());        &#125;             <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>108.<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a> ★</p><p>有意思的题目，首先想到的分治法求解</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-comment">//分治 递归</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">buildBST</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(l==r)&#123;            TreeNode* p = <span class="hljs-keyword">new</span> TreeNode(nums[l]);            <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-keyword">if</span>(l&gt;r)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;         TreeNode* parent = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);        parent-&gt;left = buildBST(nums,l,mid<span class="hljs-number">-1</span>);        parent-&gt;right = buildBST(nums,mid+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">return</span> parent;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> buildBST(nums,<span class="hljs-number">0</span>,nums.size()<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//有没有其他写法明天再看</span></code></pre><p>110.<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a> ★</p><p>这个版本写得非常之垃圾，最初的思路留在这里，纪念一下愚蠢的思路。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHeightandCheck</span><span class="hljs-params">(TreeNode* p, <span class="hljs-keyword">bool</span> &amp;flag)</span></span>&#123;        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left_height = getHeightandCheck(p-&gt;left,flag);        <span class="hljs-keyword">int</span> right_height = getHeightandCheck(p-&gt;right,flag);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left_height-right_height)&gt;<span class="hljs-number">1</span>)&#123;            flag = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> max(left_height, right_height) + <span class="hljs-number">1</span>;    &#125;     <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-comment">//if(root == NULL)&#123;</span>        <span class="hljs-comment">//    return true;</span>        <span class="hljs-comment">//&#125; </span>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;        getHeightandCheck(root,flag);        <span class="hljs-keyword">return</span> flag;    &#125;&#125;;</code></pre><p>自顶向下分别判断每个结点的左右子树高度，但是这一方法时间复杂度为<span class="math inline">\(o(nlogn)\)</span></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* p)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> max(height(p-&gt;left),height(p-&gt;right)) + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right)                &amp;&amp; (<span class="hljs-built_in">abs</span>(height(root-&gt;left) - height(root-&gt;right)) &lt;=<span class="hljs-number">1</span> );    &#125;&#125;;</code></pre><p>111.<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></p><p>最先想到的方法是BFS，遇到的首个叶子节点（左右孩子空）的深度。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;        que.push(root);         <span class="hljs-keyword">int</span> min_depth = <span class="hljs-number">0</span>;        <span class="hljs-keyword">bool</span> flag_leaf = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">while</span>(!que.empty())&#123;            min_depth ++;            <span class="hljs-keyword">int</span> size = que.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;                TreeNode* p = que.front();                que.pop();                <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right==<span class="hljs-literal">NULL</span>)&#123;                    flag_leaf = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;<span class="hljs-comment">//这个if特殊判断当前结点是否是根结点，[1,2]的最小深度为2</span>                <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;left);                &#125;                <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;right);                &#125;            &#125;            <span class="hljs-keyword">if</span>(flag_leaf)&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> min_depth;    &#125;&#125;;</code></pre><p>这个题目还可以使用DFS（递归）的方式。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//特例，根为空</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">NULL</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//特例，仅根</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> min_depth = <span class="hljs-number">0x3f3f3f3f</span>;        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;            min_depth = min(min_depth, minDepth(root-&gt;left));        &#125;        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;            min_depth = min(min_depth, minDepth(root-&gt;right));        &#125;        <span class="hljs-keyword">return</span> min_depth + <span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><p>比较闲，再写一遍DFS的非递归方式。</p><pre><code class="hljs C++"><span class="hljs-comment">//25号再写</span></code></pre><p>112.<a href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></p><p>递归的DFS。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> sum - root-&gt;val == <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val)                 || hasPathSum(root-&gt;right, sum - root-&gt;val);    &#125;&#125;;</code></pre><p>BFS，有正负应该怎么剪枝呢？</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-built_in">queue</span>&lt; <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; &gt; que;        que.push(<span class="hljs-built_in">make_pair</span>(root,<span class="hljs-number">0</span>));        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-keyword">int</span> size = que.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;                <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; hp = que.front();                que.pop();                TreeNode* p = hp.first;                <span class="hljs-keyword">int</span> tmp_sum = hp.second + p-&gt;val;                <span class="hljs-keyword">if</span>(tmp_sum==sum &amp;&amp; p-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right==<span class="hljs-literal">NULL</span>)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;                <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;left, tmp_sum));                &#125;                <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;right, tmp_sum));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><p>257.<a href="https://leetcode-cn.com/problems/binary-tree-paths/">二叉树的所有路径</a></p><p>顺其自然DFS递归实现。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; ans;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* p, <span class="hljs-built_in">string</span> path)</span></span>&#123;        <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right==<span class="hljs-literal">NULL</span>)&#123;            ans.push_back(path + to_string(p-&gt;val));          &#125;        <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;            DFS(p-&gt;left,path + to_string(p-&gt;val) + <span class="hljs-string">&quot;-&gt;&quot;</span>);        &#125;        <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;            DFS(p-&gt;right,path + to_string(p-&gt;val) + <span class="hljs-string">&quot;-&gt;&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> ans;        &#125;        DFS(root, <span class="hljs-string">&quot;&quot;</span>);        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>559.<a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">N叉树的最大深度</a></p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        children = _children;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> size = root-&gt;children.size();        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//没有孩子结点，说明当前root是叶子结点，返回深度1</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> max_depth = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;            max_depth = max(max_depth, maxDepth(root-&gt;children[i]));        &#125;        <span class="hljs-keyword">return</span> max_depth + <span class="hljs-number">1</span>;    &#125;&#125;;</code></pre><p>690.<a href="https://leetcode-cn.com/problems/employee-importance/">员工的重要性</a></p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for Employee.</span><span class="hljs-comment">class Employee &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int id;</span><span class="hljs-comment">    int importance;</span><span class="hljs-comment">    vector&lt;int&gt; subordinates;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, Employee*&gt; mp;    <span class="hljs-comment">// bool cmp(const Employee* a, const ) //不需要排序？</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;        Employee* ee = mp[id];        <span class="hljs-keyword">int</span> ans = ee-&gt;importance;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ee-&gt;subordinates.size();i++)&#123;            ans += DFS(ee-&gt;subordinates[i]);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Employee*&gt; employees, <span class="hljs-keyword">int</span> id)</span> </span>&#123;          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;employees.size();i++)&#123;<span class="hljs-comment">//快速查询员工，原始输入并非有序</span>            mp.emplace(employees[i]-&gt;id, employees[i]);        &#125;        <span class="hljs-keyword">return</span> DFS(id);    &#125;&#125;;</code></pre><p>BFS写一遍。</p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for Employee.</span><span class="hljs-comment">class Employee &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int id;</span><span class="hljs-comment">    int importance;</span><span class="hljs-comment">    vector&lt;int&gt; subordinates;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Employee*&gt; employees, <span class="hljs-keyword">int</span> id)</span> </span>&#123;         <span class="hljs-keyword">if</span>(employees.empty())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> size = employees.size();        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, Employee*&gt; mp;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;            mp.emplace(employees[i]-&gt;id, employees[i]);        &#125;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que;        que.push(id);        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-keyword">int</span> que_size = que.size();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;que_size;i++)&#123;                <span class="hljs-keyword">int</span> e = que.front();                que.pop();                ans += mp[e]-&gt;importance;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ee : mp[e]-&gt;subordinates)&#123;                    <span class="hljs-comment">//一个员工最多有一个直系领导，不需要visitedz数组标记</span>                    que.push(ee);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>733.<a href="https://leetcode-cn.com/problems/flood-fill/">图像渲染</a></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">bool</span> visited[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>] = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; image, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> old_color, <span class="hljs-keyword">int</span> new_color)</span></span>&#123;        <span class="hljs-keyword">if</span>((<span class="hljs-number">0</span>&lt;=r &amp;&amp; r&lt;image.size()) &amp;&amp; (<span class="hljs-number">0</span>&lt;=c &amp;&amp; c&lt;image[<span class="hljs-number">0</span>].size()) &amp;&amp; !visited[r][c])&#123;            visited[r][c] = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(image[r][c]==old_color)&#123;                image[r][c] = new_color;                DFS(image, r+<span class="hljs-number">1</span>,c, old_color, new_color);                DFS(image, r<span class="hljs-number">-1</span>,c, old_color, new_color);                DFS(image, r,c+<span class="hljs-number">1</span>, old_color, new_color);                DFS(image, r,c<span class="hljs-number">-1</span>, old_color, new_color);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">floodFill</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; image, <span class="hljs-keyword">int</span> sr, <span class="hljs-keyword">int</span> sc, <span class="hljs-keyword">int</span> newColor)</span> </span>&#123;        <span class="hljs-comment">// DFS(image, sr, sc, image[sr][sc], newColor);</span>        <span class="hljs-comment">// BFS</span>        <span class="hljs-built_in">queue</span>&lt; <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; que;        que.push(<span class="hljs-built_in">make_pair</span>(sr,sc));        <span class="hljs-keyword">int</span> scolor = image[sr][sc];        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pos = que.front();            <span class="hljs-keyword">int</span> r = pos.first;            <span class="hljs-keyword">int</span> c = pos.second;            que.pop();            <span class="hljs-keyword">if</span>((<span class="hljs-number">0</span>&lt;=r &amp;&amp; r&lt;image.size()) &amp;&amp; (<span class="hljs-number">0</span>&lt;=c &amp;&amp; c&lt;image[<span class="hljs-number">0</span>].size()) &amp;&amp; !visited[r][c])&#123;                visited[r][c] = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span>(image[r][c]==scolor)&#123;                    image[r][c] = newColor;                    que.push(<span class="hljs-built_in">make_pair</span>(r+<span class="hljs-number">1</span>,c));                    que.push(<span class="hljs-built_in">make_pair</span>(r<span class="hljs-number">-1</span>,c));                    que.push(<span class="hljs-built_in">make_pair</span>(r,c+<span class="hljs-number">1</span>));                    que.push(<span class="hljs-built_in">make_pair</span>(r,c<span class="hljs-number">-1</span>));                &#125;            &#125;                    &#125;        <span class="hljs-keyword">return</span> image;    &#125;&#125;;</code></pre><p>872.<a href="https://leetcode-cn.com/problems/leaf-similar-trees/">叶子相似的树</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; leafs)</span></span>&#123;        <span class="hljs-keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)&#123;             leafs.push_back(p-&gt;val);        &#125;        <span class="hljs-keyword">if</span>(p-&gt;left)&#123;            DFS(p-&gt;left, leafs);        &#125;        <span class="hljs-keyword">if</span>(p-&gt;right)&#123;            DFS(p-&gt;right, leafs);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!root1 &amp;&amp; !root2)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>(!root1 || !root2)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; leafs1;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; leafs2;        DFS(root1,leafs1);        DFS(root2,leafs2);        <span class="hljs-comment">// if(leafs1.size()!=leafs2.size())&#123;</span>        <span class="hljs-comment">//     return false;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">// for(int i=0;i&lt;leafs1.size();i++)&#123;</span>        <span class="hljs-comment">//     if(leafs1[i]!=leafs2[i])&#123;</span>        <span class="hljs-comment">//         return false;</span>        <span class="hljs-comment">//     &#125;</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-comment">/*如果vector是内置类型的数据,如int, char等,直接用v1 == v2来判断,</span><span class="hljs-comment">          但是如果用了自定义类型的话,那么首先要实现该类型的operator==函数,</span><span class="hljs-comment">          也就是重载等于判断.</span><span class="hljs-comment">        */</span>        <span class="hljs-keyword">return</span> leafs1==leafs2;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">//官方题解速度更快欸</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; leaves)</span></span>&#123;        <span class="hljs-keyword">if</span>(!p)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归的结束条件可以学习一下</span>        <span class="hljs-keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)&#123;             leaves.push_back(p-&gt;val);        &#125;        DFS(p-&gt;left, leaves);        DFS(p-&gt;right, leaves);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; leaves1;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; leaves2;        DFS(root1,leaves1);        DFS(root2,leaves2);        <span class="hljs-keyword">return</span> leaves1==leaves2;    &#125;&#125;;</code></pre><p>897.<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">递增顺序查找树</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nodes)</span></span>&#123;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        DFS(p-&gt;left,nodes);        nodes.push_back(p-&gt;val);        DFS(p-&gt;right,nodes);    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nodes)</span></span>&#123;        <span class="hljs-keyword">if</span>(nodes.empty())<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">int</span> size = nodes.size();        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(nodes[<span class="hljs-number">0</span>]);        TreeNode* pre = root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;            TreeNode* p = <span class="hljs-keyword">new</span> TreeNode(nodes[i]);            pre-&gt;right = p;            pre = p;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nodes;        DFS(root,nodes);        <span class="hljs-keyword">return</span> buildTree(nodes);    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode专题 树</title>
    <link href="/2020/07/15/2020-08-01-%E5%8A%9B%E6%89%A3-%E6%A0%91/"/>
    <url>/2020/07/15/2020-08-01-%E5%8A%9B%E6%89%A3-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode专题-树">LeetCode专题 树</h2><p>226.<a href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></p><p>只需要遍历到每一个结点即可，然后交换左右两个孩子结点。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        &#125;        TreeNode* tmp = invertTree(root-&gt;left);        root-&gt;left = invertTree(root-&gt;right);        root-&gt;right = tmp;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p>235.<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a> ★★★</p><p>LCA最近公共祖先，有点意思，第一次写的超级垃圾的代码108ms，103.5MB。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;TreeNode*&gt;&gt; helper;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root,<span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; path,TreeNode* target)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        path.push_back(root);        <span class="hljs-keyword">if</span>(root==target)&#123;            helper.push_back(path);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;            DFS(root-&gt;left,path,target);        &#125;        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;            DFS(root-&gt;right,path,target);        &#125;       &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; path_p;        DFS(root,path_p,p);        DFS(root,path_p,q);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;helper[<span class="hljs-number">0</span>].size()&amp;&amp;j&lt;helper[<span class="hljs-number">1</span>].size())&#123;            <span class="hljs-built_in">cout</span>&lt;&lt;helper[<span class="hljs-number">0</span>][i]-&gt;val&lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt;helper[<span class="hljs-number">1</span>][j]-&gt;val&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">if</span>(helper[<span class="hljs-number">0</span>][i]==helper[<span class="hljs-number">1</span>][j])&#123;                i++,j++;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> helper[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre><ul><li><p><strong>二叉搜索树BST的性质</strong></p><ol type="a"><li>节点 N 左子树上的所有节点的值都小于等于节点 N 的值</li><li>节点 N 右子树上的所有节点的值都大于等于节点 N 的值</li><li>子树和右子树也都是 BST</li></ol></li><li><p><strong>算法</strong></p><ol type="a"><li>从根节点开始遍历树</li><li>如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 (a) 的操作</li><li>如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 (a) 的操作</li><li>如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 LCA 了</li></ol></li><li><p>在左右子树上，则root.val - p.val和root.val - q.val异号</p><p>同在左/右子树，则同号，分别递归地遍历左/右子树</p><p>该算法得到的性能是36ms，23.5MB</p></li></ul><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    TreeNode* lca = <span class="hljs-literal">NULL</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCA</span><span class="hljs-params">(TreeNode* root, TreeNode*p, TreeNode* q)</span></span>&#123;        <span class="hljs-keyword">if</span>((root-&gt;val - p-&gt;val)*(root-&gt;val - q-&gt;val) &lt;= <span class="hljs-number">0</span>)&#123;            lca = root;<span class="hljs-comment">//如果p,q分别再左右子树上，则root就是lca</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)&#123;            LCA(root-&gt;right, p, q);        &#125;<span class="hljs-keyword">else</span>&#123;            LCA(root-&gt;left, p, q);        &#125;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-comment">// 题目的意思是树不空</span>        <span class="hljs-comment">// if (!root) return nullptr;</span>        LCA(root, p, q);        <span class="hljs-keyword">return</span> lca;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">if</span>(q -&gt; val &gt; root -&gt; val &amp;&amp; p -&gt; val &gt; root -&gt; val)                <span class="hljs-keyword">return</span> lowestCommonAncestor(root -&gt; right, p, q);<span class="hljs-comment">// 都在root的右边</span>        <span class="hljs-keyword">if</span>(q -&gt; val &lt; root -&gt; val &amp;&amp; p -&gt; val &lt; root -&gt; val)                <span class="hljs-keyword">return</span> lowestCommonAncestor(root -&gt; left, p, q); <span class="hljs-comment">// 都在root的左边</span>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 若分布在root的两侧，说明root为最近公共祖先</span>    &#125;&#125;;</code></pre><ul><li><p><strong>进阶： 二叉树 - 无左小右大的性质，需要全盘搜索</strong></p><ol type="a"><li>遇到指定节点，直接返回root，无需往下搜寻。</li><li>向左右子树遍历，返回包含指定节点的子树。</li><li>若左右子树都包含指定节点，则当前root为最近公共祖先。</li></ol><p>自底向上遍历结点，一旦遇到结点等于p或者q，则将其向上传递给它的父结点。父结点会判断它的左右子树是否都包含其中一个结点，如果是，则父结点一定是这两个节点p和q的LCA，传递父结点到root。如果不是，我们向上传递其中的包含结点p或者q的子结点，或者NULL(如果子结点不包含任何一个)。该方法时间复杂度为O(N)。</p></li></ul><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!root || root == p || root == q ) <span class="hljs-keyword">return</span> root;        <span class="hljs-comment">// ↓ l(r)=NULL,左(右)子树不包含p或q;l(r)=p或q,左(右)子树包含有p或q</span>        TreeNode* l = lowestCommonAncestor(root -&gt; left, p , q);        TreeNode* r = lowestCommonAncestor(root -&gt; right, p, q);        <span class="hljs-keyword">if</span>(l &amp;&amp; r) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 如果p和q位于不同的子树,根即为LCA</span>        <span class="hljs-keyword">return</span> l ? l : r;         <span class="hljs-comment">// ↑ p和q在当前以root为根的相同的子树中(即左右子树)</span>    &#125;&#125;;</code></pre><p>404.<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和</a></p><ul><li>算法思路 对任意一个节点，它只需要做两件事； 1、判断它的左孩子是不是左叶子； 2、让它的左孩子和右孩子分别向它汇报，以该孩子为根的sumOfLeftLeaves； 最后简单相加即可，很典型的递归算法。</li></ul><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment">* Definition for a binary tree node.</span><span class="hljs-comment">* struct TreeNode &#123;</span><span class="hljs-comment">*     int val;</span><span class="hljs-comment">*     TreeNode *left;</span><span class="hljs-comment">*     TreeNode *right;</span><span class="hljs-comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">* &#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">if</span>(root-&gt;left-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right==<span class="hljs-literal">NULL</span>)&#123;                left_sum += root-&gt;left-&gt;val;<span class="hljs-comment">//root-&gt;left是左叶子结点</span>            &#125; <span class="hljs-keyword">else</span> &#123;                left_sum += sumOfLeftLeaves(root-&gt;left);            &#125;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;            left_sum += sumOfLeftLeaves(root-&gt;right);        &#125;        <span class="hljs-keyword">return</span> left_sum;    &#125;&#125;;</code></pre><p>我的想法是BFS标记左叶子，但是很慢，开销也大</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">queue</span>&lt; <span class="hljs-built_in">pair</span>&lt;TreeNode* , <span class="hljs-keyword">int</span>&gt; &gt; que;        que.push(<span class="hljs-built_in">make_pair</span>(root,<span class="hljs-number">-1</span>));<span class="hljs-comment">//0左1右，root默认为-1</span>        <span class="hljs-keyword">int</span> left_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; hp = que.front();            que.pop();            TreeNode* p = hp.first;            <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right==<span class="hljs-literal">NULL</span> &amp;&amp; hp.second==<span class="hljs-number">0</span>)&#123;                left_sum += p-&gt;val;            &#125;            <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;left,<span class="hljs-number">0</span>));            &#125;            <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;right,<span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-keyword">return</span> left_sum;    &#125;&#125;;</code></pre><p>501.<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数</a></p><p>不使用额外空间的方法（递归的隐式栈开销忽略不计），和一开始想的方式很类似，但是用递归的方式实现。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span> <span class="hljs-comment">//前序遍历(Preorder transversal),中序遍历(Inorder transversal)以及后序遍历(Postorder transversal)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        Inorder(root);        <span class="hljs-keyword">return</span> ans;    &#125;<span class="hljs-comment">// void Inorder(TreeNode* root,TreeNode*&amp; pre)引用传递</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-comment">// 这里我犯了一个错误，pre必须是全局的pre，</span>        <span class="hljs-comment">// 要按照引用传递或者设置全局变量，否则回溯的时候pre不会更新</span>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        Inorder(root-&gt;left);        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;val==pre-&gt;val)&#123;            cur_cnt ++;        &#125;<span class="hljs-keyword">else</span>&#123;            cur_cnt = <span class="hljs-number">1</span>;        &#125;                <span class="hljs-keyword">if</span>(max_cnt &lt; cur_cnt)&#123;               max_cnt = cur_cnt;            ans.clear();            ans.push_back(root-&gt;val);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max_cnt==cur_cnt)&#123;            ans.push_back(root-&gt;val);        &#125;        pre = root;        Inorder(root-&gt;right);    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;    <span class="hljs-keyword">int</span> max_cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> cur_cnt = <span class="hljs-number">1</span>;    TreeNode* pre = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//记录中序遍历过程中当前结点的前驱结点</span>&#125;;</code></pre><p>这个开销太大了，是最直接的做法，即原问题等价于求一个单调不减数列的众数。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span> <span class="hljs-comment">//前序遍历(Preorder transversal),中序遍历(Inorder transversal)以及后序遍历(Postorder transversal)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        DFS(root-&gt;left);        inorder.push_back(root-&gt;val);        DFS(root-&gt;right);    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        DFS(root);        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-keyword">int</span> max_cnt = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> size = inorder.size();        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ans;        <span class="hljs-keyword">int</span> pre_val=inorder[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;            <span class="hljs-keyword">if</span>(i&lt;size &amp;&amp; inorder[i]==inorder[i<span class="hljs-number">-1</span>])&#123;                cnt ++;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(max_cnt &lt; cnt)&#123;                    max_cnt = cnt;                    ans.clear();                    ans.push_back(inorder[i<span class="hljs-number">-1</span>]);                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max_cnt==cnt)&#123;                    ans.push_back(inorder[i<span class="hljs-number">-1</span>]);                &#125;                cnt = <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>530.<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">二叉搜索树的最小绝对差</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        getMin(root);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMin</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;        getMin(root-&gt;left);        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;val - pre-&gt;val &lt; ans)&#123;            ans = root-&gt;val - pre-&gt;val;        &#125;        pre = root;        getMin(root-&gt;right);    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-keyword">int</span> ans = INF;    TreeNode* pre = <span class="hljs-literal">NULL</span>;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; prev, <span class="hljs-keyword">int</span>&amp; res)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        dfs(root-&gt;left, prev, res);        <span class="hljs-keyword">if</span> (prev &gt;= <span class="hljs-number">0</span>) res = min(res, root-&gt;val - prev);        prev = root-&gt;val;        dfs(root-&gt;right, prev, res);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">int</span> prev = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">int</span> res = INT_MAX;        dfs(root, prev, res);        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><ul><li><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/solution/zhong-xu-bian-li-tuan-mie-xi-lie-er-cha-sou-suo-sh/">二叉搜索树的绝杀方式</a></li></ul><p>538.<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a></p><p>aha，一次AC，核心还是"中序遍历"，只不过该问需要从最右结点开始反向中序遍历，利用BST的特性（见235.LCA）当前结点的值加上大于当前结点"右侧"结点的值（右边的一定大）。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        buildGT(root);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildGT</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        buildGT(root-&gt;right);        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span>)&#123;            root-&gt;val += pre-&gt;val;        &#125;        pre = root;        buildGT(root-&gt;left);    &#125;<span class="hljs-keyword">private</span>:    TreeNode* pre = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//记录反向中序遍历的&quot;前驱&quot;结点</span>&#125;;</code></pre><p>543.<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">二叉树的直径</a></p><p>数的直径即求两节点间最大距离，即转化可递归解决的问题：</p><p>1、不经过root，最长路径子在左子树上</p><p>2、不经过root，最长路径子在右子树上</p><p>3、经过root，最长路径为左右子树的最大高度之和。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        maxDepth(root);        <span class="hljs-keyword">return</span> max_diameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> dL = maxDepth(root-&gt;left);        <span class="hljs-keyword">int</span> dR = maxDepth(root-&gt;right);        max_diameter = max(max_diameter, dL+dR);        <span class="hljs-keyword">return</span> max(dL,dR) + <span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> max_diameter = <span class="hljs-number">0</span>;&#125;;</code></pre><p>563.<a href="https://leetcode-cn.com/problems/binary-tree-tilt/">二叉树的坡度</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTilt</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        getSum(root);        <span class="hljs-keyword">return</span> tilt;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> L = getSum(root-&gt;left);        <span class="hljs-keyword">int</span> R = getSum(root-&gt;right);        tilt += <span class="hljs-built_in">abs</span>(L - R);        <span class="hljs-keyword">return</span> L + R + root-&gt;val;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> tilt = <span class="hljs-number">0</span>;&#125;;</code></pre><p>572.<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">另一个树的子树</a> ★★★★</p><p>Donald Trump： Nobody knows SIMPLICITY better than me, noboday.</p><p>官方题解，从暴力搜索匹配到字符串匹配KMP，再到树的hash，着实厉害。</p><p>最简单的匹配方法</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* s, TreeNode* t)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//主树为空时，返回false，避免使用空指针</span>        <span class="hljs-keyword">return</span> isSame(s,t) || isSubtree(s-&gt;left,t) || isSubtree(s-&gt;right,t);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(TreeNode* s, TreeNode* t)</span></span>&#123;        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span> &amp;&amp; t==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span> || t==<span class="hljs-literal">NULL</span> || s-&gt;val!=t-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> isSame(s-&gt;left,t-&gt;left) &amp;&amp; isSame(s-&gt;right,t-&gt;right);    &#125;&#125;;</code></pre><p>589.<a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">N叉树的前序遍历</a></p><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/solution/yi-tao-quan-fa-shua-diao-nge-bian-li-shu-de-wen--3/">树的遍历合集</a></p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        children = _children;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;        traverse(root);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(Node* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;        ans.push_back(root-&gt;val);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e : root-&gt;children)&#123;            traverse(e);        &#125;    &#125;&#125;;</code></pre><p>迭代法</p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        children = _children;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-built_in">stack</span>&lt;Node*&gt; st;        <span class="hljs-comment">// if(root==NULL)return ans;</span>        st.push(root);        <span class="hljs-keyword">while</span>(!st.empty())&#123;            Node* p = st.top();            st.pop();            <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;                ans.push_back(p-&gt;val);                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=p-&gt;children.size()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;                    st.push(p-&gt;children[i]);                &#125;            &#125;          &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>590.<a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">N叉树的后序遍历</a></p><pre><code class="hljs C++"><span class="hljs-comment">/*</span><span class="hljs-comment">// Definition for a Node.</span><span class="hljs-comment">class Node &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><span class="hljs-comment">        val = _val;</span><span class="hljs-comment">        children = _children;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;        traverse(root);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(Node* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e:root-&gt;children)&#123;            traverse(e);        &#125;        ans.push_back(root-&gt;val);    &#125;&#125;;</code></pre><p>606.<a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">根据二叉树创建字符串</a></p><p>题目的意思是子节点需要用<code>()</code>来包裹。举例来说，二叉树<code>[root,left,right]</code>，则转换为<code>root(left)(right)</code>。如果只有<code>left</code>为空节点，则输出<code>root()(right)</code>；如果只有<code>right</code>为空节点则可以忽略右节点的<code>()</code>，输出为<code>root(left)</code>。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">tree2str</span><span class="hljs-params">(TreeNode* t)</span> </span>&#123;        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-built_in">string</span> ans = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-built_in">string</span> L = tree2str(t-&gt;left);        <span class="hljs-built_in">string</span> R = tree2str(t-&gt;right);        <span class="hljs-keyword">if</span>(t-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; t-&gt;right==<span class="hljs-literal">NULL</span>) &#123;            ans = to_string(t-&gt;val);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left!=<span class="hljs-literal">NULL</span> &amp;&amp; t-&gt;right==<span class="hljs-literal">NULL</span>) &#123;            ans = to_string(t-&gt;val) + <span class="hljs-string">&quot;(&quot;</span> + L + <span class="hljs-string">&quot;)&quot;</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            ans = to_string(t-&gt;val) + <span class="hljs-string">&quot;(&quot;</span> + L + <span class="hljs-string">&quot;)&quot;</span> + <span class="hljs-string">&quot;(&quot;</span> + R + <span class="hljs-string">&quot;)&quot;</span>;        &#125;         <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>617.<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a> ★★</p><p><strong>一开始没想到的是孩子为空的时候啥也不用做，直接连接即可。</strong></p><p>我们可以对这两棵树同时进行前序遍历，并将对应的节点进行合并。在遍历时，如果两棵树的当前节点均不为空，我们就将它们的值进行相加，并对它们的左孩子和右孩子进行递归合并；如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;        TreeNode* root = t1 ? t1 : t2;        <span class="hljs-keyword">if</span>(t1&amp;&amp;t2)&#123;            t1-&gt;val += t2-&gt;val;            t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);            t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p>非递归的实现：如果t1和t2非空，则将其val求和并赋值给t1，然后考虑左右孩子，（以左孩为例）如果t1左孩子为空，则将t2的左孩子作为t1的左孩子，如果t1左孩子非空，则将结点入栈/队，两者皆空则无操作（上述，右孩子同理）；如果t1为空，则返回t2（无论t2是否为空，不影响结果），否则返回t1。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;        <span class="hljs-comment">//判断t1空的情况，while循环仅执行一次</span>        TreeNode* root = t1 ? t1 : t2;                <span class="hljs-built_in">queue</span>&lt; <span class="hljs-built_in">pair</span>&lt;TreeNode*,TreeNode*&gt; &gt; que;        que.push(<span class="hljs-built_in">make_pair</span>(t1,t2));        <span class="hljs-keyword">while</span>(!que.empty()) &#123;            <span class="hljs-built_in">pair</span>&lt;TreeNode*,TreeNode*&gt; hp = que.front();            que.pop();            TreeNode* p = hp.first;            TreeNode* q = hp.second;            <span class="hljs-comment">//若t1为空，循环结束；或者p非空而q空，</span>            <span class="hljs-comment">//该情况出现在树t1的左或右孩子非空而树t2与之对应的孩子为空</span>            <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> || q==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;            p-&gt;val += q-&gt;val;            <span class="hljs-comment">//分别判断左右孩子</span>            <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span>) &#123;                p-&gt;left = q-&gt;left;            &#125; <span class="hljs-keyword">else</span> &#123;                que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;left,q-&gt;left));            &#125;            <span class="hljs-keyword">if</span>(p-&gt;right==<span class="hljs-literal">NULL</span>) &#123;                p-&gt;right = q-&gt;right;            &#125; <span class="hljs-keyword">else</span> &#123;                que.push(<span class="hljs-built_in">make_pair</span>(p-&gt;right,q-&gt;right));            &#125;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p>637.<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">二叉树的层平均值</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; ans;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;        que.push(root);        <span class="hljs-keyword">while</span>(!que.empty())&#123;            <span class="hljs-keyword">int</span> SIZE = que.size();            <span class="hljs-keyword">double</span> avg = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE;i++)&#123;                TreeNode* p = que.front();                que.pop();                <span class="hljs-comment">// if(p==NULL) continue; //非空二叉树</span>                avg += p-&gt;val;                <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;left);                &#125;                <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;                    que.push(p-&gt;right);                &#125;            &#125;            ans.push_back(avg/SIZE);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>653.<a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">两数之和 IV - 输入 BST</a></p><p>最初的想法是直接返回中序遍历结果，然后问题就转化为1.两数之和。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; in)</span></span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;        traverse(root-&gt;left,in);        in.push_back(root-&gt;val);        traverse(root-&gt;right,in);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder;        traverse(root,inorder);        <span class="hljs-keyword">int</span> SIZE = inorder.size();        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE;i++)&#123;            <span class="hljs-keyword">if</span>(mp.count(k - inorder[i])==<span class="hljs-number">1</span>)&#123;                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;            mp.emplace(inorder[i],i);        &#125;        <span class="hljs-keyword">return</span> flag;    &#125;&#125;;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        inorder(root);        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> hi = vec.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;            <span class="hljs-keyword">if</span>(vec[lo] + vec[hi] == k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vec[lo] + vec[hi] &lt; k) lo++;            <span class="hljs-keyword">else</span> hi--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> root) <span class="hljs-keyword">return</span>;        inorder(root-&gt;left);        vec.emplace_back(root-&gt;val);        inorder(root-&gt;right);    &#125;&#125;;</code></pre><p>递归，效率不高欸？？？</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(mp.count(k - root-&gt;val)==<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        mp.emplace(root-&gt;val, <span class="hljs-number">1</span>);          <span class="hljs-keyword">return</span> findTarget(root-&gt;right, k) || findTarget(root-&gt;left, k);    &#125;&#125;;</code></pre><p>669.<a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树</a></p><p>递归做法，设当前结点为root：</p><p>如果root-&gt;val小于L，则剪掉左子树和自身，递归处理右子树；如果root-&gt;val大于R，则剪掉右子树和自身，递归处理左子树；若root-&gt;val处在区间之间，则分别递归地处理左右子树。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(root-&gt;val &lt; L) &#123;                root = trimBST(root-&gt;right, L, R);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; R) &#123;                root = trimBST(root-&gt;left, L, R);            &#125; <span class="hljs-keyword">else</span> &#123;                root-&gt;left = trimBST(root-&gt;left, L, R);                root-&gt;right = trimBST(root-&gt;right, L, R);            &#125;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p>671.<a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">二叉树中第二小的节点</a></p><p>最最直接的做法就是遍历一遍，使用map存储遍历结果，然后遍历一遍map寻找最小值。</p><p>上述过程也可以使用额外的一个变量记录，遍历树寻找比root（由题意，root的值一定是最小的）值大的数中最小的一个。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span> || (root-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">NULL</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        mins = root-&gt;val;        getMin2(root);        <span class="hljs-keyword">return</span> ans ;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMin2</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;              <span class="hljs-keyword">if</span>(root-&gt;val &gt; mins)&#123;                <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">-1</span>)                    ans = root-&gt;val;                <span class="hljs-keyword">else</span>                     ans = min(ans,root-&gt;val);            &#125;            getMin2(root-&gt;left);            getMin2(root-&gt;right);        &#125;        &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> mins;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;&#125;;</code></pre><p>也可以这样做：分别求左右子树的最小值， 如果左右子树最小值都大于根节点的值取较小的值。其他情况取左右子树较大的值。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right!=<span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-comment">// 如果当前结点的孩子的值大于当前结点的值，则无需递归遍历，</span>            <span class="hljs-comment">// 因为以该孩子为根的子树最小值即为这个根</span>            <span class="hljs-keyword">int</span> l = root-&gt;left-&gt;val, r = root-&gt;right-&gt;val;            <span class="hljs-keyword">if</span>(root-&gt;val==root-&gt;left-&gt;val)&#123;<span class="hljs-comment">// 只有当孩子值与根相等时，才递归遍历</span>                l = findSecondMinimumValue(root-&gt;left);            &#125;            <span class="hljs-keyword">if</span>(root-&gt;val==root-&gt;right-&gt;val)&#123;                r = findSecondMinimumValue(root-&gt;right);            &#125;            <span class="hljs-comment">// 问题可以转化为求左右子树的最小值</span>            <span class="hljs-keyword">if</span>(l&gt;root-&gt;val &amp;&amp; r&gt;root-&gt;val) &#123;                ans = min(l,r); <span class="hljs-comment">// 如果左右子树最小值都大于根节点的值,取较小的值</span>            &#125;<span class="hljs-keyword">else</span>&#123;                ans = max(l,r); <span class="hljs-comment">// 其他情况取左右子树较大的值</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>687.<a href="https://leetcode-cn.com/problems/longest-univalue-path/">最长同值路径</a> ★★★</p><p>思路：递归的思想，对于某个根节点root，在左子树中，与左子树根节点（root-&gt;left-&gt;val）同值的最大路径长度为L（如果root-&gt;left值与其的左右孩子值都不同，则L=0），同理，右子树记作R。</p><p>类似地，如果root的值与左孩子相同，则路径长度应当为L+1，否则左孩子到root的的路径不符合要求，记作0；右子树同理，记作R+1或0。返回左右子树中的较长路径。</p><p>函数getPath返回的是单侧的最长路径，若该路径穿越根结点，则需要加上左右两条分支路径的长度，所以在递归的过程中使用单独的变量ans记录最大路径的长度（这个长度可能是不经过根结点的单侧路径，也有可能是经过根节点的双分支路径）。</p><p><strong>对于任意一个节点, 如果最长同值路径包含该节点, 那么只可能是两种情况：</strong></p><ol type="i"><li><p>其左右子树中加上该节点后所构成的同值路径中较长的那个继续向父节点回溯构成最长同值路径</p></li><li><p>左右子树加上该节点都在最长同值路径中, 构成了最终的最长同值路径 需要注意因为要求同值, 所以在判断左右子树能构成的同值路径时要加入当前节点的值作为判断依据</p></li></ol><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        getPath(root);        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPath</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">int</span> path_len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">int</span> L = getPath(root-&gt;left); <span class="hljs-comment">// 以左孩为根节点的最大路径长度</span>            <span class="hljs-keyword">int</span> R = getPath(root-&gt;right);            <span class="hljs-keyword">int</span> tmp_L = <span class="hljs-number">0</span>, tmp_R = <span class="hljs-number">0</span>; <span class="hljs-comment">// 过当前节点的路径长度，假设与孩子值不等，初始设为0</span>            <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;val == root-&gt;val)&#123;                tmp_L = L + <span class="hljs-number">1</span>;            &#125; <span class="hljs-comment">// 如果与左孩子值相同，path值为L+1</span>            <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right-&gt;val == root-&gt;val)&#123;                tmp_R += R + <span class="hljs-number">1</span>;            &#125; <span class="hljs-comment">// 如果与右孩子值相同，path值为R+1</span>            ans = max(ans, tmp_L + tmp_R); <span class="hljs-comment">// 递归过程中记录最大路径长度</span>            path_len = max(tmp_L,tmp_R);            <span class="hljs-comment">// 若同时和左右孩子值相同，返回较长的路径，继续向上遍历</span>            <span class="hljs-comment">// 如果和左（右）孩子值不等，则路径长度设置为0</span>        &#125;        <span class="hljs-keyword">return</span> path_len;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;&#125;;</code></pre><p>700.<a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        TreeNode* ans = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) &#123;                ans = searchBST(root-&gt;left, val);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) &#123;                ans = searchBST(root-&gt;right, val);            &#125; <span class="hljs-keyword">else</span> &#123;                ans = root;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>783.<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">二叉搜索树节点最小距离</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDiffInBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        traverse(root);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size()<span class="hljs-number">-1</span>;i++)&#123;            ans = min(ans, nums[i+<span class="hljs-number">1</span>] - nums[i]);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            traverse(root-&gt;left);            nums.push_back(root-&gt;val);            traverse(root-&gt;right);        &#125;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;    <span class="hljs-keyword">int</span> ans = INT_MAX;&#125;;</code></pre><p>938.<a href="https://leetcode-cn.com/problems/range-sum-of-bst/">二叉搜索树的范围和</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rangeSumBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span>(root-&gt;val &lt; L) &#123;                sum = rangeSumBST(root-&gt;right, L, R);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; R) &#123;                sum = rangeSumBST(root-&gt;left, L, R);            &#125; <span class="hljs-keyword">else</span> &#123;                sum = root-&gt;val + rangeSumBST(root-&gt;left, L, R)                         + rangeSumBST(root-&gt;right, L, R);            &#125;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;;</code></pre><p>965.<a href="https://leetcode-cn.com/problems/univalued-binary-tree/">单值二叉树</a></p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUnivalTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        val = root-&gt;val; <span class="hljs-comment">//无需验空</span>        <span class="hljs-keyword">return</span> dfs(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> (root-&gt;val==val) &amp;&amp; dfs(root-&gt;left) &amp;&amp; dfs(root-&gt;right);            &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> val;&#125;;</code></pre><p>993.<a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">二叉树的堂兄弟节点</a></p><p>遍历二叉树，分别记录 x、y 结点的深度和父亲结点。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCousins</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        dfs(root, x, y, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);        <span class="hljs-keyword">return</span> (parx!=pary &amp;&amp; dx==dy);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> d,TreeNode* par)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(root-&gt;val == x)&#123;            parx = par;            dx = d;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;val == y) &#123;            pary = par;            dy = d;        &#125;        dfs(root-&gt;left, x, y, d+<span class="hljs-number">1</span>, root);        dfs(root-&gt;right, x, y, d+<span class="hljs-number">1</span>, root);    &#125;<span class="hljs-keyword">private</span>:    TreeNode* parx = <span class="hljs-literal">nullptr</span>;    TreeNode* pary = <span class="hljs-literal">nullptr</span>;    <span class="hljs-keyword">int</span> dx=<span class="hljs-number">0</span>, dy = <span class="hljs-number">0</span>;&#125;;</code></pre><p>1022.<a href="https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/">从根到叶的二进制数之和</a> ★★☆</p><p>自上而下地遍历二叉树，遇到叶子结点则表示一个"二进制"序列的值已被计算完整，加到ans上；由于自上而下不知道序列的最高位位数，所以上层的结果递归到下一级时需要×2。类似秦九韶算法。</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * struct TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode *left;</span><span class="hljs-comment"> *     TreeNode *right;</span><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRootToLeaf</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        calculateSum(root, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> ans % M;    &#125;    <span class="hljs-comment">//由于不知道一个序列的高位位数，所以自顶向下计算数值，上一层结果×2后加上当前结点数字</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculateSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)&#123;            num = (num &lt;&lt; <span class="hljs-number">1</span>) + root-&gt;val;            <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">NULL</span>)&#123;                ans += num; <span class="hljs-comment">//叶子节点，当前路径计算结束，加上这个数字</span>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//非叶子结点继续递归，对上一层的结果×2再加上当前的数字</span>                calculateSum(root-&gt;left, num % M);                calculateSum(root-&gt;right, num % M);            &#125;            &#125;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NumPy入门笔记</title>
    <link href="/2019/10/26/2019-10-26-NumPy%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/10/26/2019-10-26-NumPy%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="numpy学习笔记">Numpy学习笔记</h1><p>序：真的是想到哪里学到哪里，学东西不要管那么多，就当是“量子波动”学习知识，总有一天会成体系。</p><p>2019年10月25日 至 2019年10月28日</p><p># define " <strong>import numpy as np</strong> "</p><hr /><h2 id="简介">简介</h2><p>​ NumPy是Python语言的一个扩充程序库。支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。Numpy内部解除了Python的PIL(全局解释器锁),运算效率极好,是大量机器学习框架的基础库!</p><p>​ NumPy 的前身 Numeric 最早是由 Jim Hugunin 与其它协作者共同开发，2005 年，Travis Oliphant 在 Numeric 中结合了另一个同性质的程序库 Numarray 的特色，并加入了其它扩展而开发了 NumPy。NumPy 为开放源代码并且由许多协作者共同维护开发。</p><hr /><hr /><h2 id="numpy-ndarray对象及常用操作">NumPy Ndarray对象及常用操作</h2><h3 id="基本属性">基本属性</h3><p>​ 这是一个N维数组对象，下标从0开始，且所有元素同类型、同内存大小，主要包含如下属性：</p><ul><li><p>ndarray.ndim</p><p>表示axes(axis复数)/dimensions 描述维度数字</p></li><li><p>ndarray.shape</p><p>返回元组，输出各个维度的大小</p><p>可以使用<code>reshape</code>函数来调整数组的形状</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])b = a.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<span class="hljs-keyword">print</span> (b)</code></pre></li><li><p>ndarray.size</p><p>返回所有元素的个数（各个维度大小的乘积）</p></li><li><p>ndarray.dtype</p><p>返回数据的类型</p><p>​ "&gt;" 若首先取高字节的数据存放在低地址，则是大端法；</p><p>​ "&lt;" 若首先取低字节的数据存放在低地址，则是小端法；</p><ul><li><strong>自定义数据类型</strong></li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npstudent = np.dtype([(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;S20&#x27;</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;i1&#x27;</span>), (<span class="hljs-string">&#x27;marks&#x27;</span>, <span class="hljs-string">&#x27;f4&#x27;</span>)]) a = np.array([(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">50</span>),(<span class="hljs-string">&#x27;xyz&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">75</span>)], dtype = student) print(a)</code></pre></li><li><p>ndarray.itemsize</p><p>返回单个元素的大小（单位字节），等价于ndarray.dtype.itemsize</p></li><li><p>ndarray.data</p><p>一般不使用，这是存放数据的区域</p></li><li><p>其他参见numpy-ref文档</p><p>NumPy数组的维数称为<strong>秩（rank）</strong>，一维数组的秩为 1，二维数组的秩为2，以此类推。</p></li></ul><p>​ 在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量(秩)，就是数组的维数。W</p><p>​ <strong>很多时候可以声明 axis，axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。</strong></p><hr /><h3 id="创建数组">创建数组</h3><ol type="1"><li>使用函数创建新数组</li></ol><p><code>np.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p><p>对应参数解释：<code>object</code>数组或者嵌套数列；<code>dtype</code>元素类型可选；<code>copy</code>对象是否复制可选；<code>order</code>创建数组的样式（C行方向、F列方向、默认A任意方向）；<code>subok</code>默认返回一个与基类同类型的数组；<code>ndim</code>指定生成数组的最小维度。</p><p>还可以使用其他函数：</p><p><a href="https://numpy.org/devdocs/reference/generated/numpy.array.html#numpy.array"><code>array</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros.html#numpy.zeros"><code>zeros</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros_like.html#numpy.zeros_like"><code>zeros_like</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ones.html#numpy.ones"><code>ones</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ones_like.html#numpy.ones_like"><code>ones_like</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.empty.html#numpy.empty"><code>empty</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.empty_like.html#numpy.empty_like"><code>empty_like</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.arange.html#numpy.arange"><code>arange</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.linspace.html#numpy.linspace"><code>linspace</code></a>, <a href="https://numpy.org/devdocs/reference/random/generated/numpy.random.RandomState.rand.html#numpy.random.RandomState.rand"><code>numpy.random.RandomState.rand</code></a>, <a href="https://numpy.org/devdocs/reference/random/generated/numpy.random.RandomState.randn.html#numpy.random.RandomState.randn"><code>numpy.random.RandomState.randn</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfunction.html#numpy.fromfunction"><code>fromfunction</code></a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfile.html#numpy.fromfile"><code>fromfile</code></a></p><ol start="2" type="1"><li>从已有对象创建新数组</li></ol><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><p>a可以接受的参数为列表、列表的元组、元组、元组的元组、元组的列表、多为数组；数据类型可选；存放方式C/F。</p><p><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></p><p>numpy.frombuffer 用于实现动态数组。numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p><p><code>buffer</code>可以是任意对象，会以流的形式读入；<code>dtype</code>返回数组的数据类型可选；<code>count</code>读取的数据数量，默认为-1，读取所有数据；<code>offset</code>读取的起始位置，默认为0。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nps =  <span class="hljs-string">&#x27;Hello World&#x27;</span>a = np.frombuffer(s, dtype =  <span class="hljs-string">&#x27;S1&#x27;</span>)<span class="hljs-keyword">print</span> (a)<span class="hljs-comment"># 输出</span><span class="hljs-comment"># [&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27; &#x27; &#x27;W&#x27; &#x27;o&#x27; &#x27;r&#x27; &#x27;l&#x27; &#x27;d&#x27;]</span></code></pre><p><code>numpy.fromiter(iterable, dtype, count=-1)</code></p><p>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</p><p><code>iterable</code>可迭代对象；<code>dtype</code>返回数组的数据类型；<code>count</code>读取的数据数量，默认为-1，读取所有数据。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment"># 使用 range 函数创建列表对象  </span>list=range(<span class="hljs-number">5</span>)it=iter(list)<span class="hljs-comment"># 使用迭代器创建 ndarray </span>x=np.fromiter(it, dtype=float)print(x)<span class="hljs-comment">#输出</span><span class="hljs-comment"># [0. 1. 2. 3. 4.]</span></code></pre><ol start="3" type="1"><li>使用数值范围创建数组</li></ol><p><code>numpy.arange(start, stop, step, dtype)</code></p><p>numpy.arange 根据 [start,stop)指定的范围，以及 step 设定的步长，生成一个 ndarray对象。</p><p><code>start</code>起始值，默认为0；<code>stop</code>终止值（不包含）；<code>step</code>步长，默认为1；<code>dtype</code>返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</p><p><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p><p>numpy.linspace 函数用于创建一个一维数组，该数组是一个<strong>等差数列</strong>构成的。</p><p><code>start</code>序列的起始值；<code>stop</code>序列的终止值，如果<code>endpoint</code>为true，该值包含于数列中；<code>num</code>要生成的等步长的样本数量，默认为50；<code>endpoint</code>该值为 ture 时，数列中中包含stop值，反之不包含，默认是True；<code>retstep</code>如果为 True 时，生成的数组中会显示间距，反之不显示；<code>dtype</code>ndarray 的数据类型。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa =np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,retstep=<span class="hljs-literal">True</span>)print(a)<span class="hljs-comment"># 拓展例子</span>b =np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>).reshape([<span class="hljs-number">10</span>,<span class="hljs-number">1</span>])print(b)<span class="hljs-comment">#输出</span><span class="hljs-comment"># (array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.]), 1.0)</span></code></pre><p><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><p>numpy.logspace 函数用于创建一个于等比数列，值得注意的是：start和stop是数列的<strong>下标值</strong>，他们的底数是base。</p><p><code>start</code>序列的起始值为：base ** start；<code>stop</code>序列的终止值为：base ** stop，如果endpoint为true，该值包含于数列中；<code>num</code> 要生成的等步长的样本数量，默认为50；<code>endpoint</code>该值为 ture 时，数列中包含stop值，反之不包含，默认是True；<code>base</code>对数 log 的底数；<code>dtype</code>ndarray 的数据类型。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa = np.logspace(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,base=<span class="hljs-number">2</span>)<span class="hljs-keyword">print</span> (a)<span class="hljs-comment"># [  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]</span></code></pre><hr /><h3 id="数据类型">数据类型</h3><table><thead><tr class="header"><th style="text-align: left;">名称</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">bool_</td><td style="text-align: center;">布尔型数据类型（True 或者 False）</td></tr><tr class="even"><td style="text-align: left;">int_</td><td style="text-align: center;">默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td></tr><tr class="odd"><td style="text-align: left;">intc</td><td style="text-align: center;">与 C 的 int 类型一样，一般是 int32 或 int 64</td></tr><tr class="even"><td style="text-align: left;">intp</td><td style="text-align: center;">用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td></tr><tr class="odd"><td style="text-align: left;">int8</td><td style="text-align: center;">字节（-128 to 127）</td></tr><tr class="even"><td style="text-align: left;">int16</td><td style="text-align: center;">整数（-32768 to 32767）</td></tr><tr class="odd"><td style="text-align: left;">int32</td><td style="text-align: center;">整数（-2147483648 to 2147483647）</td></tr><tr class="even"><td style="text-align: left;">int64</td><td style="text-align: center;">整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr class="odd"><td style="text-align: left;">uint8</td><td style="text-align: center;">无符号整数（0 to 255）</td></tr><tr class="even"><td style="text-align: left;">uint16</td><td style="text-align: center;">无符号整数（0 to 65535）</td></tr><tr class="odd"><td style="text-align: left;">uint32</td><td style="text-align: center;">无符号整数（0 to 4294967295）</td></tr><tr class="even"><td style="text-align: left;">uint64</td><td style="text-align: center;">无符号整数（0 to 18446744073709551615）</td></tr><tr class="odd"><td style="text-align: left;">float_</td><td style="text-align: center;">float64 类型的简写</td></tr><tr class="even"><td style="text-align: left;">float16</td><td style="text-align: center;">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr class="odd"><td style="text-align: left;">float32</td><td style="text-align: center;">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr class="even"><td style="text-align: left;">float64</td><td style="text-align: center;">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr class="odd"><td style="text-align: left;">complex_</td><td style="text-align: center;">complex128 类型的简写，即 128 位复数</td></tr><tr class="even"><td style="text-align: left;">complex64</td><td style="text-align: center;">复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr class="odd"><td style="text-align: left;">complex128</td><td style="text-align: center;">复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><hr /><h3 id="类型转换">类型转换</h3><ul><li><p>浮点数据转换</p><p>float64(默认)的数组转化为float32和float16的数组时，数组的长度会发生变化，分别变为原来的两倍和四倍。</p></li><li><p>整型数据转换</p><p>同上</p></li><li><p>浮点数转整数</p><p><code>numpy</code>中的数据类型转换，不能直接改原数据的dtype，只能用函数<code>astype()</code></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npb=np.array([<span class="hljs-number">1.</span>,<span class="hljs-number">2.</span>,<span class="hljs-number">3.</span>,<span class="hljs-number">4.</span>]) <span class="hljs-comment"># 默认为float64,直接改变则数组长度会变化</span>c=b.astype(int)print(c)print(c.shape)print(c.dtype)</code></pre></li></ul><hr /><h3 id="数组切片和索引">数组切片和索引</h3><p><strong>NumPy切片和普通索引</strong>，ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。ndarray 数组可以基于 0 – n 的下标进行索引，切片对象可以通过内置的 <code>slice()</code> 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。</p><pre><code class="hljs python">a = np.arange(<span class="hljs-number">10</span>) <span class="hljs-comment"># [0 1 2 3 4 5 6 7 8 9]</span>s = slice(<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>)   <span class="hljs-comment"># 从索引 2 开始到索引 7 停止，间隔为2</span><span class="hljs-keyword">print</span> (a[s])<span class="hljs-comment"># 或者</span>a = np.arange(<span class="hljs-number">10</span>)b = a[<span class="hljs-number">2</span>:<span class="hljs-number">7</span>:<span class="hljs-number">2</span>]   <span class="hljs-comment"># 从索引 2 开始到索引 7 停止（不包括7），间隔为 2</span>print(b)<span class="hljs-comment"># 输出 [2  4  6]</span></code></pre><p><strong>冒号 " : "的解释：</strong>如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引<strong>(不包括停止索引)</strong>之间的项，list[start​ : end: ​step]start:起始位置、end:结束位置、step:步长，list[::-1]用于reverse。</p><p><strong>list[-1:]和list[:-1]的区别和联系：</strong> 这里面list[-1]是最后一个元素，所以等价于 <code>list[len-1:len]</code> 和 <code>list[0:len-1]</code> <a href="https://blog.csdn.net/weixin_40576010/article/details/88426129">参考链接</a></p><p>切片还可以包括省略号 " … "，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])  <span class="hljs-keyword">print</span> (a[...,<span class="hljs-number">1</span>])   <span class="hljs-comment"># 第2列元素</span><span class="hljs-keyword">print</span> (a[<span class="hljs-number">1</span>,...])   <span class="hljs-comment"># 第2行元素</span><span class="hljs-keyword">print</span> (a[...,<span class="hljs-number">1</span>:])  <span class="hljs-comment"># 第2列及剩下的所有元素</span><span class="hljs-comment"># 输出</span><span class="hljs-comment"># [2 4 5]</span><span class="hljs-comment"># [3 4 5]</span><span class="hljs-comment"># [[2 3]</span><span class="hljs-comment">#  [4 5]</span><span class="hljs-comment">#  [5 6]]</span><span class="hljs-comment"># reversed a</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(a[ : :<span class="hljs-number">-1</span>])     array([[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],        [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])  <span class="hljs-meta">&gt;&gt;&gt; </span>print(a[...,::<span class="hljs-number">-1</span>])[[<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>] [<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>] [<span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>print(a[::<span class="hljs-number">-1</span>,::<span class="hljs-number">-1</span>])[[<span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>] [<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>] [<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>]]</code></pre><p><strong>NumPy 高级索引</strong>，NumPy 比一般的 Python 序列提供更多的索引方式。除了之前看到的用整数和切片的索引外，数组可以由<strong>整数数组索引（花式索引）、布尔索引</strong>（对应下面三段代码）。（花式索引？）</p><p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],  [<span class="hljs-number">5</span>,  <span class="hljs-number">6</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>x[x&gt;<span class="hljs-number">3</span>]array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<span class="hljs-comment"># 以下实例使用了 ~（取补运算符）来过滤 NaN</span><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([np.nan, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, np.nan, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (a[~np.isnan(a)])[<span class="hljs-number">1.</span> <span class="hljs-number">2.</span> <span class="hljs-number">3.</span> <span class="hljs-number">4.</span> <span class="hljs-number">5.</span>]<span class="hljs-comment"># 还有a[np.iscomplex(a)]等</span></code></pre><p>花式索引指的是<strong>利用整数数组进行索引</strong>。花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。<strong>花式索引跟切片不一样，它总是将数据复制到新数组中。</strong></p><pre><code class="hljs python"><span class="hljs-comment"># 获取数组中(0,0)，(1,1)和(2,0)位置处的元素</span><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],  [<span class="hljs-number">5</span>,  <span class="hljs-number">6</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>y = x[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]] <span class="hljs-comment"># 二维数组的索引</span><span class="hljs-meta">&gt;&gt;&gt; </span>yarray([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<span class="hljs-comment">#</span><span class="hljs-meta">&gt;&gt;&gt; </span>x=np.arange(<span class="hljs-number">32</span>).reshape((<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>xarray([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],       [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>],       [<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>],       [<span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>x[[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>]]array([[<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [<span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>]])<span class="hljs-comment"># 传入多个索引数组（要使用np.ix_）</span><span class="hljs-meta">&gt;&gt;&gt; </span>x[np.ix_([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])]array([[ <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],       [<span class="hljs-number">20</span>, <span class="hljs-number">23</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>],       [<span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">11</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]])</code></pre><p>寻找数组中的最大值和最小值索引可使用np.argmax(arr.axis = 0/1) , np.argmin(arr, axis = 0/1)不写axis则返回整个数组的最大值的索引（1个），0轴为列方向，1轴为行方向。</p><ul><li>生成随机数（ <a href="https://segmentfault.com/a/1190000016097466">链接</a> ）</li></ul><hr /><h3 id="数组广播">数组广播</h3><p>NumPy广播(Broadcast)，广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在shape前面加 1 补齐维度。（3,4）+（3,）补齐（1,3）</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。（x*y，y的维度与x中的子维度相同则可以运算）</li></ul><hr /><h3 id="迭代数组">迭代数组</h3><p>参考链接：<a href="https://numpy.org/devdocs/reference/generated/numpy.nditer.html?highlight=nditer#numpy.nditer" class="uri">https://numpy.org/devdocs/reference/generated/numpy.nditer.html?highlight=nditer#numpy.nditer</a></p><p>NumPy 迭代数组，NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式，迭代器最基本的任务的可以完成对数组元素的访问。</p><p><code>np.nditer(op, flags=['multi_index'], op_flags=['readwrite'])</code></p><p><code>op</code> ndarray 或者是序列；<code>flags</code> 可选项，字符串序列,用于控制迭代器行为；<code>op_flags</code> 可选项，字符串列表,可选值有 <strong>readonly, readwrite, or writeonly</strong>。</p><ul><li>数组x和x.T的存储方式是一样的，使用迭代当时输出也是一样的。</li><li>使用C（按照行输出）和F（按照列输出）迭代显式出的结果不一致。</li></ul><pre><code class="hljs python">x = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.nditer(x):<span class="hljs-meta">... </span>    print(i,end = <span class="hljs-string">&quot; &quot;</span>)...<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span></code></pre><p>nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。</p><pre><code class="hljs python">a = np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">60</span>,<span class="hljs-number">5</span>) a = a.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)  <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;原始数组是：&#x27;</span>)<span class="hljs-keyword">print</span> (a)<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> np.nditer(a, op_flags=[<span class="hljs-string">&#x27;readwrite&#x27;</span>]):     x[...]=<span class="hljs-number">2</span>*x <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;修改后的数组是：&#x27;</span>)<span class="hljs-keyword">print</span> (a)</code></pre><p>nditer类的构造器拥有flags参数，它可以接受下列值：<code>c_index</code> 跟踪C顺序索引；<code>f_index</code> 跟踪Fortran顺序索引；<code>external_loop</code>输出值时具有多个值的一维数组。</p><p>如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 （3，4），数组 b 的维度为 （4，） ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">60</span>,<span class="hljs-number">5</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>b = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>aarray([[ <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>],       [<span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>],       [<span class="hljs-number">40</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">55</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>barray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> np.nditer([a,b]):<span class="hljs-meta">... </span>    <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;%d:%d&quot;</span>  %  (x,y), end=<span class="hljs-string">&quot;, &quot;</span> )...<span class="hljs-number">0</span>:<span class="hljs-number">1</span>, <span class="hljs-number">5</span>:<span class="hljs-number">2</span>, <span class="hljs-number">10</span>:<span class="hljs-number">3</span>, <span class="hljs-number">15</span>:<span class="hljs-number">4</span>, <span class="hljs-number">20</span>:<span class="hljs-number">1</span>, <span class="hljs-number">25</span>:<span class="hljs-number">2</span>, <span class="hljs-number">30</span>:<span class="hljs-number">3</span>, <span class="hljs-number">35</span>:<span class="hljs-number">4</span>, <span class="hljs-number">40</span>:<span class="hljs-number">1</span>, <span class="hljs-number">45</span>:<span class="hljs-number">2</span>, <span class="hljs-number">50</span>:<span class="hljs-number">3</span>, <span class="hljs-number">55</span>:<span class="hljs-number">4</span>,</code></pre><hr /><h3 id="数组相关操作">数组相关操作</h3><ul><li><p>修改数组形状 <code>numpy.reshape</code> <code>numpy.ndarray.flat</code></p><p>函数返回一个数组元素迭代器</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>xarray([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>x.flat&lt;numpy.flatiter object at <span class="hljs-number">0x000001E7D0570910</span>&gt;</code></pre><p><code>numpy.ndarray.flatten</code></p><p>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.flatten()array([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])</code></pre><p><code>numpy.ravel</code></p><p>返回一个连续的被展开的数组。等同于x.reshape(-1, order=order)，修改会引起原来数组的变化。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = np.ravel(x,order= <span class="hljs-string">&quot;A&quot;</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>yarray([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>y[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><span class="hljs-meta">&gt;&gt;&gt; </span>yarray([<span class="hljs-number">100</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">4</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">6</span>,   <span class="hljs-number">7</span>,   <span class="hljs-number">8</span>,   <span class="hljs-number">9</span>,  <span class="hljs-number">10</span>,  <span class="hljs-number">11</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>xarray([[<span class="hljs-number">100</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">3</span>],       [  <span class="hljs-number">4</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">6</span>,   <span class="hljs-number">7</span>],       [  <span class="hljs-number">8</span>,   <span class="hljs-number">9</span>,  <span class="hljs-number">10</span>,  <span class="hljs-number">11</span>]])</code></pre></li><li><p>翻转数组 <code>numpy.transpose</code></p><p>用于对换数组的维度，<code>numpy.transpose(arr, axes)</code>，<code>arr</code>：要操作的数组；<code>axes</code>：整数列表，对应维度，通常所有维度都会对换。功能同arr.T，转置。</p><p><code>numpy.rollaxis</code></p><p>函数向后滚动特定的轴到一个特定位置，<code>numpy.rollaxis(arr, axis, start)</code>，<code>arr</code>：数组；<code>axis</code>：要向后滚动的轴，其它轴的相对位置不会改变；<code>start</code>：<strong>默认为零，表示完整的滚动</strong>。会滚动到特定位置。</p><p><code>numpy.swapaxes</code></p><p><code>numpy.swapaxes(arr, axis1, axis2)</code>， 函数用于交换数组的两个轴 axis1和axis2。</p></li><li><p>修改数组维度 <code>numpy.broadcast</code></p><p>用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。该函数使用两个数组作为输入参数 。</p></li></ul><p><code>numpy.broadcast_to</code></p><p>函数<code>numpy.broadcast_to(array, shape, subok)</code> 将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError 。</p><p><code>numpy.expand_dims</code></p><p>函数通过在指定位置插入新的轴来扩展数组形状 <code>numpy.expand_dims(arr, axis)</code> 。</p><p><code>numpy.squeeze</code></p><p>函数<code>numpy.squeeze(arr, axis)</code> 从给定数组的形状中删除一维（该维度数值必须为1）的条目 。</p><ul><li><p>连接数组 <code>numpy.concatenate</code></p><p>函数 <code>numpy.concatenate((a1, a2, ...), axis)</code> 用于沿指定轴连接相同形状的两个或多个数组。</p></li></ul><pre><code class="hljs shell">第一个数组：[[1 2] [3 4]]  第二个数组：  [[5 6]   [7 8]]  沿轴 0 连接两个数组：  [[1 2]   [3 4]   [5 6]   [7 8]]  沿轴 1 连接两个数组：  [[1 2 5 6]   [3 4 7 8]]</code></pre><p><code>numpy.stack</code></p><p>函数<code>numpy.stack((a1,a2,...), axis)</code> 用于沿新轴连接数组序列 。（维度会加1）</p><p><pre><code class="hljs shell">第一个数组：[[1 2]  [3 4]]  第二个数组：[[5 6] [7 8]]  沿轴 0 堆叠两个数组：  [[[1 2]    [3 4]]     [[5 6]    [7 8]]]    沿轴 1 堆叠两个数组：  [[[1 2]    [5 6]]     [[3 4]    [7 8]]]</code></pre></p><p><code>numpy.hstack</code></p><p>numpy.stack 函数的变体，它通过水平堆叠来生成数组 <code>np.hstack((a,b))</code> 。</p><p><pre><code class="hljs shell">第一个数组：[[1 2] [3 4]]  第二个数组：[[5 6] [7 8]]  水平堆叠：[[1 2 5 6] [3 4 7 8]]</code></pre></p><p><code>numpy.vstack</code></p><p><pre><code class="hljs shell">第一个数组：  [[1 2]   [3 4]] 第二个数组：  [[5 6]   [7 8]]竖直堆叠：  [[1 2]   [3 4]   [5 6]   [7 8]]</code></pre></p><ul><li><p>分割数组 <code>numpy.split</code></p><p>函数<code>numpy.split(ary, indices_or_sections, axis)</code> 沿特定的轴将数组分割为子数组 。<code>ary</code>：被分割的数组<code>indices_or_sections</code>：如果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）<code>axis</code>：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分。</p><p>For example, <code>[2, 3]</code> would, for <code>axis=0</code>, result in ary[:2]、ary[2:3]、ary[3:]。</p><p><code>numpy.hsplit</code></p><pre><code class="hljs shell">原array：[[4. 7. 6. 3. 2. 6.] [6. 3. 6. 7. 9. 7.]]np.hsplit(harr, 3)拆分后：[array([[4., 7.],       [6., 3.]]), array([[6., 3.],       [6., 7.]]), array([[2., 6.],       [9., 7.]])]</code></pre><p><code>numpy.vsplit</code></p><pre><code class="hljs shell">第一个数组：[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11] [12 13 14 15]]np.vsplit(a,2)竖直分割：[array([[0, 1, 2, 3],       [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],       [12, 13, 14, 15]])]</code></pre></li><li><p>数组元素的添加与删除 <code>numpy.resize</code></p><p>函数 <code>numpy.resize(arr, shape)</code> 返回指定大小的新数组。<strong>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</strong></p><p><code>numpy.append</code></p><p>函数<code>numpy.append(arr, values, axis=None)</code> 在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 输入数组的维度必须匹配否则将生成ValueError。</p><p><code>arr</code>：输入数组；<code>values</code>：要向<code>arr</code>添加的值，需要和<code>arr</code>形状相同（除了要添加的轴）；<code>axis</code>：默认为 None。<strong>当axis无定义时，是横向加成，返回总是为一维数组！</strong>当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</p><p><strong>append 函数返回的始终是一个一维数组。</strong></p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<span class="hljs-keyword">print</span> (np.append(a, [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]))<span class="hljs-keyword">print</span> (np.append(a, [[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]],axis = <span class="hljs-number">0</span>))<span class="hljs-keyword">print</span> (np.append(a, [[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]],axis = <span class="hljs-number">1</span>))第一个数组：[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]]向数组添加元素：[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]沿轴 <span class="hljs-number">0</span> 添加元素：[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>] [<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]]沿轴 <span class="hljs-number">1</span> 添加元素：[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span>] [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]]</code></pre><p><code>numpy.insert</code></p><p>函数<code>numpy.insert(arr, obj, values, axis)</code> 在给定索引之前，沿给定轴在输入数组中插入值。 如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p><p><code>arr</code>：输入数组；<code>obj</code>：在其之前插入值的索引；<code>values</code>：要插入的值；<code>axis</code>：沿着它插入的轴，如果未提供，则输入数组会被展开。该操作会广播值数组来配输入数组。</p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<span class="hljs-keyword">print</span> (a)<span class="hljs-keyword">print</span> (np.insert(a,<span class="hljs-number">3</span>,[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]))<span class="hljs-keyword">print</span> (np.insert(a,<span class="hljs-number">1</span>,[<span class="hljs-number">11</span>],axis = <span class="hljs-number">0</span>))<span class="hljs-keyword">print</span> (np.insert(a,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,axis = <span class="hljs-number">1</span>))第一个数组：[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span>] [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]]未传递 Axis 参数。 在插入之前输入数组会被展开。[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>]传递了 Axis 参数。 会广播值数组来配输入数组。沿轴 <span class="hljs-number">0</span> 广播：[[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>] [<span class="hljs-number">11</span> <span class="hljs-number">11</span>] [ <span class="hljs-number">3</span>  <span class="hljs-number">4</span>] [ <span class="hljs-number">5</span>  <span class="hljs-number">6</span>]]沿轴 <span class="hljs-number">1</span> 广播：[[ <span class="hljs-number">1</span> <span class="hljs-number">11</span>  <span class="hljs-number">2</span>] [ <span class="hljs-number">3</span> <span class="hljs-number">11</span>  <span class="hljs-number">4</span>] [ <span class="hljs-number">5</span> <span class="hljs-number">11</span>  <span class="hljs-number">6</span>]]</code></pre><p><code>numpy.delete</code></p><p>函数<code>Numpy.delete(arr, obj, axis)</code> 返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p><p><code>arr</code>：输入数组；<code>obj</code>：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组；<code>axis</code>：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开。</p><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-keyword">print</span> (a)<span class="hljs-keyword">print</span> (np.delete(a,<span class="hljs-number">5</span>))<span class="hljs-keyword">print</span> (np.delete(a,<span class="hljs-number">1</span>,axis = <span class="hljs-number">0</span>))<span class="hljs-keyword">print</span> (np.delete(a,<span class="hljs-number">1</span>,axis = <span class="hljs-number">1</span>))a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>])<span class="hljs-keyword">print</span> (np.delete(a, np.s_[::<span class="hljs-number">2</span>])) <span class="hljs-comment"># np.s_[::2] = slice(none,none,2)</span>第一个数组：[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]  <span class="hljs-comment"># 第一行</span> [ <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]  <span class="hljs-comment"># 第二行</span> [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]未传递 Axis 参数。 在删除之前输入数组会被展开。[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]删除第二行：[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>], [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]]删除第二列：[[ <span class="hljs-number">0</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>] [ <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>] [ <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]包含从数组中删除的替代值的切片：[ <span class="hljs-number">2</span>  <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">8</span> <span class="hljs-number">10</span>]</code></pre><p><code>numpy.unique</code></p><p>函数<code>numpy.unique(arr, return_index, return_inverse, return_counts)</code> 用于去除数组中的重复元素。</p><p><code>arr</code>：输入数组，如果不是一维数组则会展开；<code>return_index</code>：如果为<code>true</code>，返回新列表元素在旧列表中的位置（下标），并以列表形式存储；<code>return_inverse</code>：如果为<code>true</code>，返回旧列表元素在新列表中的位置（下标），并以列表形式存储；<code>return_counts</code>：如果为<code>true</code>，返回去重数组中的元素在原数组中的出现次数。</p><pre><code class="hljs python">a = np.array([<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>])<span class="hljs-keyword">print</span> (a)第一个数组：[<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span>]u,indices = np.unique(a, return_index = <span class="hljs-literal">True</span>)print(u)<span class="hljs-keyword">print</span> (indices)第一个数组的去重值：[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]去重数组的索引数组：[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]u,indices = np.unique(a,return_inverse = <span class="hljs-literal">True</span>)<span class="hljs-keyword">print</span> (u)<span class="hljs-keyword">print</span> (indices)<span class="hljs-keyword">print</span> (u[indices])去重数组的下标：[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]下标为：[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span>]使用下标重构原数组：[<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span>]u,indices = np.unique(a,return_counts = <span class="hljs-literal">True</span>)<span class="hljs-keyword">print</span> (u)<span class="hljs-keyword">print</span> (indices)返回去重元素的重复数量：[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>][<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]</code></pre></li></ul><hr /><h3 id="位运算">位运算</h3><p><code>bitwise_and</code> 对数组元素执行位与操作 <code>bitwise_or</code> 对数组元素执行位或操作 <code>invert</code> 按位取反 <code>left_shift</code> 向左移动二进制表示的位 <code>right_shift</code> 向右移动二进制表示的位</p><p><strong>注：也可以使用 “&amp;”、 “~”、 “|” 和 “^” 等操作符进行计算。</strong></p><hr /><h3 id="字符串数组">字符串数组</h3><p>NumPy 字符串函数，字符数组类（numpy.char）中定义了一些函数，这些函数用于对 dtype 为 numpy.string_ 或 numpy.unicode_ 的数组执行向量化字符串操作，它们基于 Python 内置库中的标准字符串函数。</p><p><code>numpy.char.add()</code> 依次对两个数组的元素进行字符串连接 。</p><p><code>numpy.char.multiply()</code> 对字符串执行多重连接。</p><pre><code class="hljs python">np.char.multiply(<span class="hljs-string">&#x27;geek-docs &#x27;</span>,<span class="hljs-number">3</span>) <span class="hljs-comment"># geek-docs geek-docs geek-docs</span></code></pre><p><code>numpy.char.center()</code> 用于将字符串居中，并使用指定字符在左侧和右侧进行填充。</p><p><code>numpy.char.capitalize()</code> 将字符串的第一个字母转换为大写 。</p><p><code>numpy.char.title()</code> 将字符串的每个单词的第一个字母转换为大写 。</p><p><code>numpy.char.lower()</code> 对数组的每个元素转换为小写。它对每个元素调用 str.lower 。</p><p><code>numpy.char.upper()</code> 对数组的每个元素转换为大写。它对每个元素调用 str.upper 。</p><p><code>numpy.char.split()</code> 指定分隔符对字符串进行分割，并返回数组。默认情况下，分隔符为空格。</p><p><code>numpy.char.splitlines()</code> 以换行符作为分隔符来分割字符串，并返回数组。</p><p><code>numpy.char.strip()</code> 用于移除开头或结尾处的特定字符。</p><p><code>numpy.char.join()</code> 通过指定分隔符来连接数组中的元素或字符串 。</p><p><code>numpy.char.replace()</code> 函数使用新字符串替换字符串中的所有子字符串。</p><p><code>numpy.char.encode()</code> 对数组中的每个元素调用 str.encode 函数。 默认编码是'utf-8'，可以使用标准 Python 库中的编解码器。</p><p><code>numpy.char.decode()</code> 函数对编码的元素进行 str.decode() 解码。</p><pre><code class="hljs python">a = np.char.encode(<span class="hljs-string">&#x27;geek-docs&#x27;</span>, <span class="hljs-string">&#x27;cp500&#x27;</span>)print(a)  <span class="hljs-comment"># b&#x27;\x87\x85\x85\x92`\x84\x96\x83\xa2&#x27;</span>print(np.char.decode(a, <span class="hljs-string">&#x27;cp500&#x27;</span>)) <span class="hljs-comment"># geek-docs</span></code></pre><hr /><h3 id="数学函数与计算">数学函数与计算</h3><ul><li><p><strong>三角函数</strong></p><p><code>cos</code> <code>cosh</code> <code>sin</code> <code>sinh</code> <code>tan</code> <code>tanh</code> （ 一般三角函数和<a href="https://baike.baidu.com/item/%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0/8704306?fr=aladdin">双曲函数</a> ）</p><p><code>arccos</code> <code>arccosh</code> <code>arcsin</code> <code>arcsinh</code> <code>arctan</code> <code>arctanh</code> （反三角函数）</p></li></ul><pre><code class="hljs python">cos = np.cos(a*np.pi/<span class="hljs-number">180</span>)inv = np.arccos(cos)np.degrees(inv)(弧度转化为度数)</code></pre><ul><li><p><strong>四舍五入函数</strong></p><p><code>numpy.around(array,decimals)</code></p><p>decimals默认为0，n表示保留到小数点后n位，-n表示保留到小数点前n位置。</p></li><li><p><strong>向上、下取整</strong></p><p><code>numpy.ceil()</code> <code>numpy.floor()</code></p></li><li><p><strong>算数函数</strong></p><p><code>add()</code> <code>subtract()</code> <code>multiply()</code> <code>divide()</code> 加减乘除</p><p><code>numpy.reciprocal()</code> 函数返回参数逐元素的倒数</p><p><code>numpy.power()</code> 第一个输入数组中的元素作为底数，第二个输入为幂</p><p><code>numpy.mod()</code> 求余，函数 <code>numpy.remainder()</code> 也产生相同的结果。</p></li><li><p><strong>统计函数</strong></p><p><strong>(不使用axis参数则返回所有元素的最大、最小值)</strong></p><p><code>numpy.amin(arr, axis)</code> 用于计算数组中的元素沿指定轴的最小值。</p><p><code>numpy.amax(arr, axis)</code> 用于计算数组中的元素沿指定轴的最大值。</p><p><code>numpy.ptp(arr, axis)</code> 计算数组中元素最大值与最小值的差（最大值 – 最小值）</p><p><code>numpy.percentile(a, q, axis,keepdims=false)</code></p><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。</p><p>a是输入数组，q是计算的百分位数，axis为轴向，keepdims为true保持原形状。</p><p><code>numpy.median()</code> 函数用于计算数组 a 中元素的中位数（中值）</p><p><code>numpy.mean()</code></p><p>函数返回数组中元素的算术平均值。</p><p>如果提供了轴，则沿其计算。算术平均值是沿轴的元素的总和除以元素的数量。</p><p><code>numpy.average(arr, axis, weights, returned)</code></p><p>函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。 该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。 如果 <code>returned</code> 参数设为 true，则返回 (average, sum_of_weights) 。</p><p><code>numpy.std(a, axis=None, dtype=None)</code></p><p>标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。</p><p>标准差的计算等同于 <code>std = sqrt(mean(abs(x - x.mean())**2))</code></p></li><li><p><strong>排序函数</strong></p><p><code>numpy.sort(a, axis, kind, order)</code></p><p>返回待排序数组的有序副本。<code>kind</code> 可以选择排序方法，默认quicksort，如果数组包含字段，则设置order根据字段排序。默认为升序排序降序排列（ np.sort(arr)[::-1]）。</p><pre><code class="hljs python">dt = np.dtype([(<span class="hljs-string">&#x27;name&#x27;</span>,  <span class="hljs-string">&#x27;S10&#x27;</span>),(<span class="hljs-string">&#x27;age&#x27;</span>,  int)]) a = np.array([(<span class="hljs-string">&quot;raju&quot;</span>,<span class="hljs-number">21</span>),(<span class="hljs-string">&quot;anil&quot;</span>,<span class="hljs-number">25</span>),(<span class="hljs-string">&quot;ravi&quot;</span>,  <span class="hljs-number">17</span>),  (<span class="hljs-string">&quot;amar&quot;</span>,<span class="hljs-number">27</span>)], dtype = dt)  <span class="hljs-keyword">print</span> (np.sort(a, order =  <span class="hljs-string">&#x27;name&#x27;</span>))<span class="hljs-comment"># 结果</span>我们的数组是：[(<span class="hljs-string">b&#x27;raju&#x27;</span>, <span class="hljs-number">21</span>) (<span class="hljs-string">b&#x27;anil&#x27;</span>, <span class="hljs-number">25</span>) (<span class="hljs-string">b&#x27;ravi&#x27;</span>, <span class="hljs-number">17</span>) (<span class="hljs-string">b&#x27;amar&#x27;</span>, <span class="hljs-number">27</span>)]按 name 排序：[(<span class="hljs-string">b&#x27;amar&#x27;</span>, <span class="hljs-number">27</span>) (<span class="hljs-string">b&#x27;anil&#x27;</span>, <span class="hljs-number">25</span>) (<span class="hljs-string">b&#x27;raju&#x27;</span>, <span class="hljs-number">21</span>) (<span class="hljs-string">b&#x27;ravi&#x27;</span>, <span class="hljs-number">17</span>)]</code></pre><p><code>numpy.argsort()</code> 函数返回的是数组值从小到大的索引值。</p><pre><code class="hljs python">x = np.array([<span class="hljs-number">3</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>])y = np.argsort(x)x[y]我们的数组是：[<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>]对 x 调用 argsort() 函数，返回所以：[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>]以排序后的索引，顺序重构原数组：[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]</code></pre><p><code>numpy.lexsort()</code> 用于对多个序列进行排序，返回其索引。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><p>小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p><pre><code class="hljs python">nm =  (<span class="hljs-string">&#x27;raju&#x27;</span>,<span class="hljs-string">&#x27;anil&#x27;</span>,<span class="hljs-string">&#x27;ravi&#x27;</span>,<span class="hljs-string">&#x27;amar&#x27;</span>) dv =  (<span class="hljs-string">&#x27;f.y.&#x27;</span>,  <span class="hljs-string">&#x27;s.y.&#x27;</span>,  <span class="hljs-string">&#x27;s.y.&#x27;</span>,  <span class="hljs-string">&#x27;f.y.&#x27;</span>) ind = np.lexsort((dv,nm))  <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;调用 lexsort() 函数：&#x27;</span>) <span class="hljs-keyword">print</span> (ind) <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;使用这个索引来获取排序后的数据：&#x27;</span>) <span class="hljs-keyword">print</span> ([nm[i]  +  <span class="hljs-string">&quot;, &quot;</span>  + dv[i]  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ind])调用 lexsort() 函数：[<span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span>]使用这个索引来获取排序后的数据：[<span class="hljs-string">&#x27;amar, f.y.&#x27;</span>, <span class="hljs-string">&#x27;anil, s.y.&#x27;</span>, <span class="hljs-string">&#x27;raju, f.y.&#x27;</span>, <span class="hljs-string">&#x27;ravi, s.y.&#x27;</span>]</code></pre><p><code>msort(a)</code></p><p>数组按第一个轴排序，返回排序后的数组副本，相等于 np.sort(a, axis=0)。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>np.msort(result)array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>resultarray([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">4</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">5</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>np.sort(result,axis = <span class="hljs-number">0</span>)array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]])</code></pre><p><code>sort_complex(a)</code> 对复数按照先实部后虚部的顺序进行排序。</p><p><code>partition(a, kth[, axis, kind, order])</code></p><p>指定一个数，对数组进行分区。</p><p><code>np.partition</code> 的工作流程可以看做是先对数组排序（升序），然后以索引是kth的元素为基准，将元素分成两部分，即大于该元素的放在其后面，小于该元素的放在其前面，这里有点类似于快排。常用于求一个数组的前k（k = kth+1求最小，k = kth求最大）个最值元素，时间复杂度很低 O(n) 。</p><p><a href="https://blog.csdn.net/weixin_42001089/article/details/89204112">参考链接</a></p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>result = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>,(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>resultarray([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">4</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">5</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>result1 = np.sort(result,axis=<span class="hljs-number">0</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>result1array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>],       [ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>],       [ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>result2 = np.partition(result, kth=<span class="hljs-number">1</span>, axis=<span class="hljs-number">0</span>)[:<span class="hljs-number">2</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>result2  <span class="hljs-comment"># 求每一列前k = 2小,所以参数kth = 1</span>array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>result3 = np.partition(result, kth=<span class="hljs-number">-2</span>, axis=<span class="hljs-number">1</span>)[::,<span class="hljs-number">-2</span>:]<span class="hljs-meta">&gt;&gt;&gt; </span>result3  <span class="hljs-comment"># 求每一行最大k = 2个元素，</span>array([[ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>],       [ <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>]])</code></pre><p><code>argpartition(a, kth[, axis, kind, order])</code></p><p>类似上面的函数，常用于求一个数组的前k个最值元素的索引，可以通过关键字 kind 指定算法（默认"introselect"），沿着指定轴axis对数组进行分区。(introselect参考快排过程)</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa = np.array([<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>])print(np.argpartition(a, <span class="hljs-number">4</span>)) <span class="hljs-comment">#将数组a中所有元素（包括重复元素）从小到大排列，比索引为第5的元素小的放在前面，大的放在后面（除了第五个元素，其余元素可能都是乱序的），输出新数组索引。</span>&gt;&gt; [<span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">0</span>]a[np.argpartition(a, <span class="hljs-number">4</span>)]     <span class="hljs-comment">#输出新数组索引对应的数组</span>&gt;&gt; array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])a[np.argpartition(a, <span class="hljs-number">-5</span>)[<span class="hljs-number">-5</span>:]] <span class="hljs-comment"># 输出top5</span>&gt;&gt; array([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>result3 = result[np.c_[np.arange(result.shape[<span class="hljs-number">0</span>]),np.arange(result.shape[<span class="hljs-number">0</span>])],np.argpartition(result, kth=<span class="hljs-number">-2</span>, axis=<span class="hljs-number">1</span>)[:,<span class="hljs-number">-2</span>:]]<span class="hljs-meta">&gt;&gt;&gt; </span>result3 <span class="hljs-comment"># 操作略复杂，直接partition可以得到一样的效果，两者相同</span>array([[ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>],       [ <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>]])条件筛选函数</code></pre></li><li><p>条件筛选函数</p><p><code>numpy.argmax()</code> 和 <code>numpy.argmin()</code> 返回最大值和最小值索引</p><p><code>numpy.nonzero()</code> 返回非0值索引</p><pre><code class="hljs python"> <span class="hljs-comment"># 对应两个两个维度的坐标我们的数组是：</span>[[<span class="hljs-number">30</span> <span class="hljs-number">40</span>  <span class="hljs-number">0</span>] [ <span class="hljs-number">0</span> <span class="hljs-number">20</span> <span class="hljs-number">10</span>] [<span class="hljs-number">50</span>  <span class="hljs-number">0</span> <span class="hljs-number">60</span>]]调用 nonzero() 函数：(array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], dtype=int64), array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>], dtype=int64)) <span class="hljs-comment"># 对应两个两个维度的坐标</span></code></pre><p><code>numpy.where()</code> 根据条件返回符合的元素的索引</p><pre><code class="hljs python">x = np.arange(<span class="hljs-number">9.</span>).reshape(<span class="hljs-number">3</span>,  <span class="hljs-number">3</span>)  y = np.where(x &gt;  <span class="hljs-number">3</span>)  x[y] <span class="hljs-comment"># 根据索引求原来的元素</span>我们的数组是：[[<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">2.</span>] [<span class="hljs-number">3.</span> <span class="hljs-number">4.</span> <span class="hljs-number">5.</span>] [<span class="hljs-number">6.</span> <span class="hljs-number">7.</span> <span class="hljs-number">8.</span>]]大于 <span class="hljs-number">3</span> 的元素的索引：(array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]), array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])) <span class="hljs-comment"># y是元组</span>使用这些索引来获取满足条件的元素：[<span class="hljs-number">4.</span> <span class="hljs-number">5.</span> <span class="hljs-number">6.</span> <span class="hljs-number">7.</span> <span class="hljs-number">8.</span>]</code></pre><p><code>numpy.extract()</code> 也是返回一定满足一定条件的元素。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>arrarray([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],       [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>condition = np.mod(arr, <span class="hljs-number">3</span>)==<span class="hljs-number">0</span><span class="hljs-meta">&gt;&gt;&gt; </span>conditionarray([[ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>],       [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>],       [<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>np.extract(condition, arr)array([<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])<span class="hljs-comment"># condition是布尔型的，等价于array[condition]</span></code></pre></li><li><p><strong>字节交换</strong></p><p><code>numpy.ndarray.byteswap()</code> 大小端的转化，参数为True</p></li><li><p><strong>NumPy 副本和视图</strong></p><p><code>np.ndarray.view()</code> 创建一个新的数组对象，该方法创建的新数组的维数改变不会更改原始数据的维数。修改元素会改变原始值。</p><p>但是， 使用切片创建视图修改数据<strong>会影响到</strong>原始数组 。</p><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">12</span>)arra=arr[<span class="hljs-number">3</span>:]b=arr[<span class="hljs-number">3</span>:]a[<span class="hljs-number">1</span>]=<span class="hljs-number">123</span>b[<span class="hljs-number">2</span>]=<span class="hljs-number">234</span>arrid(a),id(b),id(arr[<span class="hljs-number">3</span>:])我们的数组：[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]创建切片：[  <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span> <span class="hljs-number">123</span> <span class="hljs-number">234</span>   <span class="hljs-number">6</span>   <span class="hljs-number">7</span>   <span class="hljs-number">8</span>   <span class="hljs-number">9</span>  <span class="hljs-number">10</span>  <span class="hljs-number">11</span>]<span class="hljs-number">2142679040208</span> <span class="hljs-number">2142679040288</span> <span class="hljs-number">2142816278048</span><span class="hljs-comment"># 变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。</span></code></pre><p><code>np.ndarray.copy()</code> 创建一个副本，对副本数据进行修改，不会影响原始数据，物理内存不在一个位置。</p><p><strong>无复制： </strong> <strong>简单的赋值</strong> 不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p></li></ul><hr /><h2 id="矩阵">矩阵</h2><h3 id="简介-1">简介</h3><p>NumPy 矩阵库(Matrix)，NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。一个 m x n 的矩阵是一个由m行(row)n列（column）元素排列成的矩形阵列。</p><h3 id="相关函数">相关函数</h3><ul><li><p>创建矩阵</p><p><code>numpy.matlib.empty(shape, dtype, order)</code> 创建矩阵，填充伪随机数（通常非常小）。</p><p><code>numpy.matlib.zeros()</code></p><p><code>numpy.matlib.ones()</code></p><p><code>numpy.matlib.eye(n, M,k, dtype)</code> 函数返回一个矩阵，对角线元素为 1，其他位置为零。创建一个n*M的矩阵，为对角线索引。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy.matlib<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (np.matlib.eye(n =  <span class="hljs-number">3</span>, M =  <span class="hljs-number">4</span>, k =  <span class="hljs-number">0</span>, dtype =  float))[[<span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (np.matlib.eye(n =  <span class="hljs-number">3</span>, M =  <span class="hljs-number">4</span>, k =  <span class="hljs-number">1</span>, dtype =  float))[[<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (np.matlib.eye(n =  <span class="hljs-number">3</span>, M =  <span class="hljs-number">4</span>, k =  <span class="hljs-number">-1</span>, dtype =  float))[[<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>] [<span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">0.</span> <span class="hljs-number">0.</span>]]</code></pre><p><code>numpy.matlib.identity()</code> 创建单位矩阵</p><p><code>numpy.matlib.rand()</code> 创建一个矩阵，用[0,1)之间伪随机数填充。</p><p>可以使用 <code>np.asmatrix()</code> 和 <code>np.asarray()</code> 互相转化。</p></li><li><p>矩阵运算</p><p><code>numpy.dot()</code> 两个数组的点积，即元素对应相乘。</p><p>对于两个一维数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和。</p><pre><code class="hljs python">dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。numpy.dot(a, b, out=<span class="hljs-literal">None</span>)</code></pre><p><code>numpy.vdot()</code> 两个向量的点积。</p><p>函数是两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开，计算之后得到的是一个标量值。、</p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])b = np.array([[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">14</span>]])<span class="hljs-comment"># vdot 将数组展开计算内积</span><span class="hljs-keyword">print</span> (np.vdot(a,b)) <span class="hljs-comment"># 130</span></code></pre><p><code>numpy.inner()</code> 两个数组的内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>np.inner(np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]),np.array([<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]))<span class="hljs-number">17</span>  <span class="hljs-comment"># 一维数组</span><span class="hljs-meta">&gt;&gt;&gt; </span>np.inner(np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]),np.array([[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]))array([[<span class="hljs-number">17</span>, <span class="hljs-number">23</span>],       [<span class="hljs-number">39</span>, <span class="hljs-number">53</span>]]) <span class="hljs-comment"># 多维数组</span></code></pre><p><code>numpy.matmul()</code> 两个数组的矩阵积。</p><p>虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。对于二维数组，它就是矩阵乘法：</p><pre><code class="hljs python">a = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]] b = [[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]] <span class="hljs-keyword">print</span> (np.matmul(a,b))[[<span class="hljs-number">4</span>  <span class="hljs-number">1</span>] [<span class="hljs-number">2</span>  <span class="hljs-number">2</span>]]<span class="hljs-comment"># 二维</span>a = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]] b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] <span class="hljs-keyword">print</span> (np.matmul(a,b))<span class="hljs-keyword">print</span> (np.matmul(b,a))[<span class="hljs-number">7</span>  <span class="hljs-number">10</span>] [<span class="hljs-number">5</span>  <span class="hljs-number">11</span>]<span class="hljs-comment"># 三维</span>a = np.arange(<span class="hljs-number">8</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) b = np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">print</span> (np.matmul(a,b))[[[ <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]  [ <span class="hljs-number">6</span> <span class="hljs-number">11</span>]] [[<span class="hljs-number">10</span> <span class="hljs-number">19</span>]  [<span class="hljs-number">14</span> <span class="hljs-number">27</span>]]]</code></pre><p><code>numpy.linalg.det()</code> 数组的行列式。</p><p><code>numpy.linalg.solve()</code> 求解线性矩阵方程。AX = B或者X = A^(-1)B</p><p><code>numpy.linalg.inv()</code> 计算矩阵的乘法逆矩阵。</p></li></ul><hr /><h2 id="其他">其他</h2><h3 id="io及磁盘存储">IO及磁盘存储</h3><p>​ Numpy可以读写磁盘上的文本数据或二进制数据，NumPy 为 ndarray 对象引入了一个简单的文件格式(.npy)。npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p><p><code>numpy.save() 和 numpy.load()</code></p><p>函数 <code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code> 可以存储数组为".npy"格式。</p><p><code>numpy.savez(file, *args, **kwds)</code></p><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])b = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.1</span>)c = np.sin(b)<span class="hljs-comment"># c 使用了关键字参数 sin_array</span>np.savez(<span class="hljs-string">&quot;geek-docs.npz&quot;</span>, a, b, sin_array = c)r = np.load(<span class="hljs-string">&quot;geek-docs.npz&quot;</span>)print(r.files) <span class="hljs-comment"># 查看各个数组名称</span>print(r[<span class="hljs-string">&quot;arr_0&quot;</span>]) <span class="hljs-comment"># 数组 a</span>print(r[<span class="hljs-string">&quot;arr_1&quot;</span>]) <span class="hljs-comment"># 数组 b</span>print(r[<span class="hljs-string">&quot;sin_array&quot;</span>]) <span class="hljs-comment"># 数组 c</span><span class="hljs-comment"># 输出</span>[<span class="hljs-string">&#x27;sin_array&#x27;</span>, <span class="hljs-string">&#x27;arr_0&#x27;</span>, <span class="hljs-string">&#x27;arr_1&#x27;</span>][[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]][<span class="hljs-number">0.</span>  <span class="hljs-number">0.1</span> <span class="hljs-number">0.2</span> <span class="hljs-number">0.3</span> <span class="hljs-number">0.4</span> <span class="hljs-number">0.5</span> <span class="hljs-number">0.6</span> <span class="hljs-number">0.7</span> <span class="hljs-number">0.8</span> <span class="hljs-number">0.9</span>][<span class="hljs-number">0.</span>         <span class="hljs-number">0.09983342</span> <span class="hljs-number">0.19866933</span> <span class="hljs-number">0.29552021</span> <span class="hljs-number">0.38941834</span> <span class="hljs-number">0.47942554</span> <span class="hljs-number">0.56464247</span> <span class="hljs-number">0.64421769</span> <span class="hljs-number">0.71735609</span> <span class="hljs-number">0.78332691</span>]</code></pre><p><code>numpy.savetxt(FILENAME, a, fmt="%d", delimiter=",")</code></p><p><code>numpy.loadtxt(FILENAME, dtype=int, delimiter=' ')</code></p><p>以简单的文本文件格式(.txt)存储数据， 参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</p><pre><code class="hljs python">a=np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0.5</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>)np.savetxt(<span class="hljs-string">&quot;out.txt&quot;</span>,a,fmt=<span class="hljs-string">&quot;%d&quot;</span>,delimiter=<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment"># 改为保存为整数，以逗号分隔</span>b = np.loadtxt(<span class="hljs-string">&quot;out.txt&quot;</span>,delimiter=<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment"># load 时也要指定为逗号分隔</span>print(b)<span class="hljs-comment"># 输出</span>[[<span class="hljs-number">0.</span> <span class="hljs-number">0.</span> <span class="hljs-number">1.</span> <span class="hljs-number">1.</span> <span class="hljs-number">2.</span>] [<span class="hljs-number">2.</span> <span class="hljs-number">3.</span> <span class="hljs-number">3.</span> <span class="hljs-number">4.</span> <span class="hljs-number">4.</span>] [<span class="hljs-number">5.</span> <span class="hljs-number">5.</span> <span class="hljs-number">6.</span> <span class="hljs-number">6.</span> <span class="hljs-number">7.</span>] [<span class="hljs-number">7.</span> <span class="hljs-number">8.</span> <span class="hljs-number">8.</span> <span class="hljs-number">9.</span> <span class="hljs-number">9.</span>]]</code></pre><hr /><h3 id="matplotlib">Matplotlib</h3><p><a href="https://liam.page/2014/09/11/matplotlib-tutorial-zh-cn/">学习链接1</a></p><ul><li><p>中文显示 <a href="https://blog.csdn.net/skyli114/article/details/77508247">参考链接</a></p><p>Matplotlib 默认情况不支持中文，我们可以使用以下简单的方法来解决 ：</p><pre><code class="hljs awk">zhfont = matplotlib.font_manager.FontProperties(fname=<span class="hljs-string">r&quot;c:\windows\fonts\simsun.ttc&quot;</span>)</code></pre><p>然后可以设置参数： fontproperties=zhfont`</p><p>或者修改全局字体： <code>plt.rcParams['font.family']=['FontName']</code></p></li><li><p>线形 <a href="https://github.com/rougier/matplotlib-tutorial#quick-references">链接</a></p><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>'-'</code></td><td style="text-align: center;">实线样式</td></tr><tr class="even"><td style="text-align: center;"><code>'--'</code></td><td style="text-align: center;">短横线样式</td></tr><tr class="odd"><td style="text-align: center;"><code>'-.'</code></td><td style="text-align: center;">点划线样式</td></tr><tr class="even"><td style="text-align: center;"><code>':'</code></td><td style="text-align: center;">虚线样式</td></tr><tr class="odd"><td style="text-align: center;"><code>'.'</code></td><td style="text-align: center;">点标记</td></tr><tr class="even"><td style="text-align: center;"><code>','</code></td><td style="text-align: center;">像素标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'o'</code></td><td style="text-align: center;">圆标记</td></tr><tr class="even"><td style="text-align: center;"><code>'v'</code></td><td style="text-align: center;">倒三角标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'^'</code></td><td style="text-align: center;">正三角标记</td></tr><tr class="even"><td style="text-align: center;"><code>'&lt;'</code></td><td style="text-align: center;">左三角标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'&gt;'</code></td><td style="text-align: center;">右三角标记</td></tr><tr class="even"><td style="text-align: center;"><code>'1'</code></td><td style="text-align: center;">下箭头标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'2'</code></td><td style="text-align: center;">上箭头标记</td></tr><tr class="even"><td style="text-align: center;"><code>'3'</code></td><td style="text-align: center;">左箭头标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'4'</code></td><td style="text-align: center;">右箭头标记</td></tr><tr class="even"><td style="text-align: center;"><code>'s'</code></td><td style="text-align: center;">正方形标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'p'</code></td><td style="text-align: center;">五边形标记</td></tr><tr class="even"><td style="text-align: center;"><code>'*'</code></td><td style="text-align: center;">星形标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'h'</code></td><td style="text-align: center;">六边形标记 1</td></tr><tr class="even"><td style="text-align: center;"><code>'H'</code></td><td style="text-align: center;">六边形标记 2</td></tr><tr class="odd"><td style="text-align: center;"><code>'+'</code></td><td style="text-align: center;">加号标记</td></tr><tr class="even"><td style="text-align: center;"><code>'x'</code></td><td style="text-align: center;">X 标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'D'</code></td><td style="text-align: center;">菱形标记</td></tr><tr class="even"><td style="text-align: center;"><code>'d'</code></td><td style="text-align: center;">窄菱形标记</td></tr><tr class="odd"><td style="text-align: center;"><code>'|'</code></td><td style="text-align: center;">竖直线标记</td></tr><tr class="even"><td style="text-align: center;"><code>'_'</code></td><td style="text-align: center;">水平线标记</td></tr></tbody></table></li><li><p>颜色</p><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: center;">颜色</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>'b'</code></td><td style="text-align: center;">蓝色</td></tr><tr class="even"><td style="text-align: center;"><code>'g'</code></td><td style="text-align: center;">绿色</td></tr><tr class="odd"><td style="text-align: center;"><code>'r'</code></td><td style="text-align: center;">红色</td></tr><tr class="even"><td style="text-align: center;"><code>'c'</code></td><td style="text-align: center;">青色</td></tr><tr class="odd"><td style="text-align: center;"><code>'m'</code></td><td style="text-align: center;">品红色</td></tr><tr class="even"><td style="text-align: center;"><code>'y'</code></td><td style="text-align: center;">黄色</td></tr><tr class="odd"><td style="text-align: center;"><code>'k'</code></td><td style="text-align: center;">黑色</td></tr><tr class="even"><td style="text-align: center;"><code>'w'</code></td><td style="text-align: center;">白色</td></tr></tbody></table></li><li><p>绘制子图</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <span class="hljs-comment"># 计算正弦和余弦曲线上的点的 x 和 y 坐标 </span>x = np.arange(<span class="hljs-number">0</span>,  <span class="hljs-number">3</span>  * np.pi,  <span class="hljs-number">0.1</span>) y_sin = np.sin(x) y_cos = np.cos(x)  <span class="hljs-comment"># 建立 subplot 网格，高为 2，宽为 1  </span><span class="hljs-comment"># 激活第一个 subplot</span>plt.subplot(<span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>)  <span class="hljs-comment"># 绘制第一个图像 </span>plt.plot(x, y_sin) plt.title(<span class="hljs-string">&#x27;Sine&#x27;</span>)  <span class="hljs-comment"># 将第二个 subplot 激活，并绘制第二个图像</span>plt.subplot(<span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>) plt.plot(x, y_cos) plt.title(<span class="hljs-string">&#x27;Cosine&#x27;</span>)  <span class="hljs-comment"># 展示图像</span>plt.show()</code></pre></li></ul><hr /><h3 id="结构化数组">结构化数组</h3><pre><code class="hljs python"><span class="hljs-comment"># numpy基本类型</span>bytes                 b1int                   i1,i2,i4,i8unsigned ints         u1,u2,u4,u8floats                f2,f4,f8complex               c8,c16fixed length strings a&lt;n&gt;</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npstructured = np.array([(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>+<span class="hljs-number">2j</span>),                        (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Second&#x27;</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">2</span><span class="hljs-number">-2j</span>),                       (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Third&#x27;</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>+<span class="hljs-number">3j</span>)],                      dtype=[(<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;i2&#x27;</span>), (<span class="hljs-string">&#x27;position&#x27;</span>,<span class="hljs-string">&#x27;a6&#x27;</span>),                              (<span class="hljs-string">&#x27;value&#x27;</span>,<span class="hljs-string">&#x27;f4&#x27;</span>), (<span class="hljs-string">&#x27;complex&#x27;</span>, <span class="hljs-string">&#x27;c8&#x27;</span>)])<span class="hljs-comment"># 或者</span>structured = np.array([(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;First&#x27;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>+<span class="hljs-number">2j</span>),                        (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Second&#x27;</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">2</span><span class="hljs-number">-2j</span>),                       (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Third&#x27;</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>+<span class="hljs-number">3j</span>)],                       dtype=(<span class="hljs-string">&#x27;i2, a6, f4, c8&#x27;</span>))<span class="hljs-comment">#这里再单独指定字段名称</span>structured.dtype.names = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;order&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;complex&#x27;</span>)print(structured[<span class="hljs-string">&#x27;position&#x27;</span>])<span class="hljs-comment"># 指定字段名，否则自动分配f0,f1,f2</span></code></pre><hr /><ol type="1"><li><p>单元素元组表示（num,）括号内应当加上逗号，否则按照数值处理</p></li><li><p><code>*args, **kwargs</code> 这两个是python中的可变参数。<code>*args</code>表示任何多个无名参数，它是一个tuple；<code>**kwargs</code> 表示关键字参数，它是一个dict。并且同时使用<code>*args</code>和<code>**kwargs</code> 时，必须<code>*args</code>参数列要在<code>**kwargs</code>前。</p><p><a href="https://blog.csdn.net/yjk13703623757/article/details/76521420">参考链接</a></p></li><li><p>参考资料：<a href="https://numpy.org/devdocs/user/quickstart.html#" class="uri">https://numpy.org/devdocs/user/quickstart.html#</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门</title>
    <link href="/2019/10/16/2019-10-16-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <url>/2019/10/16/2019-10-16-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习入门">深度学习入门</h1><p>开始时间：2019年09月17日</p><hr /><h2 id="感知机">感知机</h2><ul><li><p><strong>感知机（perceptron）</strong>接收多个输入信号，输出一个信号。学习是确定合适的参数的过程，而人要做的是思考感知机的构造（模型），并把训练数据交给计算机。</p></li><li><p><span class="math inline">\(y=\left\{\begin{array}{ll}{0} &amp; {\left(b+w_{1} x_{1}+w_{2} x_{2} \leqslant 0\right)} \\ {1} &amp; {\left(b+w_{1} x_{1}+w_{2} x_{2}&gt;0\right)}\end{array}\right.\)</span> ，此处，<span class="math inline">\(b\)</span> 称为偏置，<span class="math inline">\(w_1\)</span> 和 <span class="math inline">\(w_2\)</span> 称为权重。<span class="math inline">\(w_1\)</span> 和 <span class="math inline">\(w_2\)</span> 是控制输入信号的重要性的参数，而偏置是调整神经元被激活的容易程度（输出信号为1的程度）的参数。</p></li><li><p>感知机的<strong>局限性</strong>就在于它只能表示由一条直线分割的空间。由曲线分割而成的空间称为非线性空间，由直线分割而成的空间称为线性空间。e.g. 单层感知机无法表示异或门，但可以叠加层后表示，见下图，而与门，或门个与非门皆可以使用单层感知机实现。</p><figure><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-09-18_16-01-17.png" alt="利用与门，或门个与非门实现异或逻辑" /><figcaption aria-hidden="true">利用与门，或门个与非门实现异或逻辑</figcaption></figure></li></ul><hr /><h2 id="神经网络及其学习方式">神经网络及其学习方式</h2><p>一般由输入层、中间层（隐藏层）、输出层构成，与感知机的主要区别在激活函数。</p><ul><li><p><strong>激活函数</strong></p><p>就是在人工神经网络上运行的函数，负责将神经元的输入映射到输出端。激活函数不可以使用线性函数，线性函数的问题在于，不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络”。</p><p>实际上，用作激活函数的函数最好具有<strong>关于原点对称</strong>的性质。</p><ul><li><strong>阶跃函数：</strong>以阈值为界，一旦输入超过阈值，就切换输出。</li><li><strong>Sigmoid函数：</strong><span class="math inline">\(h(x) = \frac{1}{1+exp(-x)}\)</span> 。</li><li><strong>ReLU函数：</strong><span class="math inline">\(h(x)=\left\{\begin{array}{ll}{x} &amp; {(x&gt;0)} \\ {0} &amp; {(x \leqslant 0)}\end{array}\right.\)</span> ，全称线性整流函数（Rectified Linear Unit）。</li></ul></li><li><p><strong>符号</strong>解释：<span class="math inline">\(w_{12}^{(1)}\)</span> <span class="math inline">\(a_1^{(2)}\)</span> 如下图</p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-09-19_15-51-22.png" /></p></li><li><p><strong>输出层函数</strong></p><p>输出层的激活函数，用 <span class="math inline">\(\sigma()\)</span> 表示，一般地，回归问题可以使用恒等函数，二元分类问题可以使用sigmoid函数，多元分类问题可以使用<strong>Softmax函数</strong>（作用于输出层，例子见下图）。</p><ul><li><p><strong>恒等函数：</strong>会将输入原样输出</p></li><li><p><strong>Softmax函数：</strong> <span class="math inline">\(y_k = \frac{exp(a_k)}{\sum_{i=1}^{n} exp(a_i)}\)</span> ，表示假设输出层共有n个神经元，计算第k个神经元的输出 <span class="math inline">\(y_k\)</span> 。</p></li><li><p>使用python实现softmax时需要注意处理指数溢出，改进方法是在分子分母的指数上同时加/减一个常数C，C通常为输入信号最大值。</p></li><li><p>softmax函数的输出范围<span class="math inline">\((0.0, 1.0)\)</span>，输出总和为1，所以可解释为概率。</p></li><li><p>一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果。并且，即便使用softmax函数，输出值最大的神经元的位置也不会变。因此，神经网络在进行分类时，输出层的softmax函数可以省略。在实际的问题中，由于指数函数的运算需要一定的计算机运算量，因此输出层的softmax函数一般会被省略。</p><figure><img src="C:\Users\Orion_wyc\AppData\Roaming\Typora\typora-user-images\1569494022849.png" alt="1569494022849" /><figcaption aria-hidden="true">1569494022849</figcaption></figure><p>注：输入图像通过Affi ne层和ReLU层进行转换，10个输入通过Softmax层进行正规化在这个例子中，“0”的得分是5.3，这个值经过Softmax层转换为0.008（0.8%）；“2”的得分是10.1，被转换为0.991（99.1%）</p></li></ul></li><li><p><strong>输出层神经元数量：</strong>对于分类问题，输出层的神经元数量一般设定为类别的数量。</p></li><li><p><strong>前向传播（forward propagation）与反向传播（back propagation）</strong></p></li><li><p><strong>预处理（pre-processing）与数据的正规化（normalization/Feature scaling ）</strong></p><p>（应该有区别，例如将数据范围转化到[0,1]之间）、数据白化（whitening，将数据整体的分布形状均匀化的方法）、数据批处理（batch）</p></li><li><p><strong>损失函数</strong></p><p>神经网络的“学习”过程就是从训练数据中自动获得最优权重参数的过程。设立训练数据和测试数据是为了评估模型的泛化能力。</p><ul><li><p>训练过程的评价指标为<strong>损失函数</strong>，损失函数可以使用任意函数，一般采用:</p><p>① <strong>均方误差（MSE，mean-square error）</strong> <span class="math inline">\(E = \frac{1}{2}\sum_{k}{(y_k - t_k)^2}\)</span> ；</p><p>② <strong>交叉熵误差（cross entropy error）</strong> <span class="math inline">\(E = - \sum_{k}{t_k\log{(y_k[+delta])}}\)</span></p><p>（其中k表示数据维度，<span class="math inline">\(y_k\)</span> 是神经网络输出，<span class="math inline">\(t_k\)</span> 是标签值，log是以e为底的对数，delta是防止对数出现无穷大。）[P85]</p><ul><li><p><strong>均方损失：</strong> 假设误差是正态分布，适用于线性的输出(如回归问题)，特点是对于与真实结果差别越大，则惩罚力度越大，这并不适用于分类问题</p></li><li><p><strong>交叉熵损失：</strong> 假设误差是二值分布，可以视为预测概率分布和真实概率分布的相似程度。在分类问题中有良好的应用。</p></li><li><p>一般我们用预测值和实际值的平方差或者它们平方差的一半，但是通常在<strong>逻辑回归</strong>中我们不这么做，因为当我们在学习逻辑回归参数的时候，会发现我们的<strong>优化目标不是凸优化</strong>，只能找到多个局部最优值，梯度下降法很可能找不到全局最优值，虽然平方差是一个不错的损失函数，但是我们在逻辑回归模型中会定义另外一个损失函数。</p></li><li><p>我们常看到两个交叉熵损失函数对应不同的最后一层的输出。第一个对应的最后一层是 sigmoid，用于二分类问题，第二个对应的最后一层是 softmax，用于多分类问题。但是它们的本质是一样的。</p><p><span class="math inline">\(\begin{array}{c}{\operatorname{cost}\left(h_{\theta}(x), y\right)=-y_{i} \log \left(h_{\theta}(x)\right)-\left(1-y_{i}\right) \log \left(1-h_{\theta}(x)\right)} \\ {C=-\sum_{i}\left(y_{i} \log a_{i}\right)}\end{array}\)</span></p><p>sigmoid 作为最后一层输出的话，那就不能吧最后一层的输出看作成一个分布了，因为加起来不为 1。现在应该将最后一层的每个神经元看作一个分布。</p></li></ul></li></ul></li></ul><p><a href="https://blog.csdn.net/tsyccnh/article/details/79163834">交叉熵的相关推导1</a></p><p><a href="https://blog.csdn.net/xu_ampl/article/details/95179849">交叉熵推导2</a></p><p><a href="https://blog.csdn.net/lanchunhui/article/details/75433608">二项分布、最大似然、交叉熵</a></p><ul><li><p><strong>二分类、多分类与多标签的基本概念</strong></p><p><strong>二分类：</strong>表示分类任务中有两个类别，比如我们想识别一幅图片是不是猫。也就是说，训练一个分类器，输入一幅图片，用特征向量x表示，输出是不是猫，用y=0或1表示。二类分类是假设每个样本都被设置了一个且仅有一个标签 0 或者 1。</p><p><strong>多类分类(Multiclass classification):</strong> 表示分类任务中有多个类别, 比如对一堆水果图片分类, 它们可能是橘子、苹果、梨等. 多类分类是假设每个样本都被设置了一个且仅有一个标签: 一个水果可以是苹果或者梨, 但是同时不可能是两者。</p><p><strong>多标签分类(Multilabel classification):</strong> 给每个样本一系列的目标标签. 可以想象成一个数据点的各属性不是相互排斥的(一个水果既是苹果又是梨就是相互排斥的), 比如一个文档相关的话题. 一个文本可能被同时认为是宗教、政治、金融或者教育相关话题。</p><p><strong>参考交叉熵的相关推导1</strong></p><p>多类分类（单标签）时，每张图片的损失是一个交叉熵，交叉熵针对的是所有类别（所有类别概率和是1，使用softmax）。 多标签分类时，每张图片的损失是N个交叉熵之和（N等于类别数），交叉熵针对的是单个类别（单个类别概率和是1）。</p><p>链接：<a href="https://blog.csdn.net/u011734144/article/details/80915559" class="uri">https://blog.csdn.net/u011734144/article/details/80915559</a></p><p>链接：<a href="https://juejin.im/post/5b38971be51d4558b10aad26" class="uri">https://juejin.im/post/5b38971be51d4558b10aad26</a></p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-10-21_10-44-33.png" /></p></li><li><p><strong>端到端</strong></p><p>深度学习有时也称为<strong>端到端机器学习（end-to-end machine learning</strong>）。这里所说的端到端是指从一端到另一端的意思，也就是从原始数据（输入）中获得目标结果（输出）的意思。</p></li><li><p><strong>mini_batch</strong></p><p>通过抽取一部分的训练数据来学习和计算误差函数，减小计算量。编程矩阵运算，程序实现参考。[P91]</p></li><li><p>在进行神经网络的学习时，不能将识别精度作为指标。因为如果以识别精度为指标，则参数的导数在绝大多数地方都会变为0。[P93]</p></li><li><p><strong>梯度下降法</strong></p><p>设有函数 <span class="math inline">\(f(x_0,x_1)\)</span> ,像 <span class="math inline">\(\left(\frac{\partial f}{\partial x_{0}}, \frac{\partial f}{\partial x_{1}}\right)\)</span> 这样的由全部变量的偏导数汇总而成的向量称为梯度 <span class="math inline">\(\operatorname{grad} f\left(x_{0}, x_{1}, \ldots, x_{n}\right)=\left(\frac{\partial f}{\partial x_{0}}, \ldots, \frac{\partial f}{\partial x_{j}}, \ldots, \frac{\partial f}{\partial x_{n}}\right)\)</span> ，<strong>梯度法公式：</strong> <span class="math inline">\(x_{i}=x_{i}-\eta \frac{\partial f}{\partial x_{i}}\)</span> 其中 <span class="math inline">\(\eta\)</span> 称为学习率。</p><p>公式含义是在每个变量轴上减小对应变量值。梯度不一定是指向了最低处,实际上，梯度指示的方向是各点处的函数值减小最多的方向。既然在变量空间的某一点处，函数沿梯度方向具有最大的变化率，那么在优化目标函数的时候，自然是<strong>沿着负梯度方向去减小函数值</strong>，以此达到我们的优化目标。</p><ul><li>求梯度的两种方法：① 基于数值微分的方法（中心差分和前向差分，速度慢，一般不容易出错，用于比对验证结果正确性）② 解析性地求解数学式的方法（反向传播，速度快）。</li><li>导数、偏导数、梯度的定义 <a href="https://www.cnblogs.com/lingjiajun/p/9895753.html">链接</a></li></ul></li><li><p><strong>学习高原</strong></p><p>函数的<strong>极小值、最小值</strong>以及被称为<strong>鞍点（saddle point）</strong>的地方，梯度为0。极小值是局部最小值，也就是限定在某个范围内的最小值。鞍点是从某个方向上看是极大值，从另一个方向上看则是极小值的点。虽然梯度法是要寻找梯度为0的地方，但是那个地方不一定就是最小值（也有可能是极小值或者鞍点）。此外，当函数很复杂且呈扁平状时，学习可能会进入一个（几乎）平坦的地区，陷入被称为“<strong>学习高原</strong>”的无法前进的停滞期。</p></li><li><p><strong>学习率、超参数</strong></p><p>学习率这样的参数称为超参数。这是一种和神经网络的参数（权重和偏置）性质不同的参数。相对于神经网络的权重参数是通过训练数据和学习算法自动获得的，学习率这样的超参数则是人工设定的。一般来说，超参数需要尝试多个值，以便找到一种可以使学习顺利进行的设定。<strong>常见超参数包括：</strong> 树的数量或树的深度、矩阵分解中潜在因素的数量、学习率（多种模式）、深层神经网络隐藏层数、k均值聚类中的簇数。</p></li><li><p><strong>随机梯度下降法（stochastic gradient descent）</strong></p><p>对随机选择的数据进行的梯度下降法，结合mini_batch计算损失函数并利用梯度下降法求解参数。</p></li><li><p><strong>epoch</strong></p><p>epoch是一个单位。一个epoch表示学习中所有训练数据均被使用过一次时的更新次数。比如，对于10000笔训练数据，用大小为100笔数据的mini-batch进行学习时，重复随机梯度下降法100次，所有的训练数据就都被“看过”了A 。此时，100次就是一个epoch。</p><p>一般做法是事先<strong>将所有训练数据随机打乱</strong>，然后按指定的批次大小，按序生成mini-batch。这样每个mini-batch均有一个索引号，比如可以是0, 1, 2, . . . , 99，然后用索引号可以遍历所有的mini-batch。遍历一次所有数据，就称为一个epoch。</p></li><li><p><strong>过拟合（overfitting）与欠拟合（underfitting）</strong></p><ul><li><p><strong>欠拟合问题</strong>，根本的原因是特征维度过少，导致拟合的函数无法满足训练集，误差较大。</p><p>解决方法</p><pre><code class="hljs text">增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间;尝试非线性模型，比如核SVM 、决策树、DNN等模型;如果有正则项可以较小正则项参数 $\lambda$;Boosting ,Boosting 往往会有较小的 Bias，比如 Gradient Boosting 等.</code></pre></li><li><p><strong>过拟合问题</strong>，根本的原因则是特征维度过多，导致拟合的函数完美的经过训练集，但是对新数据的预测结果则较差。</p><p>解决方法</p><pre><code class="hljs text">交叉检验，通过交叉检验得到较优的模型参数;特征选择，减少特征数或使用较少的特征组合，对于按区间离散化的特征，增大划分的区间;正则化，常用的有 L1、L2 正则。而且 L1正则还可以自动进行特征选择;如果有正则项则可以考虑增大正则项参数 lambda;增加训练数据可以有限的避免过拟合;Bagging ,将多个弱学习器Bagging 一下效果会好很多，比如随机森林等.</code></pre></li></ul></li></ul><hr /><h2 id="误差反向传播法">误差反向传播法</h2><p>一个能够高效计算权重参数的梯度的方法。BP算法是“误差反向传播”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来训练人工神经网络的常见方法。该方法对网络中所有权重计算损失函数的梯度。反向传播计算导数的原理是<strong>链式法则</strong>。</p><ul><li><p><strong>简单加法层和乘法层</strong></p><p>反向传播时，加法节点直接传递上层导数，乘法节点需要交换输入作为系数与导数相乘。（三个呢？）</p></li><li><p><strong>激活函数层</strong></p><ul><li><p><strong>ReLU层</strong></p><p>对激活函数 <span class="math inline">\(h(x)=\left\{\begin{array}{ll}{x} &amp; {(x&gt;0)} \\ {0} &amp; {(x \leqslant 0)}\end{array}\right.\)</span> <span class="math inline">\({求偏导} \Longrightarrow\)</span> <span class="math inline">\(\frac{\partial y}{\partial x}=\left\{\begin{array}{ll}{1} &amp; {(x&gt;0)} \\ {0} &amp; {(x \leqslant 0)}\end{array}\right.\)</span> ，易知，如果正向传播时的输入x大于0，则反向传播会将上游的值原封不动地传给下游。如果正向传播时的x小于等于0，则反向传播中传给下游的信号将停在此处。（类比开关）</p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-09-25_15-41-45.png" /></p></li><li><p><strong>Sigmoid层</strong></p><p>激活函数 <span class="math inline">\(h(x) = \frac{1}{1+exp(-x)}\)</span> 的反向传播如下图</p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-09-25_16-33-50.png" /></p><p>相比ReLU，不仅包含加法和乘法层，还需要计算指数exp()和除法“/”，最后反向传播得到的偏导数可以整理如下：<span class="math inline">\(\begin{aligned} \frac{\partial L}{\partial y} y^{2} \exp (-x) &amp;=\frac{\partial L}{\partial y} \frac{1}{(1+\exp (-x))^{2}} \exp (-x) \\ &amp;=\frac{\partial L}{\partial y} \frac{1}{1+\exp (-x)} \frac{\exp (-x)}{1+\exp (-x)} \\ &amp;=\frac{\partial L}{\partial y} y(1-y) \end{aligned}\)</span> .</p><p>易知，正向传播的结果y可以保存，而后用于计算反向传播时的偏导数。</p></li></ul></li><li><p><strong>Affine/Softmax层</strong></p><ul><li><p><strong>Affine层</strong></p><p>$  $ 分别是形状为(2,)、(2, 3)、(3,)的多维数组，所以，神经元的加权和可以用 <span class="math inline">\(Y = np.dot(X, W) + B\)</span> 计算出来。神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换”。因此，将进行<strong>仿射变换</strong>的处理实现为“Affine层”。其反向传播（使用批处理，N个一组）的计算图如下：</p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-09-26_17-34-14.png" /></p><p>需要注意的是，正向传播时，偏置会被加到每一个数据上。因此，反向传播时，各个数据的反向传播的值需要汇总为偏置的元素，即偏置 <span class="math inline">\(\boldsymbol{B}\)</span> 需要在列方向（axis = 0）上求和。</p></li><li><p><strong>Softmax-with-Loss 层</strong></p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-09-26_18-33-06.png" /></p><p>Softmax-with-Loss = Softmax Layer + Multinomial Logistic Loss Layer（交叉熵代价函数） +</p><p>上图是该层的计算图，易知：（这张图有疑问）</p><ol type="1"><li>Softmax层将输入 <span class="math inline">\((a_1,a_2,a_3)\)</span> 正规化，输出 <span class="math inline">\((y_1,y_2,y_3)\)</span> .</li><li>Cross Entropy Error层接收Softmax的输出 <span class="math inline">\((y_1,y_2,y_3)\)</span> 和标签<span class="math inline">\((t_1,t_2,t_3)\)</span> ，从这些数据中输出损失L.</li></ol><p>推导过程：<a href="https://blog.csdn.net/yiranlun3/article/details/78632752">链接</a></p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-10-19_20-02-01.png" /></p></li></ul></li></ul><hr /><h2 id="神经网络训练技巧">神经网络训练技巧</h2><ul><li><p><strong>参数更新最优化方法</strong></p><p>总结：</p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-10-18_22-22-17.png" /></p><p><strong>最优化</strong> 是神经网络学习找到使损失函数的值尽可能小的参数的过程。</p><p>原文链接：<a href="https://blog.csdn.net/u010089444/article/details/76725843"><链接></a></p><p>参考论文：<a href="http://ruder.io/optimizing-gradient-descent/index.html"><链接></a></p><p>参考博客：<a href="http://zh.d2l.ai/chapter_optimization/rmsprop.html"><链接></a></p><ul><li><p><strong>梯度下降法</strong></p><p><span class="math inline">\(W \leftarrow W - \eta \frac{\partial{L}}{\partial{W}}\)</span> 这是SGD的数学表达，权重W可以用梯度下降的方式求得。SGD简单一如实现，但它的缺点是，如果函数的形状非均向（anisotropic），比如呈延伸状（导致导致梯度并不指向最小值的方向），搜索的路径就会非常低效。</p><p><strong>Batch Gradient Descent</strong> 在每一轮的训练过程中，Batch Gradient Descent算法用整个训练集的数据计算cost fuction的梯度，并用该梯度对模型参数进行更新。</p><p>优点：cost fuction若为凸函数，能够保证收敛到全局最优值；若为非凸函数，能够收敛到局部最优值。 缺点：由于每轮迭代都需要在整个数据集上计算一次，所以批量梯度下降可能非常慢训练数较多时，需要较大内存批量梯度下降不允许在线更新模型，例如新增实例。</p><p><strong>Stochastic Gradient Descent</strong> 和批梯度下降算法相反，Stochastic gradient descent 算法每读入一个数据，便立刻计算cost fuction的梯度来更新参数。</p><p>优点：算法收敛速度快(在Batch Gradient Descent算法中, 每轮会计算很多相似样本的梯度, 这部分是冗余的)可以在线更新有几率跳出一个比较差的局部最优而收敛到一个更好的局部最优甚至是全局最优。 缺点：容易收敛到局部最优，并且容易被困在鞍点。</p><p><strong>Mini-batch Gradient Descent</strong> mini-batch Gradient Descent的方法是在上述两个方法中取折衷, 每次从所有训练数据中取一个子集（mini-batch） 用于计算梯度：Mini-batch Gradient Descent在每轮迭代中仅仅计算一个mini-batch的梯度，不仅计算效率高，而且收敛较为稳定。该方法是目前深度学训练中的主流方法。</p><p><strong>上述三个方法面临的主要挑战</strong></p><p>选择适当的学习率α较为困难。太小的学习率会导致收敛缓慢，而学习速度太块会造成较大波动，妨碍收敛。</p><p>目前可采用的方法是在训练过程中调整学习率大小，例如模拟退火算法：预先定义一个迭代次数m，每执行完m次训练便减小学习率，或者当cost function的值低于一个阈值时减小学习率。然而迭代次数和阈值必须事先定义，因此无法适应数据集的特点。</p><p>上述方法中, 每个参数的 learning rate 都是相同的，这种做法是不合理的：如果训练数据是稀疏的，并且不同特征的出现频率差异较大，那么比较合理的做法是对于出现频率低的特征设置较大的学习速率，对于出现频率较大的特征数据设置较小的学习速率。</p><p>近期的的研究表明，深层神经网络之所以比较难训练，并不是因为容易进入local minimum。相反，由于网络结构非常复杂，在绝大多数情况下即使是 local minimum 也可以得到非常好的结果。而之所以难训练是因为学习过程容易陷入到马鞍面中，即在坡面上，一部分点是上升的，一部分点是下降的。而这种情况比较容易出现在平坦区域，在这种区域中，所有方向的梯度值都几乎是 0。</p></li><li><p><strong>Momentum</strong></p><p>意为“动量”，数学表达为 <span class="math inline">\(\nu \leftarrow \alpha \nu - \eta \frac{\partial{L}}{\partial{W}}\)</span>, <span class="math inline">\(W \leftarrow W + \nu\)</span> .</p><p>和前面的SGD一样，W表示要更新的权重参数，<span class="math inline">\(\frac{\partial{L}}{\partial{W}}\)</span>表示损失函数关于W的梯度，η表示学习率。这里新出现了一个变量<span class="math inline">\(\nu\)</span>，对应物理上的速度，超参数<span class="math inline">\(\alpha\)</span> 一般设定0.9。</p><p>SGD方法的一个缺点是其更新方向完全依赖于当前batch计算出的梯度，因而十分不稳定。Momentum算法借用了物理中的动量概念，它模拟的是物体运动时的惯性，即更新的时候在一定程度上保留之前更新的方向：Momentum算法会观察历史梯度<span class="math inline">\(v_{t-1}\)</span> ，若当前梯度的方向与历史梯度一致（表明当前样本不太可能为异常点），则会增强这个方向的梯度，若当前梯度与历史梯方向不一致，则梯度会衰减。<strong>一种形象的解释是：</strong>我们把一个球推下山，球在下坡时积聚动量，在途中变得越来越快，γ可视为空气阻力，若球的方向发生变化，则动量会衰减。</p></li><li><p><strong>AdaGrad（Adaptive Gradient）</strong></p><p>上述方法中，对于每一个参数的训练都使用了相同的学习率α。AdaGrad算法能够在训练中自动的对learning rate进行调整，对于出现频率较低参数采用较大的α更新；相反，对于出现频率较高的参数采用较小的α更新。因此，AdaGrad非常适合处理稀疏数据。<span class="math inline">\(\epsilon\)</span> 是平滑项，用于避免分母为0，一般取值1e−8。</p><p>数学表示如下：<span class="math inline">\(h \leftarrow h + \frac{\partial{L}}{\partial{W}} \bigodot \frac{\partial{L}}{\partial{W}}\)</span> , <span class="math inline">\(W \leftarrow W - \eta \frac{1}{\sqrt{h + \epsilon}} \frac{\partial {L}}{\partial{W}}\)</span> . （h初值可设为0）</p><p>简单来讲，设置全局学习率之后，每次通过，全局学习率逐参数的除以历史梯度平方和的平方根，使得每个参数的学习率不同，在某些模型上效果不错。效果是：在参数空间更为平缓的方向，会取得更大的进步（因为平缓，所以历史梯度平方和较小，对应学习下降的幅度较小）。<strong>Adagrad的缺点</strong>是在训练的中后期，分母上梯度平方的累加将会越来越大，从而梯度趋近于0，使得训练提前结束。</p></li><li><p><strong>Nesterov Momentum</strong></p><p>[空]</p></li><li><p><strong>RMSprop</strong></p><p>RMSprop是Geoff Hinton提出的一种自适应学习率方法。Adagrad会累加之前所有的梯度平方，而RMSprop仅仅是计算对应的平均值，因此可缓解Adagrad算法学习率下降较快的问题。<strong>可以看出RMSProp优化算法和AdaGrad算法唯一的不同，就在于累积平方梯度的求法不同。</strong></p><p>数学描述如下：</p><p>​ <span class="math inline">\(\boldsymbol{s}_{t} \leftarrow \gamma \boldsymbol{s}_{t-1}+(1-\gamma) \boldsymbol{g}_{t} \odot \boldsymbol{g}_{t}\)</span></p><p>​ <span class="math inline">\(\boldsymbol{x}_{t} \leftarrow \boldsymbol{x}_{t-1}-\frac{\eta}{\sqrt{\boldsymbol{s}_{t}+\epsilon}} \odot \boldsymbol{g}_{t}\)</span></p><p>(Hinton 建议 γ 为 0.9, 学习率 η 为 0.001)</p></li><li><p><strong>Adam</strong></p><p>Adam(Adaptive Moment Estimation)是另一种自适应学习率的方法。它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。Adam的优点主要在于经过偏置校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳。</p><p>数学描述如下：(稍复杂，稍后再看)</p><p><span class="math inline">\(\begin{array}{l}{m_{t}=\beta_{1} m_{t-1}+\left(1-\beta_{1}\right) g_{t}} \\ {v_{t}=\beta_{2} v_{t-1}+\left(1-\beta_{2}\right) g_{t}^{2}} \end{array}\)</span> , $</p><span class="math display">\[\begin{array}{l}{\hat{m}_{t}=\frac{m_{t}}{1-\beta_{1}^{t}}} \\ {\hat{v}_{t}=\frac{v_{t}}{1-\beta_{2}^{t}}}\end{array}\]</span><p>$ , $</p><span class="math display">\[\begin{array}{c} {\Theta_{t+1}=\Theta_{t}-\frac{\alpha}{\sqrt{\hat{v}_{t}}+\epsilon} \hat{m}_{t}}\end{array}\]</span><p>$</p><p>建议 <span class="math inline">\(\beta_1 ＝ 0.9，\beta_2 ＝ 0.999，\epsilon ＝ 10e−8\)</span>;</p><p>实践表明，Adam 比其他适应性学习方法效果要好。</p></li></ul></li><li><p><strong>权重初始化(weight initialization)</strong></p><ul><li><p><strong>梯度消失问题和梯度爆炸问题</strong></p><p><strong>梯度消失（gradient vanishing problem）：</strong>在神经网络中，当前面隐藏层的学习速率低于后面隐藏层的学习速率，即随着隐藏层数目的增加，分类准确率反而下降了。这种现象叫做消失的梯度问题。</p><p><strong>梯度爆炸（gradient exploding problem）：</strong>在深层网络或递归神经网络中，误差梯度在更新中累积得到一个非常大的梯度，这样的梯度会大幅度更新网络参数，进而导致网络不稳定。在极端情况下，权重的值变得特别大，以至于结果会溢出（NaN值，无穷与非数值）。当梯度爆炸发生时，网络层之间反复乘以大于1.0的梯度值使得梯度值成倍增长。</p></li><li><p><strong>随机产生权重</strong></p><p>权重不可以设置成一样的值。BP过程会导致所有权重进行相同的更新（值相同，且对称），无论网络训练多少轮，对于每一层中的各个神经元，权重w都是相同的，无法学习（提取）到不同的特征。所以为了防止“权重均一化”，必须随机生成初始值。</p></li><li><p><strong>Xavier初始值</strong>（['zeɪvɪr]）</p><p>论文链接：<a href="http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf"><链接></a></p><p>Xavier初始值是以激活函数是线性函数为前提而推导出来的（sigmoid 函数和 tanh 函数左右对称，且中央附近可以视作线性函数）。Xavier的论文中，为了使各层的激活值呈现出具有相同广度的分布，推导了合适的权重尺度。推导出的结论是，如果前一层的节点数为n，则初始值使用标准差为 <span class="math inline">\(\frac{1}{\sqrt n}\)</span> 的分布，其中n表示与前一层有n个节点连接 。</p></li><li><p><strong>He初始值</strong></p><p>论文链接：<a href="https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/He_Delving_Deep_into_ICCV_2015_paper.pdf"><链接></a></p><p>在ReLU网络中，假定每一层有一半的神经元被激活，另一半为0，所以，要保持variance不变，只需要在Xavier的基础上再除以2。</p></li></ul></li><li><p><strong>Batch Normalization</strong></p><p>顾名思义，Batch Normalization（BN）就是“批规范化”。Google在ICML文中描述的非常清晰，即在每次SGD时，通过mini-batch来对相应的activation做规范化操作，使得结果（输出信号各个维度）的均值为0，方差为1. 而最后的“scale and shift”操作则是为了让因训练所需而“刻意”加入的BN能够有可能还原最初的输入（即当 <span class="math inline">\(\gamma^{(k)}=\sqrt{\operatorname{Var}\left[x^{(k)}\right], \beta^{(k)}}=E\left[x^{(k)}\right]\)</span> ），从而保证整个网络的capacity。</p><ul><li><p><strong>优点：</strong> ① 可以使学习快速进行（可以增大学习率）；② 不那么依赖初始值（对于初始值不用那么神经质）；③ 抑制过拟合（降低Dropout等的必要性）。</p></li><li><p>数学表示： $</p><span class="math display">\[\begin{aligned} \mu_{B} &amp; \leftarrow \frac{1}{m} \sum_{i=1}^{m} x_{i} \\ \sigma_{B}^{2} &amp; \leftarrow \frac{1}{m} \sum_{i=1}^{m}\left(x_{i}-\mu_{B}\right)^{2} \\ \hat{x}_{i} &amp; \leftarrow \frac{x_{i}-\mu_{B}}{\sqrt{\sigma_{B}^{2}+\varepsilon}}｛此处转换为新数据B = \{ \hat{x}_{1} , \hat{x}_{2}, ... , \hat{x}_{m} \}｝ \\ y_{i} &amp; \leftarrow \gamma \hat{x}_{i}+\beta  ｛BN层会对正规化后的数据进行缩放和平移的变换｝\end{aligned}\]</span><p>$</p><p>这里对mini-batch的m个输入数据的集合<span class="math inline">\(B = \{ x_1 , x_2 , ... , x_m \}\)</span> 求均值 <span class="math inline">\(\mu_B\)</span>和方差 <span class="math inline">\(\sigma^2_B\)</span> 。然后，对输入数据进行均值为0、方差为1（合适的分布）的正规化。第3式中的 <span class="math inline">\(\epsilon\)</span> 是一个微小值（e.g.取值10e-7 等），它是为了防止出现除以0的情况。计算图如下：</p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-10-06_23-18-47.png" /></p><p><a href="https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html">Frederik Kratzert的博客</a>“Understanding the backward pass through Batch Normalization Layer”里有详细说明</p></li></ul></li><li><p><strong>正则化（Regularizer）</strong></p><ul><li><p>过拟合主要原因：模型拥有大量参数，表现力强；训练数据少</p></li><li><p><strong>权值衰减（Weight Decay）</strong>:常被使用的一种抑制过拟合的方法。该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。很多过拟合原本就是因为权重参数取值过大才发生的。数学表示如下：</p><p>原始权重更新为 <span class="math inline">\(w_i \leftarrow w_i - \eta \frac{\partial L}{\partial w_i}\)</span> ，现在在损失函数L中增加一项权值衰减项 <span class="math inline">\(\frac{\lambda}{2}W^2\)</span>（这是权重的<strong>L2范数</strong>，<strong>λ是控制正则化强度的超参数</strong>）来抑制权值变大，损失函数变为 $ L(W) = L(W) + W^2$ ，在求权重梯度的计算中，要为之前的误差反向传播法的结果加上正则化项的导数 <span class="math inline">\(\lambda W\)</span> ，权重更新为 <span class="math inline">\(w_i \leftarrow w_i - \eta \frac{\partial L}{\partial w_i} - \eta \lambda W\)</span> 。</p></li><li><p><strong>Dropout</strong></p><p>在深度学习网络的训练过程中，对于神经网络单元，按照一定的概率将其暂时从网络中丢弃。注意是暂时，对于随机梯度下降来说，由于是随机丢弃，故而每一个mini-batch都在训练不同的网络。</p><p>​</p></li></ul></li><li><p><strong>超参数与验证数据</strong></p><p>数据集分成训练数据和测试数据，训练数据用于学习，测试数据用于评估泛化能力。调整超参数时，必须使用超参数专用的确认数据，这类数据称为<strong>验证数据（validation data）</strong>。<strong>不能用测试数据评估超参数的性能。</strong></p><ul><li>超参数最优化的步骤：设定超参数范围；从设定范围中随机采样；使用选出的超参数进行训练并在验证集上测试识别精度；重复上述步骤（100次左右），根据识别进度进一步缩小超参数范围。</li><li>其他：贝叶斯最优化（论文 Practical Bayesian Optimization of Machine Learning Algorithms）</li></ul></li></ul><hr /><h2 id="卷积神经网络">卷积神经网络</h2><ul><li><p><strong>全连接层的作用</strong></p><p>全连接层（fully connected layers，FC）在整个卷积神经网络中起到“分类器”的作用。如果说卷积层、池化层和激活函数层等操作是将原始数据映射到隐层特征空间的话，全连接层则起到将学到的“分布式特征表示”映射到样本标记空间的作用。（全连接层可以转化为卷积核为1x1的卷积）</p><p>FC层的冗余的参数可保持较大的模型capacity从而保证模型表示能力的迁移。</p></li><li><p><strong>卷积层（Convolutional Layer）</strong></p><p>卷积层是全连接的一种简化形式:不全连接+参数共享，同时还保留了空间位置信息。</p><p>一般全连接层损失了数据的形状这一特征，而卷积层接受三维的数据。卷积层的输入输出又被称为<strong>输入/输出特征图</strong>。卷积运算符号为“<span class="math inline">\(\bigotimes\)</span>”，卷积运算需要有到卷积核（又称“滤波器”）。</p><ul><li>数学描述： <span class="math inline">\((f * g)(1,1)=\sum_{k=0}^{2} \sum_{h=0}^{2} f(h, k) g(1-h, 1-k)\)</span></li></ul><p><strong>一句话解释什么是卷积</strong>：一个函数（如：单位响应）在另一个函数（如：输入信号）上的<strong>加权叠加。</strong>“信号与响应的卷积”体现的是时间上的“加权求和”；“图像平滑处理的卷积”体现的是空间上的“加权求和”。 <a href="https://www.zhihu.com/question/22298352">知乎链接</a></p><ul><li><strong>填充</strong>：卷积运算会使得原来的数据形状缩小，在边界四周需要填补若干圈数据（例如0），填补的数据宽度称为<strong>幅度</strong>（padding）</li><li><strong>步幅</strong>：应用滤波器的位置间隔称为<strong>步幅</strong>（stride）</li></ul><p>假设输入大小为(H, W)，滤波器大小为(FH, FW)，输出大小为(OH, OW)，填充为P，步幅为S。此时，输出大小可通过下式进行计算：<span class="math inline">\(\begin{array}{l} OH &amp; = \frac{H + 2P - FH}{S} + 1 \\ OW &amp; = \frac{W + 2P - FW}{S} + 1 \end{array}\)</span></p><p><strong>卷积核为什么是奇数大小</strong>：保证了锚点刚好在中间；填充的像素可以平均分配在图像四周。</p><p>多维卷积：除了考虑长宽方向，还需要处理通道数，并将各通道的结果相加输出。通道数应设定为和输入数据的通道数相同的值。</p><p>把3维数据表示为多维数组时，书写顺序为（channel, height, width）。比如，通道数为C、高度为H、长度为W的数据的形状可以写成（C, H, W），滤波器同。在通道方向上也拥有多个卷积运算，数量FN，得到的特征图传到下一层就是CNN的处理流（含偏置，也使用mini-batch）。运算过程参考下图：</p><p><img src="G:\Personal%20Document\Markdown\Pictures\Snipaste_2019-10-07_19-56-03.png" /></p><p><strong>卷积层作用</strong>：</p><ol type="1"><li>提取图像的特征，并且卷积核的权重是可以学习的，由此可以猜测，在高层神经网络中，卷积操作能突破传统滤波器的限制，根据目标函数提取出想要的特征。</li><li>“局部感知，参数共享”的特点大大降低了网络参数，保证了网络的稀疏性，防止过拟合之所以可以“参数共享”，是因为样本存在局部相关的特性。</li></ol><ul><li><p><strong>主要参数</strong></p><p>CNN网络的主要参数有下面这么几个：</p><ul><li>卷积核Kernal权重（在Tensorflow中称为filter）；</li><li>填充Padding；</li><li>滑动步长Strides；</li><li>池化核Kernal（在Tensorflow中称为filter）；</li><li>通道数Channels。</li></ul></li></ul><p><font color = "red">???卷积层的反向传播</font></p></li><li><p><strong>池化层（Pooling Layer）</strong></p><p>池化是缩小高、长方向上的空间的运算。一般来说，池化的窗口大小会和步幅设定成相同的值。池化有Max池化和Average池化，相对于Max池化是从目标区域中取出最大值，Average池化则是计算目标区域的平均值。在图像识别领域，主要使用Max池化。池化层没有要训练的参数，且运算后不改变通道数。输入数据发生微小偏差时，池化仍会返回相同的结果。因此，池化对输入数据的微小偏差具有鲁棒性。</p><p><strong>池化种类</strong>：一般池化（General Pooling，最大和平均池化）、重叠池化（Overlapping Pooling，相邻池化窗口之间<strong>有重叠区域</strong>，此时一般sizeX &gt; stride）、<a href="https://blog.csdn.net/g11d111/article/details/80789538">空间金字塔池化</a>（Spatial Pyramid Pooling）</p><p><strong>池化层作用</strong>：特征不变性（feature invariant）、特征降维、在一定程度上能防止过拟合的发生 。</p></li><li><p><a href="https://blog.csdn.net/dwyane12138/article/details/78449898#commentBox">使用im2col展开优化卷积计算</a> （位置7.4.3）<a href="https://zhuanlan.zhihu.com/p/63974249">知乎链接</a></p></li><li><p><strong>常见卷积神经网络</strong></p><ol type="1"><li><p>LeNet</p><p>LeNet有几个不同点：第一个不同点在于激活函数。LeNet中使用sigmoid函数，而现在的CNN中主要使用ReLU函数。此外，原始的LeNet中使用子采样（subsampling）缩小中间数据的大小，而现在的CNN中Max池化是主流。AlexNet还使用了进行局部正规化的LRN（Local Response Normalization）层。</p></li><li><p>AlexNet</p></li><li><p>ZF</p></li><li><p>VGG</p></li><li><p>GoogLeNet</p></li><li><p>ResNet</p></li><li><p>DenseNet</p></li></ol></li></ul><p><font color = red>(!!!经典网络的论文没看)</font></p><ul><li><p>迁移学习、集成学习</p></li><li><p>组合图像和自然语言等多种信息进行的处理称为<strong>多模态处理</strong></p></li><li><p>DCGAN（Deep Convolutional Generative Adversarial Network）</p><p>技术要点是使用了Generator（生成者）和Discriminator（识别者）这两个神经网络</p></li></ul><hr /><h2 id="总结">总结</h2><ol type="1"><li>Python常用数学与图形库的使用</li><li>感知机基本概念和实现</li><li>学习了DL和ANN基本理论（层、权重、激活函数、误差函数等）</li><li>神经网络的基本训练流程、数值微分法</li><li>计算图的概念和反向传播</li><li>寻找最优权重的优化方法（Batch Normalization、SGD、Momentum、Adam等）、参数初始化以及超参数搜索</li><li>CNN卷积层、池化层，了解了LeNet、AlexNet、ResNet、DenseNet（相关论文未看）</li><li>为什么深度学习表现优异、为什么加深层能提高识别精度、为什么隐藏层很重要等问题（见笔记）</li><li>Python实现梯度下降法求最优参数、手写数字识别、超参数搜索</li></ol><hr /><h2 id="to-do">TO-DO</h2><ul class="task-list"><li><input type="checkbox" disabled="" />误差反向传播的代码值得研究研究</li><li><input type="checkbox" disabled="" />numpy和matplotlib使用方法</li><li><input type="checkbox" disabled="" />线性代数和概率论、函数求导</li><li><input type="checkbox" disabled="" />实现基于MNIST的神经网络 P73关于pickle的使用以及代码细节还未细看</li><li><input type="checkbox" disabled="" checked="" />argmax解析：<a href="https://blog.csdn.net/weixin_38145317/article/details/79650188">链接</a></li><li><input type="checkbox" disabled="" checked="" />python中类的继承、类方法、实例变量与类变量：<a href="https://www.cnblogs.com/kex1n/p/5979366.html">链接</a></li><li><input type="checkbox" disabled="" checked="" />python实现数值微分时，需要注意浮点数舍入误差，使用中间差分代替前向差分。[P95]</li><li><input type="checkbox" disabled="" />掌握python的图表绘制基本操作，散点图、三维图、梯度图，多个曲线的合并，图表标签设置、坐标轴设置</li><li><input type="checkbox" disabled="" checked="" />python实例变量和类变量辨析：<a href="http://kuanghy.github.io/2015/12/19/python-variable">链接</a></li><li><input type="checkbox" disabled="" />ILSVRC ImageNet Large Scale Visual Recognition Challenge</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法整理（更新中...）</title>
    <link href="/2019/05/21/2019-05-21-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2019/05/21/2019-05-21-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="算法整理"><font color="#0000dd">算法整理</font></h1><h2 id="基础数据结构">基础数据结构</h2><h3 id="数组">数组</h3><h3 id="链表双向链表">链表、双向链表</h3><h3 id="队列单调队列优先队列双端队列">队列、单调队列、优先队列、双端队列</h3><h3 id="栈单调栈">栈、单调栈</h3><h2 id="中级数据结构">中级数据结构</h2><h3 id="堆">堆</h3><h3 id="并查集带权并查集">并查集、带权并查集</h3><h3 id="hash表">Hash表</h3><h4 id="自然溢出">自然溢出</h4><h4 id="双hash">双Hash</h4><h2 id="高级数据结构">高级数据结构</h2><h3 id="树状数组">树状数组</h3><h3 id="线段树线段树合并">线段树、线段树合并</h3><h3 id="平衡树">平衡树</h3><h4 id="treap">Treap</h4><h4 id="splay">splay</h4><h4 id="替罪羊树">替罪羊树</h4><h3 id="块状数组块状链表">块状数组、块状链表</h3><h3 id="嵌套数据结构">嵌套数据结构</h3><h4 id="树套树">树套树</h4><h4 id="dp套dp">DP套DP</h4><h3 id="可并堆">可并堆</h3><h4 id="左偏树">左偏树</h4><h4 id="配对堆">配对堆</h4><h3 id="k-d-tree四分树">K-D Tree、四分树</h3><h2 id="可持久化数据结构">可持久化数据结构</h2><h3 id="可持久化线段树">可持久化线段树</h3><h4 id="主席树">主席树</h4><h3 id="可持久化平衡树">可持久化平衡树</h3><h3 id="可持久化并查集">可持久化并查集</h3><h3 id="可持久化块状数组">可持久化块状数组</h3><h2 id="字符串算法">字符串算法</h2><h3 id="kmp">KMP</h3><h3 id="manacher">Manacher</h3><h3 id="trie">Trie</h3><h3 id="ac自动机">AC自动机</h3><h3 id="后缀数组">后缀数组</h3><h3 id="后缀树">后缀树</h3><h3 id="后缀自动机">后缀自动机</h3><h2 id="图论算法">图论算法</h2><h3 id="图的搜索">图的搜索</h3><h4 id="bfs-dfs"><font color="#00dd00">BFS DFS</font></h4><p>基本思想：BFS使用队列，宽度优先；DFS使用递归写法or非递归(堆栈)实现，深度优先。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_V = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> V, E;<span class="hljs-keyword">int</span> G[MAX_V][MAX_V];<span class="hljs-comment">//邻接矩阵</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><span class="hljs-keyword">int</span> to, cost;Edge(<span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> cost): to(to), cost(cost) &#123;&#125;;&#125;;<span class="hljs-built_in">vector</span>&lt;Edge&gt; M[MAX_V];<span class="hljs-comment">//邻接表</span><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; P;<span class="hljs-comment">//first-to ,second-cost(unused)</span><span class="hljs-keyword">int</span> visited[MAX_V];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;G[u][v] = <span class="hljs-number">1</span>;G[v][u] = <span class="hljs-number">1</span>;M[u].push_back(Edge(v, <span class="hljs-number">0</span>));M[v].push_back(Edge(u, <span class="hljs-number">0</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//递归 邻接矩阵</span><span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;visited[s] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;<span class="hljs-keyword">if</span> ( visited[i] == <span class="hljs-number">0</span> &amp;&amp; G[s][i] != INF) &#123;DFS1(i);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//邻接矩阵</span><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;q.push(s);<span class="hljs-keyword">while</span> (!q.empty()) &#123;<span class="hljs-keyword">int</span> p = q.front();q.pop();<span class="hljs-keyword">if</span> (visited[p] == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;visited[p] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;<span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span> &amp;&amp; G[p][i] &lt; INF) &#123;q.push(i);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//递归 邻接表</span><span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;visited[s] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M[s].size(); i++) &#123;Edge e = M[s][i];<span class="hljs-keyword">if</span> ( visited[e.to] == <span class="hljs-number">0</span>) &#123;DFS1(e.to);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//邻接表</span><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;q.push(s);<span class="hljs-keyword">while</span> (!q.empty()) &#123;<span class="hljs-keyword">int</span> p = q.front();q.pop();<span class="hljs-keyword">if</span> (!visited[p]) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;visited[p] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M[p].size(); i++) &#123;Edge t = M[p][i];<span class="hljs-keyword">if</span> (!visited[t.to]) &#123;q.push(t.to);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//非递归 邻接矩阵</span><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; _s;_s.push(s);<span class="hljs-keyword">while</span> (!_s.empty()) &#123;<span class="hljs-keyword">int</span> p = _s.top();<span class="hljs-keyword">if</span> (!visited[p]) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;visited[p] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;<span class="hljs-keyword">if</span> (!visited[i] &amp;&amp; G[p][i] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// visited[i] = 1;</span><span class="hljs-comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span>_s.push(i);flag = <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;_s.pop();&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">//非递归 邻接表</span><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; _s;_s.push(s);<span class="hljs-keyword">while</span> (!_s.empty()) &#123;<span class="hljs-keyword">int</span> p = _s.top();<span class="hljs-keyword">if</span> (!visited[p]) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;visited[p] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M[p].size(); i++) &#123;Edge e = M[p][i];<span class="hljs-keyword">if</span> (!visited[e.to]) &#123;<span class="hljs-comment">// visited[i] = 1;</span><span class="hljs-comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span>_s.push(e.to);flag = <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;_s.pop();&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX_V * MAX_V, INF);<span class="hljs-built_in">cin</span> &gt;&gt; V &gt;&gt; E;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<span class="hljs-keyword">int</span> u, v, w;<span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;add_edge(u, v);&#125;<span class="hljs-keyword">int</span> st = <span class="hljs-number">1</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);DFS1(st);<span class="hljs-comment">//邻接矩阵</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);BFS1(st);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);DFS2(st);<span class="hljs-comment">//邻接表</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);BFS2(st);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);DFS3(st);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);DFS4(st);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment">8 9</span><span class="hljs-comment">1 2</span><span class="hljs-comment">1 3</span><span class="hljs-comment">2 4</span><span class="hljs-comment">2 5</span><span class="hljs-comment">4 8</span><span class="hljs-comment">5 8</span><span class="hljs-comment">3 6</span><span class="hljs-comment">3 7</span><span class="hljs-comment">6 7</span><span class="hljs-comment">*/</span></code></pre><h3 id="最短路径次短路">最短路径、次短路</h3><hr /><p>连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。 强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。 连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。 最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p><hr /><h4 id="dijkstra"><font color="#00dd00">Dijkstra</font></h4><p><strong>基本思想</strong>（邻接矩阵表述）</p><p><a href="https://blog.csdn.net/C2681595858/article/details/85687836#1_Dijkstra_3">参考资料</a></p><p>设定两个集合<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>，<span class="math inline">\(A\)</span>中存放我们已经处理过的顶点，<span class="math inline">\(B\)</span>中存放图中剩余顶点。刚开始的时候，<span class="math inline">\(A\)</span>中只有一个我们选定的起点<span class="math inline">\(v_0\)</span>，每一次从集合<span class="math inline">\(B\)</span>中取到<span class="math inline">\(v_0\)</span>的代价最小的点并入，每一次并入时都需要修改<span class="math inline">\(v_0\)</span>到<span class="math inline">\(B\)</span>中顶点的代价，直到所有的顶点都并入为止。</p><p><strong>算法准备</strong></p><ol type="1"><li>数组<span class="math inline">\(dist\)</span>，用于存放<span class="math inline">\(v_0\)</span>到图中个顶点的代价，数组下标表示顶点编号</li><li>数组<span class="math inline">\(path\)</span>，用于存放路径，数组下标表示顶点编号，下标所对应的数组值表示能够到达当前这个顶点的前一个顶点编号，最后连起来就是<span class="math inline">\(v_0\)</span>到图中各顶点的最短路径了。如果没有前前驱顶点，则内容值为-1。</li><li>数组<span class="math inline">\(set\)</span>，用于标识图中顶点是否被处理过，数组下标表示顶点编号。处理过为1，没处理过为0。</li><li>使用图的邻接矩阵来存储有向带权图，<span class="math inline">\(graph[i][j]\)</span>。</li></ol><p><strong>算法过程（我们选择编号为0的顶点作为起点）</strong></p><ol type="1"><li>首先进行3个数组的初始化，把set数组全部初始化为0；<span class="math inline">\(dist\)</span>数组全部初始化为无穷大，<span class="math inline">\(path\)</span>数组全部初始化为-1。</li><li>将<span class="math inline">\(set[0]\)</span>的值设置为1，然后遍历邻接矩阵的第0行，依次更新<span class="math inline">\(dist\)</span>数组的每一项。</li><li>将<span class="math inline">\(dist\)</span>数组中值不为无穷大的在<span class="math inline">\(path\)</span>中的对应下标，把它们的值改为0。因为编号为0的点是它们的前驱嘛。</li><li>选择<span class="math inline">\(dist\)</span>数组中值最小的点的下标，这里为1。</li><li>将<span class="math inline">\(set[1]\)</span>的值设置为1</li><li>遍历邻接矩阵的第1行(因为1是最小权值的下标)，将dist[1]的值与邻接矩阵<span class="math inline">\(graph[1][i]\)</span>的值相加（此时是以编号为1的点作为中间点，看看由<span class="math inline">\(v_0\)</span>-&gt;<span class="math inline">\(v_1\)</span>再到其余点的路径长度会不会比<span class="math inline">\(v_0\)</span>直接到它们的路径长度短），如果这个值比dist[i]的值小，就更新<span class="math inline">\(dist[i]\)</span>，同时将<span class="math inline">\(path[i]\)</span>的值设置为1，执行这个操作的前提是，<span class="math inline">\(set[i]==0\)</span>。</li><li>重复（4）~（6）步，如果已经处理过的点就不用再判断了。直到<span class="math inline">\(set\)</span>数组全变为1。</li></ol><pre><code class="hljs C++"><span class="hljs-function">function <span class="hljs-title">Dijkstra</span><span class="hljs-params">(G, w, s)</span></span>for each vertex v in V[G]   // 初始化d[v] := infinity     <span class="hljs-comment">// 将各点的已知最短距离先设成无穷大</span>previous[v] := undefined   <span class="hljs-comment">// 各点的已知最短路径上的前趋都未知</span>d[s] := <span class="hljs-number">0</span>           <span class="hljs-comment">// 因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0</span>S := empty <span class="hljs-built_in">set</span>Q := <span class="hljs-built_in">set</span> of all vertices<span class="hljs-keyword">while</span> Q is <span class="hljs-keyword">not</span> an empty <span class="hljs-built_in">set</span>      <span class="hljs-comment">// Dijkstra算法主体</span>u := Extract_Min(Q)<span class="hljs-comment">//从Q中找一个距离远点s距离最小的点，加入S</span>S.append(u)<span class="hljs-keyword">for</span> each edge outgoing from u as (u,v)<span class="hljs-keyword">if</span> d[v] &gt; d[u] + w(u,v)    <span class="hljs-comment">// 拓展边（u,v）。w(u,v)为从u到v的路径长度。</span>d[v] := d[u] + w(u,v)  <span class="hljs-comment">// 更新路径长度到更小的那个和值。</span>previous[v] := u   <span class="hljs-comment">// 纪录前趋顶点</span></code></pre><pre><code class="hljs C++"><span class="hljs-comment">//采用邻接矩阵存储</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_V = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> V, E;<span class="hljs-keyword">int</span> G[MAX_V][MAX_V];<span class="hljs-keyword">int</span> dist[MAX_V];<span class="hljs-keyword">int</span> path[MAX_V];<span class="hljs-keyword">int</span> visited[MAX_V];<span class="hljs-comment">/*</span><span class="hljs-comment">采用邻接矩阵存储,需要设置visited数组判断是否已经访问过,</span><span class="hljs-comment">保证已计算出最短路的结点访问次数唯一,</span><span class="hljs-comment">作为对比可参考邻接表存储时的相应操作.</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;fill(path, path + MAX_V, <span class="hljs-number">-1</span>);fill(visited, visited + MAX_V, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;dist[j] = G[s][j];<span class="hljs-keyword">if</span> (G[s][j] &lt; INF) &#123;path[j] = s;&#125;&#125;dist[s] = <span class="hljs-number">0</span>;visited[s] = <span class="hljs-number">1</span>;path[s] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-keyword">int</span> minp = s, minw = INF;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<span class="hljs-keyword">if</span> (visited[j] == <span class="hljs-number">0</span> &amp;&amp; dist[j] &lt; minw) &#123;minw = dist[j];minp = j;&#125;&#125;visited[minp] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++) &#123;<span class="hljs-keyword">if</span> (visited[j] == <span class="hljs-number">0</span> &amp;&amp; minw &lt; INF &amp;&amp; dist[j] &gt; G[minp][j] + minw) &#123;dist[j] = G[minp][j] + minw;path[j] = minp;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ed)</span> </span>&#123;<span class="hljs-keyword">if</span> (path[ed] != <span class="hljs-number">-1</span>)get_path(path[ed]);<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span>;<span class="hljs-built_in">cout</span> &lt;&lt; ed &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; V &gt;&gt; E;fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX_V * MAX_V, INF);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<span class="hljs-keyword">int</span> u, v, w;<span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;G[u][v] = w;&#125;<span class="hljs-keyword">int</span> st = <span class="hljs-number">2</span>, ed = <span class="hljs-number">1</span>;dijkstra(st);get_path(ed);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; dist[ed] &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//采用邻接表存储</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_V = <span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span>    <span class="hljs-keyword">int</span> to, cost;    Edge(<span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> cost): to(to), cost(cost) &#123;&#125;;<span class="hljs-comment">//C++初始化列表-构造函数内容：（参数列表，函数体，初始化列表）</span>&#125;;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; P;<span class="hljs-comment">//first-to ,second-cost</span><span class="hljs-keyword">int</span> V, E;<span class="hljs-built_in">vector</span>&lt;Edge&gt; G[MAX_V];<span class="hljs-keyword">int</span> dist[MAX_V];<span class="hljs-keyword">int</span> path[MAX_V];<span class="hljs-comment">//bool visited[MAX_V];</span><span class="hljs-comment">/*</span><span class="hljs-comment">采用邻接表存储,不需要设置visited数组判断是否已经访问过,</span><span class="hljs-comment">因为采用优先队列维护已经保证访问次数唯一,</span><span class="hljs-comment">作为对比可参考邻接矩阵存储时的相应操作.</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;    <span class="hljs-built_in">priority_queue</span>&lt;P, <span class="hljs-built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;    fill(dist, dist + V + <span class="hljs-number">1</span>, INF);    fill(path, path + V + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);    dist[s] = <span class="hljs-number">0</span>;    path[s] = <span class="hljs-number">0</span>;    que.push(P(s, <span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span> (!que.empty()) &#123;        P p = que.top();        que.pop();        <span class="hljs-keyword">int</span> v = p.first;        <span class="hljs-keyword">if</span> (dist[v] &lt; p.second) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">/*细节问题！这里是剪枝操作，因为之前加入的点更新的距离可能已经不是最短，</span><span class="hljs-comment">        此时找到了另外一条最短路，节点也更新，即在优先队列中存在多个相同顶点序号，</span><span class="hljs-comment">        不同距离的pair&lt;&gt;，例如&lt;2,3&gt;,&lt;2,2&gt;（下面样例）会同时存在，显然，&lt;2,3&gt;这对数据没必要在运行*/</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[v].size(); i++) &#123;            Edge e = G[v][i];            <span class="hljs-keyword">if</span> (dist[e.to] &gt; dist[v] + e.cost) &#123;                dist[e.to] = dist[v] + e.cost;                que.push(P(e.to, dist[e.to]));                path[e.to] = v;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ed)</span> </span>&#123;    <span class="hljs-keyword">if</span> (path[ed]!=<span class="hljs-number">-1</span>)        get_path(path[ed]);    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; ed &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; V &gt;&gt; E;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;        <span class="hljs-keyword">int</span> u, v, w;        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;        G[u].push_back(Edge(v, w));    &#125;    <span class="hljs-keyword">int</span> st = <span class="hljs-number">1</span>, ed = <span class="hljs-number">4</span>;    dijkstra(st);    get_path(ed);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; dist[ed] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">5 7</span><span class="hljs-comment">1 2 1</span><span class="hljs-comment">1 3 4</span><span class="hljs-comment">1 5 1</span><span class="hljs-comment">2 4 5</span><span class="hljs-comment">5 2 1</span><span class="hljs-comment">5 3 2</span><span class="hljs-comment">3 4 2</span><span class="hljs-comment">*/</span></code></pre><p>在最短路径问题中，对于带权有向图G = (V, E)，<strong>Dijkstra</strong> 算法的初始实现版本未使用最小优先队列实现，其<strong>时间复杂度</strong>为O(V2)，基于Fibonacci heap 的最小优先队列实现版本，其<strong>时间复杂度</strong>为O(E + VlogV)。</p><hr /><h4 id="bell-man-ford">Bell-man Ford</h4><p><strong>算法思路</strong></p><p><a href="https://blog.csdn.net/C2681595858/article/details/85687836#1_Dijkstra_3">参考资料</a></p><p><strong>核心思想是：</strong>首先对距离进行松弛，然后随着迭代次数的增加，距离越来越接近最短路径，直到最后得出最短路径。更具体一点说就是每一次检查每一条边 <span class="math inline">\(&lt;u,v&gt;\)</span> ,看是否有 <span class="math inline">\(d[v] &gt; d[u] + L_{uv}\)</span> 情况，如果有就更新 <span class="math inline">\(d[v]\)</span> 的值，这样一来每一遍大的循环就把源点的情况全局推进一步，然后最多推进n-1步也就把原点的情况推到了每一个节点。</p><p><strong>松弛：</strong>每次松弛操作实际上是对相邻节点的访问，第 <span class="math inline">\(k\)</span> 次松弛操作保证了所有深度为 <span class="math inline">\(k\)</span> 的路径最短。由于图的最短路径最长不会经过超过 <span class="math inline">\(|V|-1\)</span> 条边，所以可知贝尔曼-福特算法所得为最短路径。</p><p><strong>负边权操作：</strong>与迪科斯彻算法不同的是，迪科斯彻算法的基本操作“拓展”是在深度上寻路；而“松弛”操作则是在广度上寻路，这就确定了贝尔曼-福特算法可以对负边进行操作而不会影响结果。</p><p><strong>负权环判定：</strong>因为负权环可以无限制的降低总花费，所以如果发现第 <span class="math inline">\(n\)</span> 次操作仍可降低花销，就一定存在负权环。</p><pre><code class="hljs C++"><span class="hljs-function">procedure <span class="hljs-title">BellmanFord</span><span class="hljs-params">(<span class="hljs-built_in">list</span> vertices, <span class="hljs-built_in">list</span> edges, vertex source)</span></span><span class="hljs-function">   <span class="hljs-comment">//读入边和顶点的列表并对distance和predecessor写入最短路径</span></span><span class="hljs-function">   <span class="hljs-comment">// 初始化图</span></span><span class="hljs-function">   <span class="hljs-keyword">for</span> each vertex v in vertices:</span>       if v is source then distance[v] := 0       <span class="hljs-keyword">else</span> distance[v] := infinity       predecessor[v] := null   <span class="hljs-comment">// 对每一条边重复进行“松弛”操作</span>   <span class="hljs-keyword">for</span> i from <span class="hljs-number">1</span> to size(vertices)<span class="hljs-number">-1</span>: <span class="hljs-comment">// V - 1 次松弛</span>       <span class="hljs-keyword">for</span> each edge (u, v) with weight w in edges:           <span class="hljs-keyword">if</span> distance[u] + w &lt; distance[v]:               distance[v] := distance[u] + w               predecessor[v] := u   <span class="hljs-comment">// 检查图中包含有负权重的环</span>   <span class="hljs-keyword">for</span> each edge (u, v) with weight w in edges:       <span class="hljs-keyword">if</span> distance[u] + w &lt; distance[v]:           error <span class="hljs-string">&quot;图中包含有负权重的环&quot;</span></code></pre><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxnum = <span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxint = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-comment">// 边，</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span>    <span class="hljs-keyword">int</span> u, v;    <span class="hljs-comment">// 起点，重点</span>    <span class="hljs-keyword">int</span> weight;  <span class="hljs-comment">// 边的权值</span>&#125;Edge;Edge edge[maxnum];     <span class="hljs-comment">// 保存边的值</span><span class="hljs-keyword">int</span>  dist[maxnum];     <span class="hljs-comment">// 结点到源点最小距离</span><span class="hljs-keyword">int</span> nodenum, edgenum, source;    <span class="hljs-comment">// 结点数，边数，源点</span><span class="hljs-comment">// 初始化图</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 输入结点数，边数，源点</span>    <span class="hljs-built_in">cin</span> &gt;&gt; nodenum &gt;&gt; edgenum &gt;&gt; source;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=nodenum; ++i)        dist[i] = maxint;    dist[source] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=edgenum; ++i)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].weight;        <span class="hljs-keyword">if</span>(edge[i].u == source)          <span class="hljs-comment">//注意这里设置初始情况</span>            dist[edge[i].v] = edge[i].weight;    &#125;&#125;<span class="hljs-comment">// 松弛计算</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">relax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> weight)</span></span>&#123;    <span class="hljs-keyword">if</span>(dist[v] &gt; dist[u] + weight)        dist[v] = dist[u] + weight;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=nodenum<span class="hljs-number">-1</span>; ++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=edgenum; ++j)            relax(edge[j].u, edge[j].v, edge[j].weight);    <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 判断是否有负环路</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=edgenum; ++i)        <span class="hljs-keyword">if</span>(dist[edge[i].v] &gt; dist[edge[i].u] + edge[i].weight)&#123;            flag = <span class="hljs-number">0</span>;            <span class="hljs-keyword">break</span>;        &#125;    <span class="hljs-keyword">return</span> flag;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//freopen(&quot;input3.txt&quot;, &quot;r&quot;, stdin);</span>    init();    <span class="hljs-keyword">if</span>(Bellman_Ford())&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ;i &lt;= nodenum; i++)            <span class="hljs-built_in">cout</span> &lt;&lt; dist[i] &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>复杂度O(VE)</p><hr /><h4 id="spfa">SPFA</h4><p>算法思路</p><p><strong>算法思想：</strong></p><p>我们用数组记录每个结点的最短路径估计值，用邻接表来存储图G。</p><p>我们采取的方法是动态逼近法：1.设立一个先进先出的队列用来保存待优化的结点。 2.优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。 3.这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</p><p>期望的时间复杂度O(ke)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2。（?）</p><pre><code class="hljs C++">procedure Shortest-Path-Faster-Algorithm(G, s)   <span class="hljs-keyword">for</span> each vertex v ≠ <span class="hljs-function">s in <span class="hljs-title">V</span><span class="hljs-params">(G)</span></span><span class="hljs-function">       <span class="hljs-title">d</span><span class="hljs-params">(v)</span> :</span>= ∞   d(s) := <span class="hljs-number">0</span>   offer s into PQ <span class="hljs-comment">//PQ是优先队列</span>   <span class="hljs-keyword">while</span> PQ is <span class="hljs-keyword">not</span> empty       u := poll PQ       <span class="hljs-keyword">for</span> each edge (u, v) in E(G)           <span class="hljs-keyword">if</span> d(u) + w(u, v) &lt; d(v) then               d(v) := d(u) + w(u, v)               <span class="hljs-keyword">if</span> v is <span class="hljs-keyword">not</span> in PQ then                   offer v into PQ</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//bfs 万能啊</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa_bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;    <span class="hljs-built_in">queue</span> &lt;<span class="hljs-keyword">int</span>&gt; q;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span>(d));    d[s]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    q.push(s);  vis[s]=<span class="hljs-number">1</span>; c[s]=<span class="hljs-number">1</span>;    <span class="hljs-comment">//顶点入队vis要做标记，另外要统计顶点的入队次数</span>    <span class="hljs-keyword">int</span> OK=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> x;        x=q.front(); q.pop();  vis[x]=<span class="hljs-number">0</span>;        <span class="hljs-comment">//队头元素出队，并且消除标记</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=f[x]; k!=<span class="hljs-number">0</span>; k=nnext[k]) <span class="hljs-comment">//遍历顶点x的邻接表</span>        &#123;            <span class="hljs-keyword">int</span> y=v[k];            <span class="hljs-keyword">if</span>( d[x]+w[k] &lt; d[y])            &#123;                d[y]=d[x]+w[k];  <span class="hljs-comment">//松弛</span>                <span class="hljs-keyword">if</span>(!vis[y])  <span class="hljs-comment">//顶点y不在队内</span>                &#123;                    vis[y]=<span class="hljs-number">1</span>;    <span class="hljs-comment">//标记</span>                    c[y]++;      <span class="hljs-comment">//统计次数</span>                    q.push(y);   <span class="hljs-comment">//入队</span>                    <span class="hljs-keyword">if</span>(c[y]&gt;NN)  <span class="hljs-comment">//超过入队次数上限，说明有负环</span>                        <span class="hljs-keyword">return</span> OK=<span class="hljs-number">0</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> OK;&#125;<span class="hljs-comment">//dfs处理负环更快，但是仅限于有限深度</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa_dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><span class="hljs-function"></span>&#123;    vis[u]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=f[u]; k!=<span class="hljs-number">0</span>; k=e[k].next)    &#123;        <span class="hljs-keyword">int</span> v=e[k].v,w=e[k].w;        <span class="hljs-keyword">if</span>( d[u]+w &lt; d[v] )        &#123;            d[v]=d[u]+w;            <span class="hljs-keyword">if</span>(!vis[v])            &#123;                <span class="hljs-keyword">if</span>(spfa_dfs(v))                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    vis[u]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>时间复杂度是O(α(n)n)，n为边数，α(n)为n的反阿克曼函数，一般小于等于4</p><hr /><h4 id="floyd">Floyd</h4><p>算法思路</p><p><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6995648.html">参考资料</a></p><p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd算法的时间复杂度为 <span class="math inline">\(O(N^3)\)</span> ，空间复杂度为 <span class="math inline">\(O(N^2)\)</span> 。Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点 u 到点 v 的最短路径，有两种情况：（1）直接从点 u 到 v 点（2）从点 u 经过若干个中间点 w 到点 v 。</p><p>算法描述：a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。</p><pre><code class="hljs C++">let dist be a |V| × |V| <span class="hljs-built_in">array</span> of minimum distances initialized to ∞ (infinity)<span class="hljs-keyword">for</span> each vertex v    dist[v][v] ← <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">for</span> each <span class="hljs-title">edge</span> <span class="hljs-params">(u,v)</span></span>    dist[u][v] ← w(u,v)  // the weight of the edge (u,v)<span class="hljs-keyword">for</span> k from <span class="hljs-number">1</span> to |V|    <span class="hljs-keyword">for</span> i from <span class="hljs-number">1</span> to |V|       <span class="hljs-keyword">for</span> j from <span class="hljs-number">1</span> to |V|          <span class="hljs-keyword">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]              dist[i][j] ← dist[i][k] + dist[k][j]          end <span class="hljs-keyword">if</span></code></pre><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyed</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//顶点的编号1~n</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;                dist[i][j] = min(dis[i][j],dis[i][k]+dis[k][j]);                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">4 8   </span><span class="hljs-comment">1 2 2   </span><span class="hljs-comment">1 3 6   </span><span class="hljs-comment">1 4 4   </span><span class="hljs-comment">2 3 3   </span><span class="hljs-comment">3 1 7   </span><span class="hljs-comment">3 4 1   </span><span class="hljs-comment">4 1 5   </span><span class="hljs-comment">4 3 12 </span><span class="hljs-comment">*/</span><span class="hljs-comment">//传递闭包问题的修改版</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;                dp[i][j]=dp[i][j]||(dp[i][k]&amp;&amp;dp[k][j]);            &#125;        &#125;    &#125;&#125;</code></pre><p>时间复杂度：<span class="math inline">\(O(n^3)\)</span></p><hr /><ul><li>图的连通<ul><li>强连通分量</li><li>双连通分量</li><li>割点、桥</li></ul></li><li>网络流<ul><li>最大流</li><li>最小割</li><li>费用流</li><li>分数规划</li><li>无汇无源可行流</li></ul></li><li>二分图<ul><li>KM算法</li><li>Hungary算法、HK算法</li></ul></li></ul><hr /><h3 id="最小生成树">最小生成树</h3><p>1.Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣。</p><p>2.Prim+Heap在任何时候都有令人满意的的时间复杂度，但是代价是空间消耗极大。【以及代码很复杂&gt;_&lt;】</p><p>3.时间复杂度并不能反映出一个<a href="https://blog.csdn.net/Haskei/article/details/53132681">算法</a>的实际优劣。</p><h4 id="prim"><font color="#00dd00">Prim</font></h4><p><strong>算法思路</strong></p><p><a href="https://www.cnblogs.com/alantu2018/p/8464561.html">参考资料</a></p><p>定义：一个连通图的生成树是一个极小的连通子图，它包含图中全部的顶点（n个顶点），但只有n-1条边。最小生成树是构造连通网的最小代价（最小权值）生成树。</p><p>最小生成树MST性质：假设N=（V,{E}）是一个连通网，U是顶点集V的一个非空子集。若（u,v）是一条具有最小权值（代价）的边，其中u∈U，v∈V-U，则必存在一颗包含边（u,v）的最小生成树。</p><p><strong>Prim算法过程为：</strong></p><p>书上是这么说的：假设N=（V,{E}）是连通图，TE是N上最小生成树中边的集合。算法从U={u_0}（u_0∈V），TE={}开始，重复执行下述操作：在所有u∈U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0，v0）并入集合TE，同时v0 并入U，直至U=V为止。此时TE中必有n-1条边，则T=（V，{TE}）为N的最小生成树。</p><p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><p>图的所有顶点集合为V；初始令集合u={s}, v=V−u; 在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。 由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组mincost[MAX_V]，用来维护集合v中每个顶点与集合u中最小代价边信息。</p><pre><code class="hljs C++"><span class="hljs-comment">/* wiki伪代码</span><span class="hljs-comment">从单一顶点开始，普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</span><span class="hljs-comment">输入：一个加权连通图，其中顶点集合为V，边集合为E；</span><span class="hljs-comment">初始化：Vnew=&#123;x&#125;，其中x为集合V中的任一节点（起始点），Enew=&#123;&#125;；</span><span class="hljs-comment">重复下列操作，直到Vnew = V：</span><span class="hljs-comment">在集合E中选取权值最小的边（u, v），其中u为集合Vnew中的元素，而v则是V中没有加入Vnew的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</span><span class="hljs-comment">将v加入集合Vnew中，将（u, v）加入集合Enew中；</span><span class="hljs-comment">输出：使用集合Vnew和Enew来描述所得到的最小生成树。</span><span class="hljs-comment">*/</span></code></pre><p><strong>主要过程是以“点”集合为中心算的，此外还可以使用Heap + Prim优化。</strong></p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> cost[MAX _V][MAX _V]; <span class="hljs-comment">//cost[u][v]表 示边e=(u,v)的权值(不存在的情况下设为INF )</span><span class="hljs-keyword">int</span> mincost[MAX_ V] ;  <span class="hljs-comment">//从集合X出发的边到每个顶点的最小权值</span><span class="hljs-keyword">bool</span> used[MAX_ _V];  <span class="hljs-comment">// 顶点i是否包含在集合X中</span><span class="hljs-keyword">int</span> V;  <span class="hljs-comment">//顶点数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;        mincost[i] = INF;        used[i] = <span class="hljs-literal">false</span>;    &#125;    mincost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">int</span> v = <span class="hljs-number">-1</span>;          <span class="hljs-comment">//从不属于X的顶点中选取从X到其权值最小的顶点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; V; u++) &#123;            <span class="hljs-keyword">if</span> (!used[u] &amp;&amp; (v == <span class="hljs-number">-1</span> || mincost[u] &lt; mincost[v])) &#123;                v = u;            &#125;        &#125;        <span class="hljs-keyword">if</span> (v == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;        used[v] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//把顶点v加入X</span>        res += mincost[v];  <span class="hljs-comment">//把边的长度加到结果里</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; V; u++) &#123;            mincost[u] = min(mincost[u], cost[v][u]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//返回MST权值</span>&#125;</code></pre><p>复杂度：临接矩阵<span class="math inline">\(O(|V|^2)\)</span> 邻接表 <span class="math inline">\(O(|E| log |V|)\)</span></p><hr /><h4 id="krusual"><font color="#00dd00">Krusual</font></h4><p>算法思路</p><p><a href="https://blog.csdn.net/qq_41754350/article/details/81460643">参考资料</a></p><p>克鲁斯卡尔算法的基本思想是以边为主导地位，始终选择当前可用的最小边权的边（可以sort）。每次选择边权最小的边链接两个端点是kruskal的规则，并实时判断两个点之间有没有间接联通。</p><p>Kruskal算法原理如下。首先，将每个顶点放入其自身的数据集合中。然后，按照权值的升序来选择边。当选择每条边时，判断定义边的顶点是否在不同的数据集中。如果是，将此边插入最小生成树的集合中，同时，将集合中包含每个顶点的联合体取出，如果不是，就移动到下一条边。重复这个过程直到所有的边都探查过。</p><p>算法简单，需要使用到<a href="https://blog.csdn.net/qq_41754350/article/details/81271567">并查集</a>。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,m,tot=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<span class="hljs-comment">//n端点总数，m边数，tot记录最终答案，k已经连接了多少边 </span><span class="hljs-keyword">int</span> fat[<span class="hljs-number">200010</span>];<span class="hljs-comment">//记录集体老大 </span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> from,to,dis;<span class="hljs-comment">//结构体储存边 </span>&#125;edge[<span class="hljs-number">200010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> node &amp;a,<span class="hljs-keyword">const</span> node &amp;b)</span><span class="hljs-comment">//sort排序（当然你也可以快排） </span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> a.dis&lt;b.dis;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">father</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//找集体老大，并查集的一部分 </span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(fat[x]!=x)<span class="hljs-keyword">return</span> father(fat[x]);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unionn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span><span class="hljs-comment">//加入团体，并查集的一部分 </span></span><span class="hljs-function"></span>&#123;fat[father(y)]=father(x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="hljs-comment">//输入点数，边数 </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;edge[i].from,&amp;edge[i].to,&amp;edge[i].dis);<span class="hljs-comment">//输入边的信息 </span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) fat[i]=i;<span class="hljs-comment">//自己最开始就是自己的老大 （初始化） </span>sort(edge+<span class="hljs-number">1</span>,edge+<span class="hljs-number">1</span>+m,cmp);<span class="hljs-comment">//按权值排序（kruskal的体现） </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<span class="hljs-comment">//从小到大遍历 </span>&#123;<span class="hljs-keyword">if</span>(k==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//n个点需要n-1条边连接 </span><span class="hljs-keyword">if</span>(father(edge[i].from)!=father(edge[i].to))<span class="hljs-comment">//假如不在一个团体 </span>&#123;unionn(edge[i].from,edge[i].to);<span class="hljs-comment">//加入 </span>tot+=edge[i].dis;<span class="hljs-comment">//记录边权 </span>k++;<span class="hljs-comment">//已连接边数+1 </span>&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,tot);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>时间复杂度：O(|Elog|E|)</p><hr /><ul><li>最小树形图<ul><li>朱刘算法</li></ul></li><li>欧拉图</li><li>环套树</li><li>仙人掌</li></ul><h2 id="树相关">树相关</h2><ul><li><p>树上倍增</p><ul><li>最近公共祖先</li></ul></li><li><p>树链剖分</p></li><li><p>动态树</p><ul><li>Link-Cut Tree</li><li>树分块</li></ul></li><li><p>树分治</p><ul><li>点分治</li><li>边分治</li></ul></li><li><p>虚树</p></li><li><p>Prufer编码</p></li><li><p>拓扑排序</p><p><strong>基于DFS的拓扑排序</strong></p><pre><code class="hljs c++">摘录一段维基百科上的伪码：L ← Empty <span class="hljs-built_in">list</span> that will contain the sorted nodesS ← Set of all nodes with no outgoing edges<span class="hljs-keyword">for</span> each node n in S <span class="hljs-keyword">do</span>    visit(n) <span class="hljs-function">function <span class="hljs-title">visit</span><span class="hljs-params">(node n)</span></span><span class="hljs-function">    <span class="hljs-keyword">if</span> n has <span class="hljs-keyword">not</span> been visited yet then</span><span class="hljs-function">        mark n as visited</span><span class="hljs-function">        <span class="hljs-keyword">for</span> each node m with an edgefrom m to ndo</span><span class="hljs-function">            <span class="hljs-title">visit</span><span class="hljs-params">(m)</span></span><span class="hljs-function">        add n to L</span></code></pre><p>DFS的实现更加简单直观，使用递归实现。利用DFS实现拓扑排序，实际上只需要添加一行代码，即上面伪码中的最后一行：add n to L .需要注意的是，将顶点添加到结果List中的时机是在visit方法即将退出之时。这种方法十分巧妙。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> T, n, m, cases;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;Map[maxn];<span class="hljs-keyword">int</span> c[maxn];<span class="hljs-comment">//标记数组c[i] = 0 表示还未访问过点i， c[i] = 1表示已经访问过点i，并且还递归访问过它的所有子孙，c[i] = -1表示正在访问中，尚未返回</span><span class="hljs-keyword">int</span> topo[maxn], t;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span><span class="hljs-comment">//从u出发</span></span><span class="hljs-function"></span>&#123;    c[u] = <span class="hljs-number">-1</span>;<span class="hljs-comment">//访问标志</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Map[u].size(); i++)    &#123;        <span class="hljs-keyword">int</span> v = Map[u][i];        <span class="hljs-keyword">if</span>(c[v] &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果子孙比父亲先访问，说明存在有向环，失败退出</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[v] &amp;&amp; !dfs(v))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果子孙未被访问，访问子孙返回假，说明也是失败</span>    &#125;    c[u] = <span class="hljs-number">1</span>;    topo[--t] = u;<span class="hljs-comment">//在递归结束才加入topo排序中，这是由于在最深层次递归中，已经访问到了尽头，此时才是拓扑排序中的最后一个元素</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    t = n;    <span class="hljs-built_in">memset</span>(c, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(c));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; u++)<span class="hljs-keyword">if</span>(!c[u])        <span class="hljs-keyword">if</span>(!dfs(u))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m)    &#123;        <span class="hljs-keyword">if</span>(!n &amp;&amp; !m)<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">int</span> u, v;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  i &lt;= n; i++)Map[i].clear();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)        &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;            Map[u].push_back(v);        &#125;        <span class="hljs-keyword">if</span>(toposort())        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Great! There is not cycle.&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-built_in">cout</span>&lt;&lt;topo[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Network has a cycle!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Kahn算法</strong></p><p><strong>Kahn算法：</strong></p><pre><code class="hljs C++">摘一段维基百科上关于Kahn算法的伪码描述：L← Empty <span class="hljs-built_in">list</span> that will contain the sorted elementsS ← Set of all nodes with no incoming edges<span class="hljs-keyword">while</span> S is non-empty <span class="hljs-keyword">do</span>    remove a node n from S    insert n into L    foreach node m with an edge e from nto m <span class="hljs-keyword">do</span>        remove edge e from thegraph        ifm has no other incoming edges then            insert m into S<span class="hljs-keyword">if</span> graph has edges then    <span class="hljs-keyword">return</span> error (graph has at least onecycle)<span class="hljs-keyword">else</span>     <span class="hljs-keyword">return</span> L (a topologically sortedorder)</code></pre><p>不难看出该算法的实现十分直观，关键在于需要维护一个入度为0的顶点的集合：每次从该集合中取出(没有特殊的取出规则，随机取出也行，使用队列/栈也行，下同)一个顶点，将该顶点放入保存结果的List中。紧接着循环遍历由该顶点引出的所有边，从图中移除这条边，同时获取该边的另外一个顶点，如果该顶点的入度在减去本条边之后为0，那么也将这个顶点放到入度为0的集合中。然后继续从集合中取出一个顶点......当集合为空之后，检查图中是否还存在任何边，如果存在的话，说明图中至少存在一条环路。不存在的话则返回结果List，此List中的顺序就是对图进行拓扑排序的结果。</p><p>实现算法：<a href="https://blog.csdn.net/qinzhaokun/article/details/48541117">博客链接</a></p></li></ul><h2 id="数论">数论</h2><ul><li>欧几里得算法<ul><li>扩展欧几里得算法</li></ul></li><li>筛法</li><li>杜教筛</li><li>快速幂</li><li>裴蜀定理</li><li>欧拉函数<ul><li>欧拉定理</li><li>费马小定理</li></ul></li><li>排列组合<ul><li>Lucas定理</li></ul></li><li>乘法逆元</li><li>矩阵乘法</li><li>数学概率与期望</li><li>博弈论<ul><li>SG函数</li><li>树上删边游戏</li></ul></li><li>拉格朗日乘子法</li><li>中国剩余定理</li><li>线性规划<ul><li>单纯形</li></ul></li><li>辛普森积分</li><li>模线性方程组</li><li>莫比乌斯反演<ul><li>莫比乌斯函数</li></ul></li><li>容次原理</li><li>置换群</li><li>FFT、NTT</li><li>BSGS<ul><li>扩展BSGS</li></ul></li></ul><h2 id="动态规划">动态规划</h2><ul><li>背包问题</li><li>概率DP</li><li>状压DP</li><li>区间DP</li><li>树形DP</li><li>数位DP</li><li>插头DP</li><li>斯坦纳树</li><li>DP优化<ul><li>单调队列优化</li><li>矩阵乘法优化</li><li>斜率优化</li><li>四边形不等式优化</li></ul></li></ul><h2 id="计算几何">计算几何</h2><ul><li>计算几何基础</li><li>梯形剖分</li><li>三角形剖分</li><li>旋转卡壳</li><li>半平面交</li><li>pick定理</li><li>扫描线</li></ul><h2 id="搜索">搜索</h2><ul><li>DFS、BFS</li><li>A<em>、IDA</em></li><li>迭代加深搜索</li><li>双向BFS</li></ul><h2 id="随机化">随机化</h2><ul><li>模拟退火</li><li>爬山算法</li><li>随机增量法</li></ul><hr /><h2 id="排序算法">排序算法</h2><p>这里将展示十中排序算法，包括内部排序和外部排序，各类排序算法的复杂度总结如下表：</p><p>！！！待插入汇总表</p><hr /><h3 id="插入排序">插入排序</h3><h4 id="直接插入排序">直接插入排序</h4><p><strong>算法思想：</strong> 将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。此方法可用于链表。</p><p><strong>要点：</strong> 设立哨兵，作为临时存储和判断数组边界之用。</p><pre><code class="hljs C++"><span class="hljs-comment">//插入排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">list</span>[],<span class="hljs-keyword">int</span> count)</span></span>&#123;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-comment">/*此处充当哨兵，不在list数组里面单独占一个单位*/</span>    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;count;i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>[i]&lt;<span class="hljs-built_in">list</span>[i<span class="hljs-number">-1</span>])&#123;            temp = <span class="hljs-built_in">list</span>[i];            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;<span class="hljs-built_in">list</span>[j]&gt;temp&amp;&amp;j&gt;=<span class="hljs-number">0</span>;j--)&#123;                <span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>[j];            &#125;            <span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>] = temp;        &#125;    &#125;&#125;<span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> len)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;        <span class="hljs-keyword">if</span>(a[i]&lt;a[i<span class="hljs-number">-1</span>])&#123;            <span class="hljs-keyword">int</span> tmp = a[i];            <span class="hljs-keyword">int</span> j;            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;                <span class="hljs-keyword">if</span>(tmp&lt;a[j])&#123;                    a[j+<span class="hljs-number">1</span>] = a[j];                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-comment">//上面那个拆开就是这样</span>            &#125;            a[j+<span class="hljs-number">1</span>] = tmp;        &#125;    &#125;&#125;</code></pre><h4 id="折半插入排序">折半插入排序</h4><p><strong>基本概念：</strong> 折半插入排序（binary insertion sort）是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。</p><p><strong>算法思想：</strong> 在将一个新元素插入已排好序的数组的过程中，寻找插入点时，将待插入区域的首元素设置为a[low]，末元素设置为a[high]，则轮比较时将待插入元素与a[m]，其中m=(low+high)/2相比较,如果比参考元素大，则选择a[low]到a[m-1]为新的插入区域(即high=m-1)，否则选择a[m+1]到a[high]为新的插入区域（即low=m+1），如此直至low&lt;=high不成立，即将此位置之后所有元素后移一位，并将新元素插入a[high+1]。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BinaryInsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span>   </span>&#123;    <span class="hljs-keyword">int</span> i, j, k, low, high, m;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;        low = <span class="hljs-number">0</span>;        high = i - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(low &lt;= high) &#123; <span class="hljs-comment">//主要优化就是用二分法寻找有序数组的目标值</span>            m = (low + high) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(a[m] &gt; a[i]) high = m - <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> low = m + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(j != i - <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">int</span> temp = a[i];            <span class="hljs-keyword">for</span>(k = i - <span class="hljs-number">1</span>; k &gt;= high + <span class="hljs-number">1</span>; k--)                a[k + <span class="hljs-number">1</span>] = a[k];            a[k + <span class="hljs-number">1</span>] = temp;        &#125;    &#125;&#125;</code></pre><h4 id="希尔排序">希尔排序</h4><p><strong>基本思想：</strong> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p><strong>排序过程：</strong> 先取一个正整数<span class="math inline">\(d_1&lt;n\)</span> ，把所有序号相隔 <span class="math inline">\(d_1\)</span> 的数组元素放一组，组内进行直接插入排序；然后取 <span class="math inline">\(d_2&lt;d_1\)</span> ，重复上述分组和排序操作；直至 <span class="math inline">\(d_i=1\)</span> ，即所有记录放进一个组中排序为止。</p><pre><code class="hljs C++"><span class="hljs-comment">//shell排序，序号是0~count-1，序号如果从1开始，写法上有一点区别</span><span class="hljs-comment">//待排序数组和数组长度count</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shell_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = len / <span class="hljs-number">2</span>; d &gt;= <span class="hljs-number">1</span>; d /= <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = d; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (a[i] &lt; a[i - d]) &#123;                <span class="hljs-keyword">int</span> tmp = a[i];                <span class="hljs-keyword">int</span> j;                <span class="hljs-keyword">for</span> (j = i - d; j &gt;= <span class="hljs-number">0</span>; j -= d) &#123;                    <span class="hljs-keyword">if</span> (tmp &lt; a[j]) &#123;                        a[j + d] = a[j];                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;                &#125;                a[j + d] = tmp;            &#125;        &#125;    &#125;&#125;</code></pre><hr /><h3 id="交换排序">交换排序</h3><h4 id="冒泡排序">冒泡排序</h4><p>算法思想：冒泡排序比较简单，俩层循环，第一层循环决定终止位置，第二层循环从起点位置开始遍历，到终止位置，其间对比相邻俩个元素，根据升序或者降序需求比较值并进行兑换。假设有一个大小为 N 的无序序列，冒泡排序就是要每趟排序过程中通过两两比较，找到第 i 个小（大）的元素，将其往上排。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-comment">//数组序号从0开始</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++)&#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//递增排序，把大的先放到数组后面</span>                swap(arr[j], arr[j + <span class="hljs-number">1</span>]);                            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">//逆序的写法，有序后加入flag提前退出</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//判断本轮的冒泡是否更新</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n<span class="hljs-number">-1</span>; j &gt; i; j--)&#123;<span class="hljs-comment">//把小的先放到数组前面,本轮选择第i小的数字</span>            <span class="hljs-keyword">if</span> (arr[j<span class="hljs-number">-1</span>] &gt; arr[j])&#123;<span class="hljs-comment">//递增排序</span>                swap(arr[j<span class="hljs-number">-1</span>], arr[j]);                flag = <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(!flag)<span class="hljs-keyword">return</span>;    &#125;&#125;</code></pre><h4 id="快速排序">快速排序</h4><p><strong>算法思想：</strong> 随机找出一个数，可以随机取，也可以取固定位置，一般是取第一个或最后一个称为基准，然后就是比基准小的在左边，比基准大的放到右边，如何放做，就是和基准进行交换，这样交换完左边都是比基准小的，右边都是比较基准大的，这样就将一个数组分成了两个子数组，然后再按照同样的方法把子数组再分成更小的子数组，直到不能分解为止。</p><p><strong>算法流程：</strong> （1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； （2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； （3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； （4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； （5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<span class="hljs-keyword">int</span> temp=arr[left];<span class="hljs-keyword">while</span>(left&lt;right)<span class="hljs-comment">//直达left和right重合的时候，才找到合适的位置</span>&#123;<span class="hljs-comment">//先从后往前找比基准小的</span><span class="hljs-keyword">while</span>(left&lt;right  &amp;&amp;  arr[right]&gt;=temp)            <span class="hljs-comment">//当right的值大于temp的值的时候才执行</span>    <span class="hljs-comment">//等号一定得写，因为可能会出现，保存的temp元素和数据中的元素一样的，不写会出现死循环的现象</span>&#123;right--;&#125;arr[left]=arr[right];        <span class="hljs-comment">//当right的值小于temp的值的时候执行</span><span class="hljs-comment">//从前往后找，找比基准大的</span><span class="hljs-keyword">while</span>(left&lt;right  &amp;&amp; arr[left] &lt;=temp)<span class="hljs-comment">//当left的值小于temp的值的时候执行</span>&#123;left++;&#125;arr[right]=arr[left];<span class="hljs-comment">//当left的值大于temp的时候执行</span>&#125;arr[left]=temp;<span class="hljs-comment">//此时的left和right在同一个位置，此时为合适的位置，把temp的值给left</span><span class="hljs-keyword">return</span> left;<span class="hljs-comment">//此时返回的值是temp合适的位置，即小于它的在它的左边，大于它的在它的右边</span>&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<span class="hljs-keyword">if</span>(left&lt;right)&#123;<span class="hljs-keyword">int</span> pivot=partition(arr,left,right);quick(arr,left,pivot<span class="hljs-number">-1</span>);quick(arr,pivot+<span class="hljs-number">1</span>,right);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[],<span class="hljs-keyword">int</span> len)</span></span>&#123;quick(arr,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> arr[]=&#123;<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">45</span>,<span class="hljs-number">12</span>&#125;;<span class="hljs-keyword">int</span> len=<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);quick_sort(arr,len);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;len;++k)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;arr[k]&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>;&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;    <span class="hljs-keyword">int</span> tmp = a[low];    <span class="hljs-keyword">while</span>(low&lt;high)&#123;        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=tmp) --high;        a[low] = a[high];        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=tmp) ++low;        a[high] = a[low];     &#125;    a[low] = tmp;    <span class="hljs-keyword">return</span> low;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span>(low &lt; high)&#123;        <span class="hljs-keyword">int</span> pos = partition(a,low,high);        quickSort(a,low,pos<span class="hljs-number">-1</span>);        quickSort(a,pos+<span class="hljs-number">1</span>,high);    &#125;&#125;</code></pre><p><strong>快速排序的优化方法：</strong> <a href="https://blog.csdn.net/lingling_nice/article/details/80943231">参考资料</a></p><p>（1）三数取中法，解决数据基本有序的（就是找到数组中最小下标，最大下标，中间下标的数字，进行比较，把中间大的数组放在最左边）</p><p>（2）随机选取基准，引入的原因是因为在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴，方法就是取待排序列中任意一个元素作为基准</p><p>（3）优化小数组的交换，就是为了解决大才小用问题，<strong>对于很小和部分有序的数组，快排不如插排好</strong>。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排，快排截止范围：<strong>待排序序列长度N = 10</strong>，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形</p><p>（4）在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割，具体过程：在处理过程中，会有两个步骤第一步，在划分过程中，把与key相等元素放入数组的两端，第二步，划分结束后，把与key相等的元素移到枢轴周围</p><hr /><h3 id="选择排序">选择排序</h3><h4 id="简单选择排序">简单选择排序</h4><p>算法思想：在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p><pre><code class="hljs C++"><span class="hljs-comment">//选择排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Select_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">list</span>[],<span class="hljs-keyword">int</span> count)</span></span>&#123;    <span class="hljs-keyword">int</span> min,i,j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;        min = i;        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;count;j++)&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>[min]&gt;<span class="hljs-built_in">list</span>[j])&#123;                min = j;            &#125;        &#125;        <span class="hljs-keyword">if</span>(min!=i)&#123;            swap(<span class="hljs-built_in">list</span>[i],<span class="hljs-built_in">list</span>[min]);        &#125;    &#125;&#125;</code></pre><h4 id="堆排序">堆排序</h4><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。 堆是一种特殊的树形数据结构，即完全二叉树。堆分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆。</p><p><strong>算法思想：</strong></p><ul><li>步骤一：建立大根堆--将n个元素组成的无序序列构建一个堆，从最后一个非叶子节点开始向下调整。</li><li>步骤二：交换堆元素--交换堆尾元素和堆首元素，使堆尾元素为最大元素；</li><li>步骤三：重建大根堆--将前n-1个元素组成的无序序列调整为大根堆；</li></ul><p>​ 重复执行步骤二和步骤三，直到整个序列有序。</p><p>需要注意的是数组的序号可以从0开始也可以从1开始，写法上稍有不同，若初始序号是0，则对于序号是i的结点，</p><pre><code class="hljs C++"><span class="hljs-comment">//调整为一个堆</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_AdjustDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> m)</span><span class="hljs-comment">//数组的序号的从1开始</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>] = <span class="hljs-built_in">list</span>[s];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*s;j&lt;=m;j = <span class="hljs-number">2</span>*j)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>[j]&lt;<span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>]&amp;&amp;j&lt;m)        &#123;            j++;        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>]&gt;<span class="hljs-built_in">list</span>[j])            <span class="hljs-keyword">break</span>;        <span class="hljs-built_in">list</span>[s] = <span class="hljs-built_in">list</span>[j];        s = j;    &#125;    <span class="hljs-built_in">list</span>[s] = <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">/*这样写也可以</span><span class="hljs-comment">void adjustDown(int a[],int k, int len)&#123;</span><span class="hljs-comment">    a[0] = a[k];</span><span class="hljs-comment">    for(int i=2*k;i&lt;=len;i*=2)&#123;</span><span class="hljs-comment">        if(a[i]&lt;a[i+1]&amp;&amp;i&lt;len)i++;</span><span class="hljs-comment">        //if(a[0]&gt;a[i])break;</span><span class="hljs-comment">        if(a[i]&gt;a[k])&#123;</span><span class="hljs-comment">            swap(a[i],a[k]);k = i;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        else break;</span><span class="hljs-comment">        //a[k] = a[i];</span><span class="hljs-comment">        </span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    //a[k] = a[0];</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-comment">//堆排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> len)</span><span class="hljs-comment">//数组的序号的从1开始</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//创建一个大顶堆</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s = len/<span class="hljs-number">2</span>;s&gt;<span class="hljs-number">0</span>;s--)    &#123;        Heap_AdjustDown(<span class="hljs-built_in">list</span>,s,len);    &#125;     <span class="hljs-comment">//排序</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len;i &gt; <span class="hljs-number">1</span>;i--)    &#123;        swap(<span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>],<span class="hljs-built_in">list</span>[i]);        Heap_AdjustDown(<span class="hljs-built_in">list</span>,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);    &#125;&#125;</code></pre><p>补充，堆的插入和删除：删除堆顶元素操作需要将堆顶元素与堆尾交换，由于破坏了堆的性质，需要向下调整Heap_AdjustDown。而插入元素操作，需要在堆尾插入，然后从堆尾开始向上调整Heap_AdjustUp。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_AdjustUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> k)</span><span class="hljs-comment">//数组的序号的从1开始，参数k是向上调整的节点位置(list[k])，也是堆元素个数;list[0]用作临时变量存放结点数字</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>] = <span class="hljs-built_in">list</span>[k];    <span class="hljs-keyword">int</span> i = k/<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">list</span>[i]&lt;<span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>])&#123;        <span class="hljs-built_in">list</span>[k] = <span class="hljs-built_in">list</span>[i];        k = i;        i = k/<span class="hljs-number">2</span>;    &#125;    <span class="hljs-built_in">list</span>[k] = <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>];&#125;</code></pre><p>另外一种写法，差不多。</p><pre><code class="hljs C++"><span class="hljs-comment">//调整为一个堆，这个写法是0序号开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_AdjustDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> m)</span><span class="hljs-comment">//list是待排序数组，s是开始调整的父亲结点，m是堆尾结点的序号</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">list</span>[s];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>*s+<span class="hljs-number">1</span>;j&lt;=m;j = <span class="hljs-number">2</span>*j+<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>[j]&lt;<span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>]&amp;&amp;j&lt;m)        &#123;            j++;        &#125;        <span class="hljs-keyword">if</span>(temp&gt;<span class="hljs-built_in">list</span>[j])            <span class="hljs-keyword">break</span>;        <span class="hljs-built_in">list</span>[s] = <span class="hljs-built_in">list</span>[j];        s = j;    &#125;    <span class="hljs-built_in">list</span>[s] = temp;&#125; <span class="hljs-comment">//堆排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_Sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> len)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//创建一个大顶堆</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s = len/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;s&gt;=<span class="hljs-number">0</span>;s--)    &#123;        Heap_AdjustDown(<span class="hljs-built_in">list</span>,s,len<span class="hljs-number">-1</span>);    &#125;     <span class="hljs-comment">//排序</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">1</span>;i--)    &#123;        swap(<span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>],<span class="hljs-built_in">list</span>[i]);        Heap_AdjustDown(<span class="hljs-built_in">list</span>,<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_AdjustUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">list</span>,<span class="hljs-keyword">int</span> k)</span><span class="hljs-comment">//数组的序号的从0开始，参数k是向上调整的节点位置，也是堆元素个数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> tmp = <span class="hljs-built_in">list</span>[k];    <span class="hljs-keyword">int</span> i = (k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">list</span>[i]&lt;tmp)&#123;        <span class="hljs-built_in">list</span>[k] = <span class="hljs-built_in">list</span>[i];        k = i;        i = (k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//这里跳出，有空再改</span>    &#125;    <span class="hljs-built_in">list</span>[k] = tmp;&#125;</code></pre><p>n个元素建立堆的时间复杂度是O(n)，调整堆的时间复杂度是O(h)</p><hr /><h3 id="归并排序">归并排序</h3><p><strong>算法思想：</strong>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><a href="https://blog.csdn.net/orion_pistachio/article/details/70766898">参考资料</a></p><pre><code class="hljs C++"><span class="hljs-comment">//非递归</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &lt; y ? x : y;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">int</span> *a = arr;    <span class="hljs-keyword">int</span> *b = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));    <span class="hljs-keyword">int</span> seg, start;    <span class="hljs-keyword">for</span> (seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg) &#123;        <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; len; start += seg * <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class="hljs-number">2</span>, len);            <span class="hljs-keyword">int</span> k = low;            <span class="hljs-keyword">int</span> start1 = low, end1 = mid;            <span class="hljs-keyword">int</span> start2 = mid, end2 = high;            <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            <span class="hljs-keyword">while</span> (start1 &lt; end1)                b[k++] = a[start1++];            <span class="hljs-keyword">while</span> (start2 &lt; end2)                b[k++] = a[start2++];        &#125;        <span class="hljs-keyword">int</span> *temp = a;        a = b;        b = temp;    &#125;    <span class="hljs-keyword">if</span> (a != arr) &#123;        <span class="hljs-keyword">int</span> i;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)            b[i] = a[i];        b = a;    &#125;    <span class="hljs-built_in">free</span>(b);&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//递归</span><span class="hljs-comment">//merge_sort_recursive（待排序数组，辅助数组，起始位置，结束位置）</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort_recursive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> reg[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start &gt;= end)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="hljs-number">1</span>) + start;<span class="hljs-comment">//mid = (len)/2 + st</span>    <span class="hljs-keyword">int</span> start1 = start, end1 = mid;    <span class="hljs-keyword">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = end;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    <span class="hljs-keyword">int</span> k = start;    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    <span class="hljs-keyword">while</span> (start1 &lt;= end1)        reg[k++] = arr[start1++];    <span class="hljs-keyword">while</span> (start2 &lt;= end2)        reg[k++] = arr[start2++];    <span class="hljs-keyword">for</span> (k = start; k &lt;= end; k++)        arr[k] = reg[k];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">int</span> reg[len];    merge_sort_recursive(arr, reg, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);&#125;</code></pre><h3 id="基数排序">基数排序</h3><p>两种多关键码排序方法：最高位优先(Most Significant Digit first)法，简称MSD 法；最低位优先(Least Significant Digit first)法，简称LSD 法。实现方法是将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//辅助函数，求数据的最大位数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> maxData = data[<span class="hljs-number">0</span>];<span class="hljs-comment">///&lt; 最大数</span>    <span class="hljs-comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)    &#123;        <span class="hljs-keyword">if</span> (maxData &lt; data[i])            maxData = data[i];    &#125;    <span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;    <span class="hljs-keyword">while</span> (maxData &gt;= p)    &#123;        <span class="hljs-comment">//p *= 10; // Maybe overflow</span>        maxData /= <span class="hljs-number">10</span>;        ++d;    &#125;    <span class="hljs-keyword">return</span> d;<span class="hljs-comment">/*    int d = 1; //保存最大的位数</span><span class="hljs-comment">    int p = 10;</span><span class="hljs-comment">    for(int i = 0; i &lt; n; ++i)</span><span class="hljs-comment">    &#123;</span><span class="hljs-comment">        while(data[i] &gt;= p)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            p *= 10;</span><span class="hljs-comment">            ++d;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">    return d;*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radixsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//基数排序</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> d = maxbit(data, n);    <span class="hljs-keyword">int</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];    <span class="hljs-keyword">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//计数器</span>    <span class="hljs-keyword">int</span> i, j, k;    <span class="hljs-keyword">int</span> radix = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= d; i++) <span class="hljs-comment">//进行d次排序</span>    &#123;        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)            count[j] = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次分配前清空计数器</span>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++)        &#123;            k = (data[j] / radix) % <span class="hljs-number">10</span>; <span class="hljs-comment">//统计每个桶中的记录数</span>            count[k]++;        &#125;        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)            count[j] = count[j - <span class="hljs-number">1</span>] + count[j]; <span class="hljs-comment">//将tmp中的位置依次分配给每个桶</span>        <span class="hljs-keyword">for</span>(j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) <span class="hljs-comment">//将所有桶中记录依次收集到tmp中</span>        &#123;            k = (data[j] / radix) % <span class="hljs-number">10</span>;            tmp[count[k] - <span class="hljs-number">1</span>] = data[j];            count[k]--;        &#125;        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++) <span class="hljs-comment">//将临时数组的内容复制到data中</span>            data[j] = tmp[j];        radix = radix * <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">delete</span> []tmp;    <span class="hljs-keyword">delete</span> []count;&#125;</code></pre><h3 id="外部排序算法之多路归并排序">外部排序算法之多路归并排序</h3><hr /><h2 id="其他">其他</h2><ul><li><p>分治</p><ul><li>CDQ分治</li><li>整体二分</li></ul></li><li><p>莫队算法</p><ul><li>树上莫队算法</li><li>待修改莫队算法</li></ul></li><li><p>分块</p></li><li><p>高精度</p></li><li><p>离线</p></li><li><p>RMQ</p><ul><li>ST表</li></ul></li><li><p>二分法</p><ul><li>二分答案</li><li>二分查找</li></ul></li><li><p>三分法</p></li><li><p>贪心</p></li><li><p>模拟</p></li><li><p><strong>P类问题：</strong>存在多项式时间算法的问题。(P：polynomial，多项式)</p><p><strong>NP类问题：</strong>能在多项式时间内验证得出一个正确解的问题。(NP:Nondeterministic polynomial，非确定性多项式)P类问题是NP问题的子集，因为存在多项式时间解法的问题，总能在多项式时间内验证他。注意定义，这里是验证。NP类问题，我用个人的俗话理解就是，不知道这个问题是不是存在多项式时间内的算法，所以叫non-deterministic非确定性，但是我们可以在多项式时间内验证并得出这个问题的一个正确解。举个例子，</p><p><strong>NPC问题：</strong>如果所有np问题都能在多项式时间内转化为他，则称该np问题为npc问题(NPC:NP complete又叫NP完全问题)NPC问题是NP问题的子集。</p><p><strong>NPH问题：</strong>我们又叫NP难问题，他不是一个NP问题，然后所有的NPC问题都可以在多项式时间内转化为他的话，我们就叫他NPH（hard）问题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSDN博客链接</title>
    <link href="/2019/05/20/2019-05-20-CSDN%E5%8D%9A%E5%AE%A2/"/>
    <url>/2019/05/20/2019-05-20-CSDN%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>第一篇博客的链接，<a href="https://blog.csdn.net/orion_pistachio/article/details/56961411">最近没时间搬运了</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何安装Nest-simulator</title>
    <link href="/2019/04/01/2019-04-01-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Nest-simulator/"/>
    <url>/2019/04/01/2019-04-01-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Nest-simulator/</url>
    
    <content type="html"><![CDATA[<h2 id="如何安装nest-simulator">如何安装nest simulator</h2><p>官方参考链接：<a href="https://nest-simulator.readthedocs.io/en/latest/installation/linux_install.html#dependencies" class="uri">https://nest-simulator.readthedocs.io/en/latest/installation/linux_install.html#dependencies</a></p><p>官方是不支持直接在windows上安装nest的，但是可以使用virtualBox或者vmware来间接使用。</p><h4 id="所需材料"><strong>所需材料</strong></h4><ol type="1"><li>nest simulator源代码（我使用的是2.16.0版本，github上可以找到源代码）</li></ol><p><a href="https://nest-simulator.readthedocs.io/en/latest/download.html" class="uri">https://nest-simulator.readthedocs.io/en/latest/download.html</a></p><ol type="1"><li>vmware player 15（正版免费，官网有）</li><li>Ubuntu16.04.4的iso镜像</li><li>windows10上安装</li></ol><h4 id="安装步骤">安装步骤</h4><ol type="1"><li><p>首先安装好vmware并创建虚拟机，建议安装linux tool，可以直接在主机和虚拟机之间复制粘贴、可以全屏。可参考：<a href="https://blog.csdn.net/stpeace/article/details/78598333" class="uri">https://blog.csdn.net/stpeace/article/details/78598333</a></p></li><li><p>在Ubuntu中安装下列包：</p><pre><code class="hljs Shell">sudo apt-get install -y build-essential cmake libltdl7-dev libreadline6-dev \libncurses5-dev libgsl0-dev python-all-dev python-numpy python-scipy \python-matplotlib ipython openmpi-bin libopenmpi-dev python-nose//注意，这里可以先不安装，编译、安装nest的时候遇到有缺少的在安装，直接安装//在Ubuntu16.04上会遇到一些包的依赖的问题，见下。</code></pre></li><li><p>解压缩tarball：</p><pre><code class="hljs shell">tar -xzvf nest-simulator-2.16.0.tar.gz</code></pre></li><li><p>创建编译的目录：</p><pre><code class="hljs shell">mkdir nest-simulator-2.16.0-build</code></pre></li><li><p>cmake</p><pre><code class="hljs shell">cmake -DCMAKE_INSTALL_PREFIX:PATH=&lt;/install/path&gt; &lt;/path/to/NEST/src&gt;//&lt;/install/path&gt;是安装的目录，即nest-simulator-2.16.0-build文件夹//&lt;/path/to/NEST/src&gt;是源代码的目录//目录最好都是绝对路径</code></pre><p>出现NEST Configuration Summary之后不报错就可以make、make install、make installcheck了。</p></li></ol><p><strong>会遇到的问题！！</strong></p><p>安装过程中第一步就出现了错误</p><pre><code class="hljs shell">orion@orion233:~$ sudo apt-get install -y build-essential cmake libltdl7-dev libreadline6-dev \<span class="hljs-meta">&gt;</span><span class="bash"> libncurses5-dev libgsl0-dev python-all-dev python-numpy python-scipy \</span><span class="hljs-meta">&gt;</span><span class="bash"> python-matplotlib ipython openmpi-bin libopenmpi-dev python-nose</span>sudo: unable to resolve host orion233[sudo] password for orion: Sorry, try again.[sudo] password for orion: Reading package lists... DoneBuilding dependency tree       Reading state information... DoneNote, selecting &#x27;libltdl-dev&#x27; instead of &#x27;libltdl7-dev&#x27;Note, selecting &#x27;libgsl-dev&#x27; instead of &#x27;libgsl0-dev&#x27;build-essential is already the newest version (12.1ubuntu2).cmake is already the newest version (3.5.1-1ubuntu1).libgsl-dev is already the newest version (2.1+dfsg-2).libltdl-dev is already the newest version (2.4.6-0.1).libncurses5-dev is already the newest version (6.0+20160213-1ubuntu1).libreadline6-dev is already the newest version (6.3-8ubuntu2).ipython is already the newest version (2.4.1-1).openmpi-bin is already the newest version (1.10.2-8ubuntu1).Some packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: libopenmpi-dev : Depends: libhwloc-dev but it is not going to be installed python-all-dev : Depends: python (= 2.7.11-1) but 2.7.12-1~16.04 is to be installed                  Depends: python-all (= 2.7.11-1) but it is not going to be installed                  Depends: libpython-all-dev (= 2.7.11-1) but it is not going to be installed                  Depends: python-dev (= 2.7.11-1) but it is not going to be installed                  Depends: python2.7-dev (&gt;= 2.7-7) but it is not going to be installed python-numpy : Depends: liblapack3 but it is not going to be installed or                         liblapack.so.3 python-scipy : Depends: libgfortran3 (&gt;= 4.6) but it is not going to be installed                Depends: liblapack3 but it is not going to be installed or                         liblapack.so.3                Recommends: python-dev but it is not going to be installedE: Unable to correct problems, you have held broken packages.</code></pre><p>这是一些包之间相互依赖出现了问题，Linux下经常需要安装不同类型的库，在Ubuntu中，这些类库都是以“lib_name-version”的形式命名的。很多库之间存在依赖关系，即要安装这个就必须安装那个。有时候，类库之间依赖关系无法满足，你所要安装的程序就不能安装。 这类问题大多是由于相互依赖的几个库中一个或多个的版本已经更新，而用户要安装的库依赖于这几个库的较低的版本，这时候可以试试使用“sudo aptitude install ”（尖括号内为你要安装的程序的名字）。我们莫慌，先安装<strong>aptitude</strong></p><p><strong>使用aptitude</strong></p><p>aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。</p><p>sudo aptitude install python-numpy</p><p>运行后，不接受未安装方案，接受降级方案。搞定。</p><pre><code class="hljs angelscript"><span class="hljs-symbol">orion@</span>orion233:~$ sudo aptitude install libopenmpi-devThe following NEW packages will be installed:  libhwloc-dev&#123;a&#125; libibverbs-dev&#123;a&#125; libnuma-dev&#123;ab&#125; libopenmpi-dev <span class="hljs-number">0</span> packages upgraded, <span class="hljs-number">4</span> newly installed, <span class="hljs-number">0</span> to remove <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> <span class="hljs-keyword">not</span> upgraded.Need to <span class="hljs-keyword">get</span> <span class="hljs-number">802</span> kB of archives. After unpacking <span class="hljs-number">5.510</span> kB will be used.The following packages have unmet dependencies: libnuma-dev : Depends: libnuma1 (= <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) but <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1<span class="hljs-number">.1</span> <span class="hljs-keyword">is</span> installed.The following actions will resolve these dependencies:     Keep the following packages at their current version:<span class="hljs-number">1</span>)     libhwloc-dev [Not Installed]                       <span class="hljs-number">2</span>)     libnuma-dev [Not Installed]                        <span class="hljs-number">3</span>)     libopenmpi-dev [Not Installed]                     Accept <span class="hljs-keyword">this</span> solution? [Y/n/q/?] nThe following actions will resolve these dependencies:     Downgrade the following packages:                               <span class="hljs-number">1</span>)     libnuma1 [<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1<span class="hljs-number">.1</span> (now) -&gt; <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1 (xenial)]Accept <span class="hljs-keyword">this</span> solution? [Y/n/q/?] YThe following packages will be DOWNGRADED:  libnuma1 The following NEW packages will be installed:  libhwloc-dev&#123;a&#125; libibverbs-dev&#123;a&#125; libnuma-dev&#123;a&#125; libopenmpi-dev <span class="hljs-number">0</span> packages upgraded, <span class="hljs-number">4</span> newly installed, <span class="hljs-number">1</span> downgraded, <span class="hljs-number">0</span> to remove <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> <span class="hljs-keyword">not</span> upgraded.Need to <span class="hljs-keyword">get</span> <span class="hljs-number">823</span> kB of archives. After unpacking <span class="hljs-number">5.510</span> kB will be used.Do you want to <span class="hljs-keyword">continue</span>? [Y/n/?] YGet: <span class="hljs-number">1</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/main amd64 libnuma1 amd64 2.0.11-1ubuntu1 [21,0 kB]</span>Get: <span class="hljs-number">2</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/main amd64 libnuma-dev amd64 2.0.11-1ubuntu1 [31,7 kB]</span>Get: <span class="hljs-number">3</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/universe amd64 libhwloc-dev amd64 1.11.2-3 [155 kB]</span>Get: <span class="hljs-number">4</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/main amd64 libibverbs-dev amd64 1.1.8-1.1ubuntu2 [77,6 kB]</span>Get: <span class="hljs-number">5</span> http:<span class="hljs-comment">//ftp.sjtu.edu.cn/ubuntu xenial/universe amd64 libopenmpi-dev amd64 1.10.2-8ubuntu1 [537 kB]</span>Fetched <span class="hljs-number">823</span> kB <span class="hljs-keyword">in</span> <span class="hljs-number">2</span>s (<span class="hljs-number">275</span> kB/s)         dpkg: warning: downgrading libnuma1:amd64 <span class="hljs-keyword">from</span> <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1<span class="hljs-number">.1</span> to <span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1(Reading database ... <span class="hljs-number">180946</span> files <span class="hljs-keyword">and</span> directories currently installed.)Preparing to unpack .../libnuma1_2<span class="hljs-number">.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1_amd64.deb ...Unpacking libnuma1:amd64 (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) over (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1<span class="hljs-number">.1</span>) ...Selecting previously unselected package libnuma-dev:amd64.Preparing to unpack .../libnuma-dev_2<span class="hljs-number">.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1_amd64.deb ...Unpacking libnuma-dev:amd64 (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) ...Selecting previously unselected package libhwloc-dev:amd64.Preparing to unpack .../libhwloc-dev_1<span class="hljs-number">.11</span><span class="hljs-number">.2</span><span class="hljs-number">-3</span>_amd64.deb ...Unpacking libhwloc-dev:amd64 (<span class="hljs-number">1.11</span><span class="hljs-number">.2</span><span class="hljs-number">-3</span>) ...Selecting previously unselected package libibverbs-dev.Preparing to unpack .../libibverbs-dev_1<span class="hljs-number">.1</span><span class="hljs-number">.8</span><span class="hljs-number">-1.1</span>ubuntu2_amd64.deb ...Unpacking libibverbs-dev (<span class="hljs-number">1.1</span><span class="hljs-number">.8</span><span class="hljs-number">-1.1</span>ubuntu2) ...Selecting previously unselected package libopenmpi-dev.Preparing to unpack .../libopenmpi-dev_1<span class="hljs-number">.10</span><span class="hljs-number">.2</span><span class="hljs-number">-8</span>ubuntu1_amd64.deb ...Unpacking libopenmpi-dev (<span class="hljs-number">1.10</span><span class="hljs-number">.2</span><span class="hljs-number">-8</span>ubuntu1) ...Processing triggers <span class="hljs-keyword">for</span> libc-bin (<span class="hljs-number">2.23</span><span class="hljs-number">-0</span>ubuntu10) ...Processing triggers <span class="hljs-keyword">for</span> man-db (<span class="hljs-number">2.7</span><span class="hljs-number">.5</span><span class="hljs-number">-1</span>) ...Setting up libnuma1:amd64 (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) ...Setting up libnuma-dev:amd64 (<span class="hljs-number">2.0</span><span class="hljs-number">.11</span><span class="hljs-number">-1</span>ubuntu1) ...Setting up libhwloc-dev:amd64 (<span class="hljs-number">1.11</span><span class="hljs-number">.2</span><span class="hljs-number">-3</span>) ...Setting up libibverbs-dev (<span class="hljs-number">1.1</span><span class="hljs-number">.8</span><span class="hljs-number">-1.1</span>ubuntu2) ...Setting up libopenmpi-dev (<span class="hljs-number">1.10</span><span class="hljs-number">.2</span><span class="hljs-number">-8</span>ubuntu1) ...update-alternatives: using /usr/lib/openmpi/include to provide /usr/include/mpi (mpi) <span class="hljs-keyword">in</span> <span class="hljs-built_in">auto</span> modeProcessing triggers <span class="hljs-keyword">for</span> libc-bin (<span class="hljs-number">2.23</span><span class="hljs-number">-0</span>ubuntu10) ...</code></pre><p>按照上述方法（主要是17、15行）全部处理好包的版本和依赖问题，那么就可以一次输入一开始的那段指令，安装所有的包了。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sublime乱码解决方法</title>
    <link href="/2019/03/26/2019-03-26-sublime%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2019/03/26/2019-03-26-sublime%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>sublime text 3是一款非常好用的代码编辑器，通过一些配置可以实现多种语言的编译运行，但是也会遇到出现中文显示乱码或者运行程序之后输出结果为乱码，今天就针对这个问题进行一个汇总。</p><p>对于代码中中文注释或其他内容出现乱码，通常情况下使用"ConvertToUTF8"这个插件就可以解决问题，如果解决不了，可以尝试在文本文件中另存为，保存编码格式从ASCII修改为UTF-8，复制另存的代码，然后删除之前在sublime中出现乱码的文件，重新创建并将代码粘贴。（如果没有解决，可留言交流或者在看看其他解决方法）</p><p>另外一种情况的乱码可以修改环境配置文件，常用参考配置如下，容易采用UTF-8的编码。（"-fexec-charset=gbk"这句一定要加上）</p><p>C/C++：</p><pre><code class="hljs C++"> &#123; <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;gcc&quot;</span>, <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>, <span class="hljs-string">&quot;-fexec-charset=gbk&quot;</span>,<span class="hljs-string">&quot;-o&quot;</span>, <span class="hljs-string">&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;$&#123;file_base_name&#125; &amp; echo. &amp; pause&quot;</span>], <span class="hljs-string">&quot;file_regex&quot;</span>: <span class="hljs-string">&quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;</span>, <span class="hljs-string">&quot;working_dir&quot;</span>: <span class="hljs-string">&quot;$&#123;file_path&#125;&quot;</span>, <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.c, source.c++&quot;</span>, <span class="hljs-string">&quot;shell&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;encoding&quot;</span>:<span class="hljs-string">&quot;UTF-8&quot;</span>,&#125;<span class="hljs-number">2.</span> 保存为g++.sublime-build即可（g++可以改成自己好记的）<span class="hljs-number">3.</span> 然后ctrl+shift+b选择g++编译</code></pre><p>或者：</p><pre><code class="hljs C++">&#123;    <span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;utf-8&quot;</span>,    <span class="hljs-string">&quot;working_dir&quot;</span>: <span class="hljs-string">&quot;$file_path&quot;</span>,    <span class="hljs-string">&quot;shell_cmd&quot;</span>: <span class="hljs-string">&quot;g++ -Wall -std=c++11 -fexec-charset=GBK \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;</span>,    <span class="hljs-string">&quot;file_regex&quot;</span>: <span class="hljs-string">&quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;</span>,    <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.c++&quot;</span>,    <span class="hljs-string">&quot;variants&quot;</span>:     [        &#123;           <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Run&quot;</span>,        <span class="hljs-string">&quot;shell_cmd&quot;</span>: <span class="hljs-string">&quot;g++ -Wall -std=c++11 -fexec-charset=GBK \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot;</span>        &#125;    ]&#125;</code></pre><p>Python：</p><pre><code class="hljs C++">&#123; <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;c:/Python36/python.exe&quot;</span>,<span class="hljs-string">&quot;-u&quot;</span>, <span class="hljs-string">&quot;$file&quot;</span>], <span class="hljs-comment">//自己安装路径</span><span class="hljs-string">&quot;file_regex&quot;</span>:<span class="hljs-string">&quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9])*&quot;</span>,<span class="hljs-string">&quot;env&quot;</span>: &#123;<span class="hljs-string">&quot;PYTHONIOENCODING&quot;</span>: <span class="hljs-string">&quot;utf8&quot;</span>&#125;, <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.python&quot;</span> &#125;</code></pre><p>Java:</p><p>预先安装JDK并配置环境变量</p><ul><li>新建JAVA_HOME C:Files.0_181（jdk绝对路径）path 最前面添加%JAVA_HOME%;%JAVA_HOME%;</li><li>新建CLASSPATH .;%JAVA_HOME%;%JAVA_HOME%.jar;%JAVA_HOME%.jar</li></ul><pre><code class="hljs C++">    &#123;<span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;javac&quot;</span>, <span class="hljs-string">&quot;-encoding&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>, <span class="hljs-string">&quot;-d&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;$file&quot;</span>],    <span class="hljs-string">&quot;file_regex&quot;</span>: <span class="hljs-string">&quot;^(...*?):([0-9]*):?([0-9]*)&quot;</span>,    <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.java&quot;</span>,    <span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;GBK&quot;</span>,    <span class="hljs-comment">//执行完上面的命令就结束</span>     <span class="hljs-comment">// 下面的命令需要按Ctrl+Shift+b来运行</span>    <span class="hljs-string">&quot;variants&quot;</span>: [&#123;        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Run&quot;</span>,        <span class="hljs-string">&quot;shell&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;java $&#123;file_base_name&#125; &amp;echo. &amp; pause&quot;</span>],        <span class="hljs-comment">// /c是执行完命令后关闭cmd窗口,</span>        <span class="hljs-comment">// /k是执行完命令后不关闭cmd窗口。</span>        <span class="hljs-comment">// echo. 相当于输入一个回车</span>        <span class="hljs-comment">// pause命令使cmd窗口按任意键后才关闭</span>        <span class="hljs-string">&quot;working_dir&quot;</span>: <span class="hljs-string">&quot;$&#123;file_path&#125;&quot;</span>,        <span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;GBK&quot;</span>    &#125;]&#125;</code></pre><p>或者写一个runJava.bat文件放在jdk的bin目录下（具体可自行搜索）：</p><pre><code class="hljs bat">@<span class="hljs-built_in">ECHO</span> OFF <span class="hljs-built_in">cd</span> %~dp1 <span class="hljs-built_in">ECHO</span> Compiling %~nx1<span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXIST</span> %~n1.class ( <span class="hljs-built_in">DEL</span> %~n1.class ) javac %~nx1 <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXIST</span> %~n1.class ( <span class="hljs-built_in">ECHO</span> [OUTPUT]:java %~n1 )</code></pre><p>配合下面的配置文件：</p><pre><code class="hljs C++">&#123;<span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;runJava.bat&quot;</span>, <span class="hljs-string">&quot;$file&quot;</span>],<span class="hljs-string">&quot;file_regex&quot;</span>: <span class="hljs-string">&quot;^(...*?):([0-9]*):?([0-9]*)&quot;</span>,<span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.java&quot;</span>,<span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;UTF-8&quot;</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《Java核心技术（卷I）》学习笔记 (一)</title>
    <link href="/2019/02/27/2019-02-27-Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2019/02/27/2019-02-27-Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="java核心技术卷i学习笔记">Java核心技术（卷I）学习笔记</h1><h2 id="第三章-java基本程序设计结构"><strong>第三章 Java基本程序设计结构</strong></h2><p>[2019-02-27]</p><ol type="1"><li><p>在Java中使用"final"指示常量，一般来说变量名使用全大写字母，且该变量只可以赋值一次。在main方法外使用"static final"定义类常量，可以在同一个类中所有的方法中使用，若定义为"public"则可以再其它类中使用。</p></li><li><p>Integer是整数类，已封装，而int是基本的数据类型。</p></li><li><p>public static strictfp void main.........该方法中所有计算使用严格的浮点计算，中间结果不会截断。</p></li><li><p>常用数学函数：</p><p>Math.sin Math.cos Math.tan Math.atan Math.atan2 Math.exp Math.log Math.log10 Math.PI Math.E</p><figure><img src="C:\Users\Orion_wyc\AppData\Roaming\Typora\typora-user-images\1551248540993.png" alt="1551248540993" /><figcaption aria-hidden="true">1551248540993</figcaption></figure></li><li><p>32位的int型数字如果移位运算需要mod32，1&lt;&lt;37 &lt;=&gt; 1&lt;&lt;5。</p></li><li><p>Java中可使用"+"连接两个字符串，当某个字符串与非字符串类型P连接时，会自动将P转化成字符串类型。</p></li><li><p>Java中不可直接修改字符串某个位置具体的字符，但是可以修改整个字符串变量，例如，str = str.substring(0,3) + "p!",可将原来的str(内容是Hel)改为"Help!"。</p><p>String类对象被称为不可变对象。</p><p>检测两个字符串（变量）是否相等可使用s.equals(p)。</p><p><strong>（P50）具体参见Java String类 API文档</strong></p></li><li><p>有时要检查一个字符串既不是null 也不为空串，这种情况下就需要使用以下条件： if (str != null &amp;&amp; str.length() != 0)</p></li><li><p><strong><em>码点与代码单元部分暂时略过</em></strong></p></li><li><p>使用字符串构建器(StringBuilder类)来构建多个短小字符（串）的拼接字符串，最后使用builder.toString方法来得到一个完整的字符串。</p></li><li><p>（卷I）【P58】 printf 格式化输出控制字符，【P60】时间输出格式，文件读写等。</p></li><li><p>在C++ 中， 可以在嵌套的块中重定义一个变量。在内层定义的变量会覆盖在 外层定义的变量。这样， 有可能会导致程序设计错误， 因此在Java 中不允许这样做。</p></li><li><p>Java中的switch-case结构与C语言中相同：</p><pre><code class="hljs Java"><span class="hljs-keyword">switch</span> (choice)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-comment">// bad input</span><span class="hljs-keyword">break</span>;&#125;</code></pre></li><li><p>【P76-78】Java大数计算 BigInteger（整数）和BigDecimal（浮点数）</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//计算1000!</span>        BigInteger ans = BigInteger.valueOf(<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)&#123;            BigInteger input = BigInteger.valueOf(i);            ans = ans.multiply(input);        &#125;        System.out.print(ans);    &#125;&#125;</code></pre></li><li><p>Java中数组声明方式有二：Type[] a或者Type a[]，一般使用前者，只有Type[] a = new Type[N]，才算声明了一个长度为N的数组。多维数组的声明相同，并且可以声明不规则长度的数组，先初始化行数，在分配每一行的长度大小。【P89】</p><p>int[] small Primes = { 2, 3, 5, 7, 11, 13 };//不使用new来初始化</p><p>small Primes = new int[] { 17, 19, 23, 29, 31, 37 };//重新初始化</p><p>--匿名数组？？？</p><p>copyOf(array,arraylength)数组拷贝。</p></li><li><p>for each循环，功能与C++、Python相同。</p><pre><code class="hljs Java"></code></pre></li><li><p>命令行参数 "String[] agrs"，网上有详细说明。</p></li></ol><p><strong>[2019-02-28]--还未UP</strong></p><h2 id="第四章-对象与类">第四章 对象与类</h2><ol type="1"><li><p>OOP三特性：对象的行为、状态和标识。</p></li><li><p>类之间三大关系：</p><p>依赖(uses-a)--如果一个类的方法操纵另一个 类的对象，我们就说一个类依赖于另一个类</p><p>聚合(has-a)--聚合关系意味着类A 的对象包含类B 的对象</p><p>集成(is-a)--用于表示特殊与一般关系。</p></li><li><p>UML ( Unified Modeling Language , 统一建模语言）绘制类图（软工未选修）。</p><figure><img src="C:\Users\Orion_wyc\AppData\Roaming\Typora\typora-user-images\1551352375509.png" alt="1551352375509" /><figcaption aria-hidden="true">1551352375509</figcaption></figure></li><li><p>LocalDate类（感觉好奇怪）</p><p>只访问对象而不修改对象的方法有时称为访问器方法(accesser method)</p><p>会对对象造成影响，改变其状态的方法叫做更改器方法(mutator method)</p><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.time.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Orion233</span><span class="hljs-comment"> * print this month‘s calendar</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        LocalDate date = LocalDate.now();        <span class="hljs-keyword">int</span> month = date.getMonthValue();        <span class="hljs-keyword">int</span> today = date.getDayOfMonth() ;        date = date.minusDays(today - <span class="hljs-number">1</span>); <span class="hljs-comment">// Set to start of month</span>        DayOfWeek weekday = date.getDayOfWeek() ;        <span class="hljs-keyword">int</span> value = weekday.getValue();        System.out.println(<span class="hljs-string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span> + value) ;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; value; i++)            System.out.print(<span class="hljs-string">&quot;    &quot;</span>);        <span class="hljs-keyword">while</span> (date.getMonthValue() == month)        &#123;            System.out.printf(<span class="hljs-string">&quot;%3d&quot;</span>, date.getDayOfMonth()) ;            <span class="hljs-keyword">if</span> (date.getDayOfMonth() == today)                System.out.print(<span class="hljs-string">&quot;*&quot;</span>);            <span class="hljs-keyword">else</span>                System.out.print(<span class="hljs-string">&quot; &quot;</span>) ;            date = date.plusDays(<span class="hljs-number">1</span>) ;            <span class="hljs-keyword">if</span> (date.getDayOfWeek() .getValue() == <span class="hljs-number">1</span>) System.out.println();        &#125;        <span class="hljs-keyword">if</span> (date.getDayOfWeek() .getValue() != <span class="hljs-number">1</span>) System.out.println() ;    &#125;&#125;</code></pre></li><li><p>Java构造器（所有的Java 对象都是在堆中构造的）：</p><p>•构造器与类同名 •每个类可以有一个以上的构造器 •构造器可以有0 个、1 个或多个参数 •构造器没有返回值 •构造器总是伴随着new 操作一起调用</p></li><li><p>隐式参数与显式参数</p><p>this标识隐式参数，这样可以更好地实例域与局部变量明显地区分开来。</p><p><strong>成员变量：</strong></p><p>​ ①成员变量定义在类中，在整个类中都可以被访问。</p><p>​ ②成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。</p><p>​ ③成员变量有默认初始化值。</p><p><strong>局部变量：</strong></p><p>​ ①局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。</p><p>​ ②局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。</p><p>​ ③局部变量没有默认初始化值</p><pre><code class="hljs Java">进行局部运算的时候，局部变量会屏蔽全局变量。Example：Class A&#123;<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>；   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function"></span>&#123;A c = <span class="hljs-keyword">new</span> A(); a = <span class="hljs-number">2</span>;System.out.println(a);System.out.println(c.a);&#125;&#125;</code></pre><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age=<span class="hljs-number">1000</span>;<span class="hljs-comment">//定义成员变量，年龄为1000</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        age=age;        System.out.println(<span class="hljs-string">&quot;方法内的年龄&quot;</span>+age);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;我的年龄是&quot;</span>+age+<span class="hljs-string">&quot;.&quot;</span>);    &#125;&#125;......Person p=<span class="hljs-keyword">new</span> Person();p.setAge(<span class="hljs-number">20</span>);p.sayHello();......Results:<span class="hljs-comment">//方法内的年龄20</span><span class="hljs-comment">//我的年龄是1000.</span><span class="hljs-comment">/*</span><span class="hljs-comment">如果不同名，那么方法内的变量名代表成员变量；如果同名，那么方法内的变量名就只表示局部变量了，和成员变量一毛钱关系都没有了。</span><span class="hljs-comment">所以，首先当我们创建了一个Person对象p，在创建对象的时候就已经完成了成员变量的初始化了。成员变量age的初始值是1000。</span><span class="hljs-comment">当我们p.setAge(20)的时候，其实这个20只在setAge这个方法内起作用，所以输出了方法内年龄20，执行完这句话后，20就被销毁了。</span><span class="hljs-comment">然后执行sayHello，它里面的age代表的是成员变量的值，所以依旧是1000。</span><span class="hljs-comment"></span><span class="hljs-comment">所以这里应该使用this表示当前对象。</span><span class="hljs-comment">this.age在这里具体表示p对象的age(即p对象的成员变量age)的值是20。</span><span class="hljs-comment">*/</span></code></pre></li><li><p>方法可以访问所属类的私有特性（ feature ), 而不仅限于访问隐式参数的私有特性。一个方法可以访问所属类的所有 对象的私有数据。</p></li><li><p>另参考：</p></li><li><p>可以将实例域定义为final。构建对象时必须初始化这样的域。也就是说， 必须确保在每一个构造器执行之后， 这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。例如， 可以将Employee 类中的name 域声明为final , 因为在对象构建之后， 这个值不会再被修改， 即没有setName 方法。</p><p>PS：StringBUilder的例子不大一样，他可以修改，见【P112】</p><p>[2019-03-01]</p></li><li><p>如果将域定义为static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域 却都有自己的一份拷贝。</p><p>参考资料：<a href="https://www.cnblogs.com/dolphin0520/p/3799052.html">Java中的static关键字解析</a></p><p>静态变量、静态常量</p><p>静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。</p><p>--What is a field in java?</p><p>--A field is an attribute. A field may be a class’s variable, an object’s variable, an object’s method’s variable, or a parameter of a function.</p><p>field，域是一种属性，可以是一个类变量，一个对象变量，一个对象方法变量或者是一个函数的参数。（补充，class's variables，类的实例变量和静态变量称为class's variables，类属变量，也称类变量或数据域，其实翻译成属性也可以，类属性，听起来不会怪怪的，来自百度百科）。</p></li><li><p>可以使用对象调用静态方法e.g.可以用 harry.getNextId( ) 代替 Employee.getNextId( )，但是建议使用类名，而不是对象来调用 静态方法。</p><p>在下面2种情?下使用静态方法：</p><p>&lt;1&gt; 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow )</p><p>&lt;2&gt; 一个方法只需要访问类的静态域（例如：Employee.getNextld）</p></li><li><p>P132 4.4.4 工厂方法</p><ol type="1"><li><p>博客出处：http://blog.csdn.net/cgwshxs/archive/2008/12/05/3455136.aspx</p><p><strong>静态工厂方法讲解<一></strong> ​ 创建类的实例的最常见的方式是用new语句调用类的构造方法。在这种情况下，程序可以创建类的任意多个实例，每执行一条new语句，都会导致Java虚拟机的堆区中产生一个新的对象。假如类需要进一步封装创建自身实例的细节，并且控制自身实例的数目，那么可以提供静态工厂方法。 例如Class实例是Java虚拟机在加载一个类时自动创建的，程序无法用new语句创建java.lang.Class类的实例，因为Class类没有提供public类型的构造方法。为了使程序能获得代表某个类的Class实例，在Class类中提供了静态工厂方法</p><pre><code class="hljs reasonml"><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(String <span class="hljs-params">name</span>)</span>，它的使用方式如下：Class c=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;Sample&quot;</span>)</span>; <span class="hljs-comment">//返回代表Sample类的实例</span></code></pre><p>静态工厂方法与用new语句调用的构造方法相比，有以下区别。</p><p>（1）构造方法的名字必须与类名相同。这一特性的优点是符合Java语言的规范，缺点是类的所有重载的构造方法的名字都相同，不能从名字上区分每个重载方法，容易引起混淆。静态工厂方法的方法名可以是任意的，这一特性的优点是可以提高程序代码的可读性，在方法名中能体现与实例有关的信息。例如Gender类有两个静态工厂方法：getFemale()和getMale()。</p><pre><code class="hljs Java">Gender.java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gender</span></span>&#123;   <span class="hljs-keyword">private</span> String description;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Gender female=<span class="hljs-keyword">new</span> Gender(<span class="hljs-string">&quot;女&quot;</span>);   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Gender male=<span class="hljs-keyword">new</span> Gender(<span class="hljs-string">&quot;男&quot;</span>);   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Gender</span><span class="hljs-params">(String description)</span></span>&#123;<span class="hljs-keyword">this</span>.description=description;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Gender <span class="hljs-title">getFemale</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-keyword">return</span> female;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Gender <span class="hljs-title">getMale</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> male;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> description;&#125;&#125;</code></pre><p>这一特性的缺点是与其他的静态方法没有明显的区别，使用户难以识别类中到底哪些静态方法专门负责返回类的实例。为了减少这一缺点带来的负面影响，可以在为静态工厂方法命名时尽量遵守约定俗成的规范，当然这不是必需的。目前比较流行的规范是把静态工厂方法命名为valueOf或者getInstance。</p><pre><code class="hljs Java">valueOf：该方法返回的实例与它的参数具有同样的值，例如：       Integer a=Integer.valueOf(<span class="hljs-number">100</span>); <span class="hljs-comment">//返回取值为100的Integer对象</span></code></pre><p>从上面代码可以看出，valueOf()方法能执行类型转换操作，在本例中，把int类型的基本数据转换为Integer对象。</p><p>getInstance：返回的实例与参数匹配，例如：</p><p>//返回符合中国标准的日历</p><pre><code class="hljs Java">Calendar cal=Calendar.getInstance(Locale.CHINA);</code></pre><p>（2）每次执行new语句时，都会创建一个新的对象。而静态工厂方法每次被调用的时候，是否会创建一个新的对象完全取决于方法的实现。</p><p>（3）new语句只能创建当前类的实例，而静态工厂方法可以返回当前类的子类的实例，这一特性可以在创建松耦合的系统接口时发挥作用。</p><p>静态工厂方法最主要的特点是：每次被调用的时候，不一定要创建一个新的对象。利用这一特点，静态工厂方法可用来创建以下类的实例。 单例类：只有惟一的实例的类。 枚举类：实例的数量有限的类。 具有实例缓存的类：能把已经创建的实例暂且存放在缓存中的类。 具有实例缓存的不可变类：不可变类的实例一旦创建，其属性值就不会被改变。</p><p><strong>静态工厂方法讲解<二></strong> 实例化对象的方法：</p><p>1.构造函数。</p><p>2.静态工厂方法。（我不常用，但JAVA平台库有好多例子）</p><p>对于构造函数，是新建对象是自动调用的方法，返回该对象，主要用于初始化类的成员字段。而另外一种构建对象的方式是采用静态工厂方法。静态工厂方法与别的静态方法没有什么区别，只不过该方法产生的类对象，不做其他事情，如我们常用的Sington单态模式。使用静态工厂方法主要有以下优点：</p><p>第一：静态工厂方法可以突破构造函数不能自由命名的限制，对于不同的工厂方法可以采用不同的会意的名字，是程序具有更好的可读性。JAVA平台库的java.text.Format的子类NumberFormat就有getInstance() , getPrecentInstance() , getCurrencyInstatnce()等静态方法，通过不同的名字产生特定的对象。</p><p>第二：静态工厂方法是用来产生对象用的，至于产生什么类型的对象没有限制，这就意味这只要返回原返回类型或原返回类型的子类型都可以，这样就加大了程序设计和使用的灵活行，如java.util集合框架就采用了这种优势，这样就可以更好达到封装的目的，降低API的数目和用户的使用难度，java.util.Connections是集合框架的辅助类用于对原有的集合类进行进一步封装，产生一些同步的集合，不可修改的视图。都是采用静态工厂方法实现的，至于方法内部的实现类就完全别封装了。也迫使我们使用接口编程。</p><p>第三：静态工厂方法所创建的对象可以在编译时不存在，动态创建对象，采用放射，类似SPRING的IOC容器方转。最典型的例子就是spi服务提供者框架，Service Provider Iframe 是一种用于在运行时刻产生对象的框架，达到对象的创建与使用分离，是对象的客户和对象之间解耦，增加程序的灵活性和可扩展性。既然spi可以动态创建对象，那么采用什么机制来创建什么对象，创建对象的依据是什么了，spi必须一种统一的注册机制，对于要创建的对象，应该在XML文件中配置，到时候，只要提供一个字符串，就可以凭借该字符串来创建配置的对象。简单实现如下：</p><pre><code class="hljs Java"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SPITest</span></span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map SPIMap = <span class="hljs-keyword">new</span> HashMap(); <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSPIMapIfNeccury</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">if</span>(SPIMap == <span class="hljs-keyword">null</span>)&#123; SPIMap = <span class="hljs-keyword">new</span> HashMap(); &#125; <span class="hljs-comment">//initMap user the sepecify XML </span><span class="hljs-comment">//the map key is a beanName ,the value is a Object which config by XML</span> &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getInstace</span><span class="hljs-params">(String beanName)</span></span>&#123; Object result = <span class="hljs-keyword">null</span>; <span class="hljs-keyword">try</span>&#123; <span class="hljs-keyword">if</span>(SPIMap.containsKey(beanName))&#123; result = SPIMap.get(beanName); &#125; <span class="hljs-keyword">else</span>&#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot; please config the xml file ,this bean is not exists!&quot;</span>); &#125; &#125;<span class="hljs-keyword">catch</span>(Exception exce)&#123; exce.printStackTrace(); &#125; <span class="hljs-keyword">return</span> result; &#125;&#125;</code></pre><p>可以明显看出待创建的对象具体创建哪个对象，在编译时并不知道，只有在运行时刻才知道,将对象的创建工作推迟到运行时，这即是优点，有是缺点，失去了编译检查的功能。</p></li></ol><p><strong>但静态工厂方法又有缺点：</strong></p><pre><code>第一：如果将要创建的对象的构造方法是私有的或是default的，就有可能不能创建该对象。</code></pre><p>​ 第二：采用构造函数实例化对象，是语言的规范，而静态工厂方法与其他的静态方法没有区别，就增加了用户使用的区别。但这可以尽量采用一些家喻户晓的名字解决，让用户看到改名字就知道该方法是静态工厂方法。如getInstance（）。</p></li><li><p>未完待续...</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VMWARE使用记录</title>
    <link href="/2019/01/26/2019-01-26-VMWare%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/01/26/2019-01-26-VMWare%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>#<strong>VMWare</strong> ##<strong>解决虚拟机vmware安装64位系统“此主机支持 Intel VT-x，但 Intel VT-x 处于禁用状态”的问题</strong></p><p><strong>所遇到的情况</strong> 虚拟机使用的是VMware Workstation ，并且首次在虚拟机体验64 位系统。在新建好虚拟机，运行时候就出现了VMware Workstation 的提醒：此主机支持 Intel VT-x，但 Intel VT-x 处于禁用状态。如图：</p><pre><code class="hljs angelscript">提示信息：已将该虚拟机配置为使用 <span class="hljs-number">64</span> 位客户机操作系统。但是，无法执行 <span class="hljs-number">64</span> 位操作。此主机支持 Intel VT-x，但 Intel VT-x 处于禁用状态。如果已在 BIOS/固件设置中禁用 Intel VT-x，或主机自更改此设置后从未重新启动，则 Intel VT-x 可能被禁用。(<span class="hljs-number">1</span>) 确认 BIOS/固件设置中启用了 Intel VT-x 并禁用了“可信执行”。(<span class="hljs-number">2</span>) 如果这两项 BIOS/固件设置有一项已更改，请重新启动主机。(<span class="hljs-number">3</span>) 如果您在安装 VMware Workstation 之后从未重新启动主机，请重新启动。(<span class="hljs-number">4</span>) 将主机的 BIOS/固件更新至最新版本。有关更多详细信息，请参见 http:<span class="hljs-comment">//vmware.com/info?id=152。</span></code></pre><p><strong>解决方法</strong></p><p>看上面的提示 也就很好解决了：直接修改BIOS设置即可</p><p>以下以个人HP-暗影精灵2电脑为例：</p><p>1、关机，开机，在启动时，按F10进入BIOS 设置页面；</p><p>2、选择 Security，再选择Virtual ization并点击enter建进入该功能，在新功能中选择Intel (R) Virtualization Technology ，此时该选项应该是disabled（关闭）的；</p><p>3、将Disabled（关闭）改为 Enabled（开启）；</p><p>4、保存设置，点击F10，保存后退出，重启即可</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flex-Bison在windows下的安装与使用</title>
    <link href="/2019/01/15/2018-11-14-Flex-Bison%E5%AE%89%E8%A3%85/"/>
    <url>/2019/01/15/2018-11-14-Flex-Bison%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><strong>Linux下安装：</strong></p><pre><code class="hljs shell">sudo apt-get install flex bisonflex -hbison -h</code></pre><p><strong>Windows下安装：</strong> Flex下载地址：http://gnuwin32.sourceforge.net/packages/flex.htm Biosn下载地址：http://gnuwin32.sourceforge.net/packages/bison.htm</p><p>下载选择 <strong>Complete Package，except sources</strong> <img src="https://img-blog.csdnimg.cn/2018102715103511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29yaW9uX3Bpc3RhY2hpbw==,size_27,color_FFFFFF,t_70" alt="下再说明" /></p><p>安装过程和一般的win应用一样，点击setup.exe安装，默认安装位置是<strong>C盘</strong>，可以自己修改，先安装 <strong>Flex</strong> 在安装 <strong>Bison</strong>（比如我的目录是“<strong>D:</strong>”，<em>一般来说Bison的安装位置和Flex一致，如果不一致请修改成一样</em>）</p><p>安装完成后打开安装目录（flex和bison在一起）： <img src="https://img-blog.csdnimg.cn/20181027151608641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29yaW9uX3Bpc3RhY2hpbw==,size_27,color_FFFFFF,t_70" alt="就是这个样子的" /></p><p><strong>接下来配置环境变量：</strong> 将“**D:*”添加到**“系统变量**”中。</p><p><strong>接下来在cmd中查看是否安装成功：</strong></p><pre><code class="hljs cmd">flex -V      //就是大写的VVVVVVVV！！！！！bison -V     //就是大写的VVVVVVVV！！！！！</code></pre><p>可以得到如下结果 <img src="https://img-blog.csdnimg.cn/2018102715204969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29yaW9uX3Bpc3RhY2hpbw==,size_27,color_FFFFFF,t_70" alt="cmd结果" /></p><pre><code>[Tips]1.如果没有出现以上结果，请重启之后再试。（默认会修改环境变量）2.作为词法分析器使用并编译C代码需要在安装GCC，自行百度。</code></pre><p><strong>下面进行一个小测试：</strong> 代码要求：进行数字转换，比如2e3转换成2000、1.23e1转换成12.3...</p><p>这里发个链接供参考：https://blog.csdn.net/mayuko2012/article/details/51207192?locationNum=5</p><p>JNU CS1604 Orion233</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用Flex构造简易C语言词法分析器</title>
    <link href="/2019/01/15/2018-11-14-C%E8%AF%AD%E8%A8%80%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <url>/2019/01/15/2018-11-14-C%E8%AF%AD%E8%A8%80%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>Flex构造C语言词法分析器</strong> 可以识别大部分的C语言关键字和标识符，可以去除注释（多行单行都可以），可以识别整数和浮点数，可以识别错误的浮点数。</p><p>lex文件结构：</p><pre><code class="hljs cpp"> [第一部分：定义段]<span class="hljs-comment">/*</span><span class="hljs-comment"> *按照C语言语法，声明文件包含，宏定义，常数定义，全局变量及外部变量定义，函数声明等</span><span class="hljs-comment"> */</span> %% 第二部分：词法规则段  <span class="hljs-comment">/*</span><span class="hljs-comment"> *核心部分，正则定义和状态定义（解释见后）</span><span class="hljs-comment"> */</span> %% 第三部分：辅助函数段]  <span class="hljs-comment">/*</span><span class="hljs-comment"> * 辅助函数段用C语言语法来写，辅助函数一般是在词法规则段中用到的函数。这一部分一般会被直接拷贝到lex.yy.c中。</span><span class="hljs-comment"> */</span></code></pre><p>状态定义：</p><pre><code class="hljs c"><span class="hljs-string">&quot;//&quot;</span>.* &#123;&#125;<span class="hljs-string">&quot;/*&quot;</span> &#123;BEGIN COMMENT;&#125;&lt;COMMENT&gt;<span class="hljs-string">&quot;*/&quot;</span> &#123;BEGIN INITIAL;&#125;&lt;COMMENT&gt;. &#123;&#125;</code></pre><p>这一部分是根据不同的状态使用不同的规则，比如要识别多行注释，则添加BEGIN COMMENT即可转移到&lt; COMMENT &gt;状态。</p><p>代码如下：</p><pre><code class="hljs cpp">在这里插入代码片<span class="hljs-comment">/*</span><span class="hljs-comment"> *t2.lex 词法分析器</span><span class="hljs-comment"> *班级：计科1604</span><span class="hljs-comment"> *学号：1030416414</span><span class="hljs-comment"> *姓名：wyc（ORION233）</span><span class="hljs-comment"> *时间：2018-11-4</span><span class="hljs-comment"> */</span>%option pointer%option noyywrap%x COMMENT%&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 100</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXTYPE 10</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSTR 15</span><span class="hljs-keyword">char</span> *a[MAXTYPE] = &#123;<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;for&quot;</span>,<span class="hljs-string">&quot;integer&quot;</span>,<span class="hljs-string">&quot;decimal&quot;</span>,<span class="hljs-string">&quot;identify&quot;</span>,<span class="hljs-string">&quot;bracket&quot;</span>,<span class="hljs-string">&quot;QUOTE&quot;</span>,<span class="hljs-string">&quot;OPT&quot;</span>,<span class="hljs-string">&quot;float&quot;</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">int</span> line;<span class="hljs-comment">//store line numbers</span><span class="hljs-keyword">int</span> id;<span class="hljs-comment">// store tag</span><span class="hljs-keyword">char</span> text[MAXSTR];<span class="hljs-comment">//store yytext</span>&#125;tag[MAXLEN];<span class="hljs-comment">//store tags</span><span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//error flag</span><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//array notation counter</span>    <span class="hljs-keyword">int</span> line=<span class="hljs-number">1</span>;<span class="hljs-comment">//line counter</span>%&#125;DIGIT [<span class="hljs-number">0</span><span class="hljs-number">-9</span>]OINTEGER [<span class="hljs-number">1</span><span class="hljs-number">-9</span>]&#123;DIGIT&#125;*INTEGER (<span class="hljs-string">&quot;+&quot;</span>|<span class="hljs-string">&quot;-&quot;</span>)?&#123;OINTEGER&#125;DECIMAL &#123;INTEGER&#125;(.&#123;OINTEGER&#125;)?LETTER [a-zA-Z]ID (&#123;LETTER&#125;|_)(&#123;LETTER&#125;|_|&#123;DIGIT&#125;)*OPT (<span class="hljs-string">&quot;+=&quot;</span>|<span class="hljs-string">&quot;-=&quot;</span>|<span class="hljs-string">&quot;*=&quot;</span>|<span class="hljs-string">&quot;/=&quot;</span>|<span class="hljs-string">&quot;+&quot;</span>|<span class="hljs-string">&quot;-&quot;</span>|<span class="hljs-string">&quot;*&quot;</span>|<span class="hljs-string">&quot;/&quot;</span>|<span class="hljs-string">&quot;&lt;=&quot;</span>|<span class="hljs-string">&quot;&gt;=&quot;</span>|<span class="hljs-string">&quot;==&quot;</span>|<span class="hljs-string">&quot;=&quot;</span>)INDEX &#123;DIGIT&#125;+(\.&#123;DIGIT&#125;+)?e([+-])?&#123;DIGIT&#125;+ERROR &#123;DIGIT&#125;+(\.&#123;DIGIT&#125;+)?e%%<span class="hljs-string">&quot;//&quot;</span>.* &#123;&#125;<span class="hljs-string">&quot;/*&quot;</span> &#123;BEGIN COMMENT;&#125;&lt;COMMENT&gt;<span class="hljs-string">&quot;*/&quot;</span> &#123;BEGIN INITIAL;&#125;&lt;COMMENT&gt;. &#123;&#125;\n &#123;++line;&#125;(<span class="hljs-keyword">int</span>|<span class="hljs-keyword">float</span>|<span class="hljs-keyword">double</span>|<span class="hljs-keyword">short</span>) &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">0</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//has bugs--use strcpy is ok,no pointer </span><span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;<span class="hljs-keyword">for</span> &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">1</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;INTEGER&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">2</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;DECIMAL&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">3</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;ID&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">4</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;(<span class="hljs-string">&quot;(&quot;</span>|<span class="hljs-string">&quot;)&quot;</span>|<span class="hljs-string">&quot;&#123;&quot;</span>|<span class="hljs-string">&quot;&#125;&quot;</span>|<span class="hljs-string">&quot;[&quot;</span>|<span class="hljs-string">&quot;]&quot;</span>) &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">5</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;<span class="hljs-string">&quot;\&quot;&quot;</span> &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">6</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;OPT&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">7</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;INDEX&#125; &#123;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">8</span>;<span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); <span class="hljs-comment">//printf(&quot;%s : %d--%d\n&quot;,tag[cnt].text,yyleng,cnt);</span>cnt++;&#125;&#123;ERROR&#125; &#123;flag = <span class="hljs-number">1</span>;tag[cnt].line = line;tag[cnt].id = <span class="hljs-number">-1</span>;<span class="hljs-comment">//soso</span><span class="hljs-built_in">strcpy</span>(tag[cnt].text,yytext); cnt++;&#125;. &#123;&#125;%%<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> *begin lexical analysis</span><span class="hljs-comment"> *present all the tags</span><span class="hljs-comment"> *but ...</span><span class="hljs-comment"> */</span>yylex();<span class="hljs-keyword">if</span>(flag) &#123;<span class="hljs-comment">//print ERRORS</span><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<span class="hljs-keyword">if</span>(tag[i].id == <span class="hljs-number">-1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error type A at Line %d: Illegal floating point number \&quot;%s\&quot;.\n&quot;</span>,tag[i].line,tag[i].text);<span class="hljs-keyword">break</span>;&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<span class="hljs-keyword">if</span>(tag[i].id == <span class="hljs-number">5</span>)&#123;<span class="hljs-comment">//print &quot;QUOTE&quot;</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;line%d:(%s, \&quot;%s\&quot;)\n&quot;</span>,tag[i].line,a[tag[i].id],tag[i].text);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;line%d:(%s, %s)\n&quot;</span>,tag[i].line,a[tag[i].id],tag[i].text);&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/01/15/hello-world/"/>
    <url>/2019/01/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><p><span class="math inline">\(Late_x \frac{1}{x^2}\)</span></p><h3 id="create-a-new-post">Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
